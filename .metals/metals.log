[0m2021.03.26 16:02:29 INFO  Started: Metals version 0.10.0 in workspace '/Users/davidashley/Documents/Scala/scalabackend/scalabackend' for client vscode 1.54.3.[0m
[0m2021.03.26 16:02:29 INFO  time: initialize in 0.43s[0m
[0m2021.03.26 16:02:29 WARN  Build server is not auto-connectable.[0m
[0m2021.03.26 16:03:34 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/HomeController.scala[0m
[0m2021.03.26 16:03:37 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m
package controllers

import javax.inject._
import play.api._
import play.api.mvc._

/**
 * This controller creates an `Action` to handle HTTP requests to the
 * application's home page.
 */
@Singleton
class HomeController @Inject()(val controllerComponents: ControllerComponents) extends BaseController {

  /**
   * Create an Action to render an HTML page.
   *
   * The configuration in the `routes` file means that this method
   * will be called when the application receives a `GET` request with
   * a path of `/`.
   */
  def index() = Action { implicit request: Request[AnyContent] =>
    Ok(views.html.index())
  }
}

[0m2021.03.26 16:03:39 INFO  time: code lens generation in 4.06s[0m
[0m
2021.03.26 16:04:56 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/db/db.scala[0m



Mar 26, 2021 4:05:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17

Mar 26, 2021 4:05:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 21

Mar 26, 2021 4:05:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25

Mar 26, 2021 4:05:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 30

Mar 26, 2021 4:05:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 34
[0m2021.03.26 16:05:35 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/db/ScalaJdbc.scala[0m




Mar 26, 2021 4:06:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 40
[0m2021.03.26 16:06:02 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/db/ScalaJdbcConnectSelect.scala[0m






[0m2021.03.26 16:06:12 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/db/ScalaJdbcConnectSelect.scala[0m
package jdbc

import java.sql.DriverManager
import java.sql.Connection

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def main(args: Array[String]) {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.jdbc.Driver"
    val url = "jdbc:mysql://localhost/mysql"
    val username = "root"
    val password = "root"

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT host, user FROM user")
      while ( resultSet.next() ) {
        val host = resultSet.getString("host")
        val user = resultSet.getString("user")
        println("host, user = " + host + ", " + user)
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}
[0m2021.03.26 16:06:20 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/db/ScalaJdbcConnectSelect.scala[0m
package jdbc

import java.sql.DriverManager
import java.sql.Connection

/** A Scala JDBC connection example by Alvin Alexander,
  * https://alvinalexander.com
  */
object ScalaJdbcConnectSelect {

  def main(args: Array[String]) {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.jdbc.Driver"
    val url = "jdbc:mysql://localhost/mysql"
    val username = "root"
    val password = "root"

    // there's probably a better way to do this
    var connection: Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT host, user FROM user")
      while (resultSet.next()) {
        val host = resultSet.getString("host")
        val user = resultSet.getString("user")
        println("host, user = " + host + ", " + user)
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

[0m2021.03.26 16:16:18 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/db/ScalaJdbcConnectSelect.scala[0m
package jdbc

import java.sql.DriverManager
import java.sql.Connection

/** A Scala JDBC connection example by Alvin Alexander,
  * https://alvinalexander.com
  */
object ScalaJdbcConnectSelect {

  def main(args: Array[String]) {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.jdbc.Driver"
    val url = "jdbc:mysql://localhost/mysql"
    val username = "admin"
    val password = "Watayo420$"

    // there's probably a better way to do this
    var connection: Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT host, user FROM user")
      while (resultSet.next()) {
        val host = resultSet.getString("host")
        val user = resultSet.getString("user")
        println("host, user = " + host + ", " + user)
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

[0m2021.03.26 16:17:16 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/db/ScalaJdbcConnectSelect.scala[0m
package jdbc

import java.sql.DriverManager
import java.sql.Connection

/** A Scala JDBC connection example by Alvin Alexander,
  * https://alvinalexander.com
  */
object ScalaJdbcConnectSelect {

  def main(args: Array[String]) {
    println("JDBC Code running..")
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.jdbc.Driver"
    val url = "jdbc:mysql://localhost/mysql"
    val username = "admin"
    val password = "Watayo420$"

    // there's probably a better way to do this
    var connection: Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT host, user FROM user")
      while (resultSet.next()) {
        val host = resultSet.getString("host")
        val user = resultSet.getString("user")
        println("host, user = " + host + ", " + user)
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

[0m2021.03.26 16:17:19 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/db/ScalaJdbcConnectSelect.scala[0m
package jdbc

import java.sql.DriverManager
import java.sql.Connection

/** A Scala JDBC connection example by Alvin Alexander,
  * https://alvinalexander.com
  */
object ScalaJdbcConnectSelect {

  def main(args: Array[String]) {
    println("JDBC Code running...")
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.jdbc.Driver"
    val url = "jdbc:mysql://localhost/mysql"
    val username = "admin"
    val password = "Watayo420$"

    // there's probably a better way to do this
    var connection: Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT host, user FROM user")
      while (resultSet.next()) {
        val host = resultSet.getString("host")
        val user = resultSet.getString("user")
        println("host, user = " + host + ", " + user)
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

[0m2021.03.26 16:20:19 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/build.sbt[0m
name := """scalabackend"""
organization := "com.example"

version := "1.0-SNAPSHOT"

lazy val root = (project in file(".")).enablePlugins(PlayScala)

scalaVersion := "2.13.3"

libraryDependencies += guice
libraryDependencies += "org.scalatestplus.play" %% "scalatestplus-play" % "5.0.0" % Test

// Adds additional packages into Twirl
//TwirlKeys.templateImports += "com.example.controllers._"

// Adds additional packages into conf/routes
// play.sbt.routes.RoutesKeys.routesImport += "com.example.binders._"

[0m2021.03.26 16:31:27 INFO  shutting down Metals[0m
[0m2021.03.28 15:49:11 INFO  Started: Metals version 0.10.0 in workspace '/Users/davidashley/Documents/Scala/scalabackend/scalabackend' for client vscode 1.54.3.[0m
[0m2021.03.28 15:49:11 INFO  time: initialize in 0.45s[0m
[0m2021.03.28 15:49:11 WARN  Build server is not auto-connectable.[0m
[0m2021.03.28 15:49:11 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/db/ScalaJdbcConnectSelect.scala[0m
[0m2021.03.28 15:49:11 INFO  skipping build import with status 'Requested'[0m
[0m2021.03.28 15:49:15 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m
package jdbc

import java.sql.DriverManager
import java.sql.Connection

/** A Scala JDBC connection example by Alvin Alexander,
  * https://alvinalexander.com
  */
object ScalaJdbcConnectSelect {

  def main(args: Array[String]) {
    println("JDBC Code running...")
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.jdbc.Driver"
    val url = "jdbc:mysql://localhost/mysql"
    val username = "admin"
    val password = "Watayo420$"

    // there's probably a better way to do this
    var connection: Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT host, user FROM user")
      while (resultSet.next()) {
        val host = resultSet.getString("host")
        val user = resultSet.getString("user")
        println("host, user = " + host + ", " + user)
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

[0m2021.03.28 15:49:17 INFO  time: code lens generation in 4.83s[0m
[0m2021.03.28 15:50:32 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/db/ScalaJdbcConnectSelect.scala[0m
package jdbc

import java.sql.DriverManager
import java.sql.Connection

/** A Scala JDBC connection example by Alvin Alexander,
  * https://alvinalexander.com
  */
object ScalaJdbcConnectSelect {

  def main(args: Array[String]) {
    println("JDBC Code running...")
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.jdbc.Driver"
    val url = "scaladatabase-1.cmarnl7iz5vu.us-east-1.rds.amazonaws.com"
    val username = "admin"
    val password = "Watayo420$"

    // there's probably a better way to do this
    var connection: Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT host, user FROM user")
      while (resultSet.next()) {
        val host = resultSet.getString("host")
        val user = resultSet.getString("user")
        println("host, user = " + host + ", " + user)
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

[0m2021.03.28 15:51:17 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/HomeController.scala[0m
package controllers

import javax.inject._
import play.api._
import play.api.mvc._

/**
 * This controller creates an `Action` to handle HTTP requests to the
 * application's home page.
 */
@Singleton
class HomeController @Inject()(val controllerComponents: ControllerComponents) extends BaseController {

  /**
   * Create an Action to render an HTML page.
   *
   * The configuration in the `routes` file means that this method
   * will be called when the application receives a `GET` request with
   * a path of `/`.
   */
  def index() = Action { implicit request: Request[AnyContent] =>
    Ok(views.html.index())
  }
}

Mar 28, 2021 3:51:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 43
[0m2021.03.28 15:52:00 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/db/ScalaJdbcConnectSelect.scala[0m
package jdbc

import java.sql.DriverManager
import java.sql.Connection

/** A Scala JDBC connection example by Alvin Alexander,
  * https://alvinalexander.com
  */
object ScalaJdbcConnectSelect extends App {

  def main(args: Array[String]) {
    println("JDBC Code running...")
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.jdbc.Driver"
    val url = "scaladatabase-1.cmarnl7iz5vu.us-east-1.rds.amazonaws.com"
    val username = "admin"
    val password = "Watayo420$"

    // there's probably a better way to do this
    var connection: Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT host, user FROM user")
      while (resultSet.next()) {
        val host = resultSet.getString("host")
        val user = resultSet.getString("user")
        println("host, user = " + host + ", " + user)
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

[0m2021.03.28 15:53:43 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/db/ScalaJdbcConnectSelect.scala[0m
package jdbc

import java.sql.DriverManager
import java.sql.Connection

/** A Scala JDBC connection example by Alvin Alexander,
  * https://alvinalexander.com
  */
object ScalaJdbcConnectSelect extends App {

  def main(args: Unit) {
    println("JDBC Code running...")
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.jdbc.Driver"
    val url = "scaladatabase-1.cmarnl7iz5vu.us-east-1.rds.amazonaws.com"
    val username = "admin"
    val password = "Watayo420$"

    // there's probably a better way to do this
    var connection: Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT host, user FROM user")
      while (resultSet.next()) {
        val host = resultSet.getString("host")
        val user = resultSet.getString("user")
        println("host, user = " + host + ", " + user)
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

Mar 28, 2021 3:54:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 119
Mar 28, 2021 3:54:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 127
Mar 28, 2021 3:54:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 133
[0m2021.03.28 15:54:42 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/HomeController.scala[0m
package controllers

import javax.inject._
import play.api._
import play.api.mvc._

/** This controller creates an `Action` to handle HTTP requests to the
  * application's home page.
  */
@Singleton
class HomeController @Inject() (val controllerComponents: ControllerComponents)
    extends BaseController {

  /** Create an Action to render an HTML page.
    *
    * The configuration in the `routes` file means that this method
    * will be called when the application receives a `GET` request with
    * a path of `/`.
    */
  def index() = Action { implicit request: Request[AnyContent] =>
    println("hit index")
    Ok(views.html.index())
  }
}

Mar 28, 2021 3:55:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 184
Mar 28, 2021 3:56:03 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: null
Mar 28, 2021 3:56:04 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: null
Mar 28, 2021 3:56:04 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: null
[0m2021.03.28 15:56:09 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/db/ScalaJdbcConnectSelect.scala[0m
package jdbc

import java.sql.DriverManager
import java.sql.Connection

/** A Scala JDBC connection example by Alvin Alexander,
  * https://alvinalexander.com
  */
object ScalaJdbcConnectSelect extends App {

  def main(args: Array[String]): Unit = {
    println("JDBC Code running...")
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.jdbc.Driver"
    val url = "scaladatabase-1.cmarnl7iz5vu.us-east-1.rds.amazonaws.com"
    val username = "admin"
    val password = "Watayo420$"

    // there's probably a better way to do this
    var connection: Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT host, user FROM user")
      while (resultSet.next()) {
        val host = resultSet.getString("host")
        val user = resultSet.getString("user")
        println("host, user = " + host + ", " + user)
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

[0m2021.03.28 15:56:52 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/db/ScalaJdbcConnectSelect.scala[0m
package jdbc

import java.sql.DriverManager
import java.sql.Connection

/** A Scala JDBC connection example by Alvin Alexander,
  * https://alvinalexander.com
  */
object ScalaJdbcConnectSelect {

  def main(args: Array[String]) {
    println("JDBC Code running...")
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.jdbc.Driver"
    val url = "scaladatabase-1.cmarnl7iz5vu.us-east-1.rds.amazonaws.com"
    val username = "admin"
    val password = "Watayo420$"

    // there's probably a better way to do this
    var connection: Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT host, user FROM user")
      while (resultSet.next()) {
        val host = resultSet.getString("host")
        val user = resultSet.getString("user")
        println("host, user = " + host + ", " + user)
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

[0m2021.03.28 16:15:16 WARN  name := """scalabackend"""
organization := "com.example"

version := "1.0-SNAPSHOT"

lazy val root = (project in file(".")).enablePlugins(PlayScala)

scalaVersion := "2.13.3"

libraryDependencies += guice
libraryDependencies += "org.scalatestplus.play" %% "scalatestplus-play" % "5.0.0" % Test

// Adds additional packages into Twirl
//TwirlKeys.templateImports += "com.example.controllers._"

// Adds additional packages into conf/routes
// play.sbt.routes.RoutesKeys.routesImport += "com.example.binders._"
no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/build.sbt
[0m
[0m2021.03.28 16:16:38 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/build.sbt[0m
name := """scalabackend"""
organization := "com.example"

version := "1.0-SNAPSHOT"

lazy val root = (project in file(".")).enablePlugins(PlayScala)

scalaVersion := "2.13.3"

libraryDependencies += guice
libraryDependencies += "org.scalatestplus.play" %% "scalatestplus-play" % "5.0.0" % Test
libraryDependencies ++= Seq(
  jdbc
)
libraryDependencies ++= Seq(
  "mysql" % "mysql-connector-java" % "5.1.41"
)
// Adds additional packages into Twirl
//TwirlKeys.templateImports += "com.example.controllers._"

// Adds additional packages into conf/routes
// play.sbt.routes.RoutesKeys.routesImport += "com.example.binders._"

[0m2021.03.28 16:16:46 INFO  running '/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home/bin/java -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/metals5315117638613219175/sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'[0m
[0m2021.03.28 16:16:46 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/project/metals.sbt[0m
[0m2021.03.28 16:16:46 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/project/project/metals.sbt[0m
// DO NOT EDIT! This file is auto-generated.
// This file enables sbt-bloop to create bloop config files.

addSbtPlugin("ch.epfl.scala" % "sbt-bloop" % "1.4.8")

// DO NOT EDIT! This file is auto-generated.
// This file enables sbt-bloop to create bloop config files.

addSbtPlugin("ch.epfl.scala" % "sbt-bloop" % "1.4.8")

[0m2021.03.28 16:16:49 INFO  [info] welcome to sbt 1.3.13 (Oracle Corporation Java 1.8.0_201)[0m
[0m2021.03.28 16:16:52 INFO  [info] loading settings for project scalabackend-build-build-build from metals.sbt ...[0m
[0m2021.03.28 16:16:52 INFO  [info] loading project definition from /Users/davidashley/Documents/Scala/scalabackend/scalabackend/project/project/project[0m
[0m2021.03.28 16:16:56 INFO  [warn] There may be incompatibilities among your library dependencies; run 'evicted' to see detailed eviction warnings.[0m
[0m2021.03.28 16:16:58 INFO  [info] loading settings for project scalabackend-build-build from metals.sbt ...[0m
[0m2021.03.28 16:16:58 INFO  [info] loading project definition from /Users/davidashley/Documents/Scala/scalabackend/scalabackend/project/project[0m
[0m2021.03.28 16:16:59 INFO  [warn] There may be incompatibilities among your library dependencies; run 'evicted' to see detailed eviction warnings.[0m
[0m2021.03.28 16:16:59 INFO  [success] Generated .bloop/scalabackend-build-build.json[0m
[0m2021.03.28 16:16:59 INFO  [success] Total time: 1 s, completed Mar 28, 2021 4:16:59 PM[0m
[0m2021.03.28 16:17:01 INFO  [info] loading settings for project scalabackend-build from plugins.sbt,metals.sbt ...[0m
[0m2021.03.28 16:17:01 INFO  [info] loading project definition from /Users/davidashley/Documents/Scala/scalabackend/scalabackend/project[0m
[0m2021.03.28 16:17:02 INFO  [warn] There may be incompatibilities among your library dependencies; run 'evicted' to see detailed eviction warnings.[0m
[0m2021.03.28 16:17:02 INFO  [success] Generated .bloop/scalabackend-build.json[0m
[0m2021.03.28 16:17:02 INFO  [success] Total time: 2 s, completed Mar 28, 2021 4:17:03 PM[0m
[0m2021.03.28 16:17:06 INFO  [info] loading settings for project root from build.sbt ...[0m
[0m2021.03.28 16:17:06 INFO  [info] set current project to scalabackend (in build file:/Users/davidashley/Documents/Scala/scalabackend/scalabackend/)[0m
[0m2021.03.28 16:17:08 INFO  [warn] There may be incompatibilities among your library dependencies; run 'evicted' to see detailed eviction warnings.[0m
[0m2021.03.28 16:17:08 INFO  [warn] There may be incompatibilities among your library dependencies; run 'evicted' to see detailed eviction warnings.[0m
[0m2021.03.28 16:17:08 INFO  [success] Generated .bloop/root.json[0m
[0m2021.03.28 16:17:08 INFO  [success] Generated .bloop/root-test.json[0m
[0m2021.03.28 16:17:08 INFO  [success] Total time: 2 s, completed Mar 28, 2021 4:17:09 PM[0m
[0m2021.03.28 16:17:08 INFO  sbt bloopInstall exit: 0[0m
[0m2021.03.28 16:17:09 INFO  time: ran 'sbt bloopInstall' in 22s[0m
[0m2021.03.28 16:17:09 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher6361090238020046695/bsp.socket'...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
No server running at 127.0.0.1:8212, let's fire one...
Resolving ch.epfl.scala:bloop-frontend_2.12:1.4.8...
Starting bloop server at 127.0.0.1:8212...
Attempting a connection to the server...
Attempting a connection to the server...
Attempting a connection to the server...
Attempting a connection to the server...
Attempting a connection to the server...
Attempting a connection to the server...
[0m[32m[D][0m Loading 2 projects from '/Users/davidashley/Documents/Scala/scalabackend/scalabackend/.bloop'...
[0m[32m[D][0m Loading project from '/Users/davidashley/Documents/Scala/scalabackend/scalabackend/.bloop/root.json'
[0m[32m[D][0m Loading project from '/Users/davidashley/Documents/Scala/scalabackend/scalabackend/.bloop/root-test.json'
[0m[32m[D][0m Cache miss for scala instance org.scala-lang:scala-compiler:2.13.3.
[0m[32m[D][0m   => /Users/davidashley/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/java/dev/jna/jna/5.3.1/jna-5.3.1.jar
[0m[32m[D][0m   => /Users/davidashley/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/jline/jline/3.15.0/jline-3.15.0.jar
[0m[32m[D][0m   => /Users/davidashley/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-compiler/2.13.3/scala-compiler-2.13.3.jar
[0m[32m[D][0m   => /Users/davidashley/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.3/scala-library-2.13.3.jar
[0m[32m[D][0m   => /Users/davidashley/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-reflect/2.13.3/scala-reflect-2.13.3.jar
[0m[32m[D][0m Missing analysis file for project 'root-test'
[0m[32m[D][0m Missing analysis file for project 'root'
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher6361090238020046695/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher6361090238020046695/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.28 16:17:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.03.28 16:17:17 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
[0m2021.03.28 16:17:17 INFO  Attempting to connect to the build server...Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher7279450664704225284/bsp.socket'...
[0m
Waiting for the bsp connection to come up...
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher3461458198362241375/bsp.socket'...
Waiting for the bsp connection to come up...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher7279450664704225284/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher7279450664704225284/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.28 16:17:17 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher3461458198362241375/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher3461458198362241375/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.28 16:17:17 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.03.28 16:17:19 INFO  time: Connected to build server in 10s[0m
[0m2021.03.28 16:17:19 INFO  Connected to Build server: Bloop v1.4.8[0m
[0m2021.03.28 16:17:19 INFO  time: Imported build in 0.13s[0m
[0m2021.03.28 16:17:24 INFO  time: indexed workspace in 4.59s[0m
[0m2021.03.28 16:17:25 INFO  compiling root (7 scala sources and 1 java source)[0m
import _root_.scala.xml.{TopScope=>$scope}
import _root_.sbt._
import _root_.sbt.Keys._
import _root_.sbt.nio.Keys._
import _root_.sbt.ScriptedPlugin.autoImport._, _root_.bloop.integrations.sbt.BloopPlugin.autoImport._, _root_.play.sbt.Play.autoImport._, _root_.play.sbt.PlayService.autoImport._, _root_.play.sbt.routes.RoutesCompiler.autoImport._, _root_.giter8.ScaffoldPlugin.autoImport._, _root_.play.twirl.sbt.SbtTwirl.autoImport._, _root_.com.typesafe.sbt.SbtNativePackager.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.JavaAppPackaging.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.JavaServerAppPackaging.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.jar.ClasspathJarPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.jar.LauncherJarPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.jlink.JlinkPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.scripts.BashStartScriptPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.scripts.BatStartScriptPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemdPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemloaderPlugin.autoImport._, _root_.com.typesafe.sbt.packager.debian.DebianPlugin.autoImport._, _root_.com.typesafe.sbt.packager.docker.DockerPlugin.autoImport._, _root_.com.typesafe.sbt.packager.graalvmnativeimage.GraalVMNativeImagePlugin.autoImport._, _root_.com.typesafe.sbt.packager.jdkpackager.JDKPackagerPlugin.autoImport._, _root_.com.typesafe.sbt.packager.linux.LinuxPlugin.autoImport._, _root_.com.typesafe.sbt.packager.rpm.RpmPlugin.autoImport._, _root_.com.typesafe.sbt.packager.universal.UniversalPlugin.autoImport._, _root_.com.typesafe.sbt.packager.windows.WindowsPlugin.autoImport._, _root_.com.lightbend.sbt.javaagent.JavaAgent.autoImport._, _root_.com.typesafe.sbt.web.SbtWeb.autoImport._, _root_.com.typesafe.sbt.jse.SbtJsEngine.autoImport._, _root_.com.typesafe.sbt.jse.SbtJsTask.autoImport._
import _root_.sbt.plugins.IvyPlugin, _root_.sbt.plugins.JvmPlugin, _root_.sbt.plugins.CorePlugin, _root_.sbt.ScriptedPlugin, _root_.sbt.plugins.SbtPlugin, _root_.sbt.plugins.SemanticdbPlugin, _root_.sbt.plugins.JUnitXmlReportPlugin, _root_.sbt.plugins.Giter8TemplatePlugin, _root_.bloop.integrations.sbt.BloopPlugin, _root_.play.sbt.Play, _root_.play.sbt.PlayAkkaHttp2Support, _root_.play.sbt.PlayAkkaHttpServer, _root_.play.sbt.PlayFilters, _root_.play.sbt.PlayJava, _root_.play.sbt.PlayLayoutPlugin, _root_.play.sbt.PlayLogback, _root_.play.sbt.PlayMinimalJava, _root_.play.sbt.PlayNettyServer, _root_.play.sbt.PlayScala, _root_.play.sbt.PlayService, _root_.play.sbt.PlayWeb, _root_.play.sbt.routes.RoutesCompiler, _root_.play.sbt.test.MediatorWorkaroundPlugin, _root_.giter8.ScaffoldPlugin, _root_.play.twirl.sbt.SbtTwirl, _root_.com.typesafe.sbt.SbtNativePackager, _root_.com.typesafe.sbt.packager.archetypes.JavaAppPackaging, _root_.com.typesafe.sbt.packager.archetypes.JavaServerAppPackaging, _root_.com.typesafe.sbt.packager.archetypes.jar.ClasspathJarPlugin, _root_.com.typesafe.sbt.packager.archetypes.jar.LauncherJarPlugin, _root_.com.typesafe.sbt.packager.archetypes.jlink.JlinkPlugin, _root_.com.typesafe.sbt.packager.archetypes.scripts.AshScriptPlugin, _root_.com.typesafe.sbt.packager.archetypes.scripts.BashStartScriptPlugin, _root_.com.typesafe.sbt.packager.archetypes.scripts.BatStartScriptPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemVPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemdPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemloaderPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.UpstartPlugin, _root_.com.typesafe.sbt.packager.debian.DebianDeployPlugin, _root_.com.typesafe.sbt.packager.debian.DebianPlugin, _root_.com.typesafe.sbt.packager.debian.JDebPackaging, _root_.com.typesafe.sbt.packager.docker.DockerPlugin, _root_.com.typesafe.sbt.packager.docker.DockerSpotifyClientPlugin, _root_.com.typesafe.sbt.packager.graalvmnativeimage.GraalVMNativeImagePlugin, _root_.com.typesafe.sbt.packager.jdkpackager.JDKPackagerDeployPlugin, _root_.com.typesafe.sbt.packager.jdkpackager.JDKPackagerPlugin, _root_.com.typesafe.sbt.packager.linux.LinuxPlugin, _root_.com.typesafe.sbt.packager.rpm.RpmDeployPlugin, _root_.com.typesafe.sbt.packager.rpm.RpmPlugin, _root_.com.typesafe.sbt.packager.universal.UniversalDeployPlugin, _root_.com.typesafe.sbt.packager.universal.UniversalPlugin, _root_.com.typesafe.sbt.packager.windows.WindowsDeployPlugin, _root_.com.typesafe.sbt.packager.windows.WindowsPlugin, _root_.com.lightbend.sbt.javaagent.JavaAgent, _root_.com.lightbend.sbt.javaagent.JavaAgentPackaging, _root_.com.typesafe.sbt.web.SbtWeb, _root_.com.typesafe.sbt.jse.SbtJsEngine, _root_.com.typesafe.sbt.jse.SbtJsTask
name := """scalabackend"""
organization := "com.example"

version := "1.0-SNAPSHOT"

lazy val root = (project in file(".")).enablePlugins(PlayScala)

scalaVersion := "2.13.3"

libraryDependencies += guice
libraryDependencies += "org.scalatestplus.play" %% "scalatestplus-play" % "5.0.0" % Test
libraryDependencies ++= Seq(
  jdbc
)
libraryDependencies ++= Seq(
  "mysql" % "mysql-connector-java" % "5.1.41"
)
// Adds additional packages into Twirl
//TwirlKeys.templateImports += "com.example.controllers._"

// Adds additional packages into conf/routes
// play.sbt.routes.RoutesKeys.routesImport += "com.example.binders._"

[0m2021.03.28 16:17:38 INFO  time: code lens generation in 13s[0m
[0m2021.03.28 16:17:45 INFO  compiling root-test (1 scala source)[0m
[0m2021.03.28 16:17:45 INFO  time: compiled root in 20s[0m
[0m2021.03.28 16:17:46 INFO  time: compiled root-test in 1.77s[0m
[0m2021.03.28 16:18:12 INFO  skipping build import with status 'Installed'[0m
[0m2021.03.28 22:00:33 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:00:33 INFO  time: compiled root in 0.64s[0m
Mar 28, 2021 10:01:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 385
[0m2021.03.28 22:01:05 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:01:05 INFO  time: compiled root in 0.32s[0m
[0m2021.03.28 22:01:08 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:01:08 INFO  time: compiled root in 0.15s[0m
Mar 28, 2021 10:02:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 444
Mar 28, 2021 10:05:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 452
[0m2021.03.28 22:05:56 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:05:56 INFO  time: compiled root in 0.22s[0m
[0m2021.03.28 22:07:01 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:07:01 INFO  time: compiled root in 0.15s[0m
[0m2021.03.28 22:08:15 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:08:15 INFO  time: compiled root in 0.12s[0m
Mar 28, 2021 10:12:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 630
import _root_.scala.xml.{TopScope=>$scope}
import _root_.sbt._
import _root_.sbt.Keys._
import _root_.sbt.nio.Keys._
import _root_.sbt.ScriptedPlugin.autoImport._, _root_.bloop.integrations.sbt.BloopPlugin.autoImport._
import _root_.sbt.plugins.IvyPlugin, _root_.sbt.plugins.JvmPlugin, _root_.sbt.plugins.CorePlugin, _root_.sbt.ScriptedPlugin, _root_.sbt.plugins.SbtPlugin, _root_.sbt.plugins.SemanticdbPlugin, _root_.sbt.plugins.JUnitXmlReportPlugin, _root_.sbt.plugins.Giter8TemplatePlugin, _root_.bloop.integrations.sbt.BloopPlugin
addSbtPlugin("com.typesafe.play" % "sbt-plugin" % "2.8.7")
addSbtPlugin("org.foundweekends.giter8" % "sbt-giter8-scaffold" % "0.11.0")

Mar 28, 2021 10:14:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 642
[0m2021.03.28 22:23:58 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:23:58 INFO  time: compiled root in 0.21s[0m
/*
 * Copyright (C) 2009-2020 Lightbend Inc. <https://www.lightbend.com>
 */

package akka.actor

import java.io.Closeable
import java.util.Optional
import java.util.concurrent._
import java.util.concurrent.atomic.AtomicReference

import scala.annotation.tailrec
import scala.collection.immutable
import scala.compat.java8.FutureConverters
import scala.compat.java8.OptionConverters._
import scala.concurrent.{ ExecutionContext, ExecutionContextExecutor, Future, Promise }
import scala.concurrent.blocking
import scala.concurrent.duration.Duration
import scala.util.{ Failure, Success, Try }
import scala.util.control.{ ControlThrowable, NonFatal }

import com.typesafe.config.{ Config, ConfigFactory }

import akka.ConfigurationException
import akka.actor.dungeon.ChildrenContainer
import akka.actor.setup.{ ActorSystemSetup, Setup }
import akka.annotation.DoNotInherit
import akka.annotation.InternalApi
import akka.dispatch._
import akka.event._
import akka.event.Logging.DefaultLogger
import akka.japi.Util.immutableSeq
import akka.serialization.SerializationExtension
import akka.util._
import akka.util.Helpers.toRootLowerCase

object BootstrapSetup {

  /**
   * Scala API: Construct a bootstrap settings with default values. Note that passing that to the actor system is the
   * same as not passing any [[BootstrapSetup]] at all. You can use the returned instance to derive
   * one that has other values than defaults using the various `with`-methods.
   */
  def apply(): BootstrapSetup = {
    new BootstrapSetup()
  }

  /**
   * Scala API: Create bootstrap settings needed for starting the actor system
   *
   * @see [[BootstrapSetup]] for description of the properties
   */
  def apply(
      classLoader: Option[ClassLoader],
      config: Option[Config],
      defaultExecutionContext: Option[ExecutionContext]): BootstrapSetup =
    new BootstrapSetup(classLoader, config, defaultExecutionContext)

  /**
   * Scala API: Short for using custom config but keeping default classloader and default execution context
   */
  def apply(config: Config): BootstrapSetup = apply(None, Some(config), None)

  /**
   * Java API: Create bootstrap settings needed for starting the actor system
   *
   * @see [[BootstrapSetup]] for description of the properties
   */
  def create(
      classLoader: Optional[ClassLoader],
      config: Optional[Config],
      defaultExecutionContext: Optional[ExecutionContext]): BootstrapSetup =
    apply(classLoader.asScala, config.asScala, defaultExecutionContext.asScala)

  /**
   * Java  API: Short for using custom config but keeping default classloader and default execution context
   */
  def create(config: Config): BootstrapSetup = apply(config)

  /**
   * Java API: Construct a bootstrap settings with default values. Note that passing that to the actor system is the
   * same as not passing any [[BootstrapSetup]] at all. You can use the returned instance to derive
   * one that has other values than defaults using the various `with`-methods.
   */
  def create(): BootstrapSetup = {
    new BootstrapSetup()
  }

}

/**
 * @param identifier the simple name of the selected provider
 * @param fqcn the fully-qualified class name of the selected provider
 */
abstract class ProviderSelection private (
    private[akka] val identifier: String,
    private[akka] val fqcn: String,
    private[akka] val hasCluster: Boolean)
object ProviderSelection {
  private[akka] val RemoteActorRefProvider = "akka.remote.RemoteActorRefProvider"
  private[akka] val ClusterActorRefProvider = "akka.cluster.ClusterActorRefProvider"

  case object Local extends ProviderSelection("local", classOf[LocalActorRefProvider].getName, hasCluster = false)
  // these two cannot be referenced by class as they may not be on the classpath
  case object Remote extends ProviderSelection("remote", RemoteActorRefProvider, hasCluster = false)
  case object Cluster extends ProviderSelection("cluster", ClusterActorRefProvider, hasCluster = true)
  final case class Custom(override val fqcn: String) extends ProviderSelection("custom", fqcn, hasCluster = false)

  /**
   * JAVA API
   */
  def local(): ProviderSelection = Local

  /**
   * JAVA API
   */
  def remote(): ProviderSelection = Remote

  /**
   * JAVA API
   */
  def cluster(): ProviderSelection = Cluster

  /** INTERNAL API */
  @InternalApi private[akka] def apply(providerClass: String): ProviderSelection =
    providerClass match {
      case "local" => Local
      // additional fqcn for older configs not using 'remote' or 'cluster'
      case "remote" | RemoteActorRefProvider   => Remote
      case "cluster" | ClusterActorRefProvider => Cluster
      case fqcn                                => Custom(fqcn)
    }
}

/**
 * Core bootstrap settings of the actor system, create using one of the factories in [[BootstrapSetup]],
 * constructor is *Internal API*.
 *
 * @param classLoader If no ClassLoader is given, it obtains the current ClassLoader by first inspecting the current
 *                    threads' getContextClassLoader, then tries to walk the stack to find the callers class loader, then
 *                    falls back to the ClassLoader associated with the ActorSystem class.
 * @param config Configuration to use for the actor system. If no Config is given, the default reference config will be obtained from the ClassLoader.
 * @param defaultExecutionContext If defined the ExecutionContext will be used as the default executor inside this ActorSystem.
 *                                If no ExecutionContext is given, the system will fallback to the executor configured under
 *                                "akka.actor.default-dispatcher.default-executor.fallback".
 * @param actorRefProvider Overrides the `akka.actor.provider` setting in config, can be `local` (default), `remote` or
 *                         `cluster`. It can also be a fully qualified class name of a provider.
 */
final class BootstrapSetup private (
    val classLoader: Option[ClassLoader] = None,
    val config: Option[Config] = None,
    val defaultExecutionContext: Option[ExecutionContext] = None,
    val actorRefProvider: Option[ProviderSelection] = None)
    extends Setup {

  def withClassloader(classLoader: ClassLoader): BootstrapSetup =
    new BootstrapSetup(Some(classLoader), config, defaultExecutionContext, actorRefProvider)

  def withConfig(config: Config): BootstrapSetup =
    new BootstrapSetup(classLoader, Some(config), defaultExecutionContext, actorRefProvider)

  def withDefaultExecutionContext(executionContext: ExecutionContext): BootstrapSetup =
    new BootstrapSetup(classLoader, config, Some(executionContext), actorRefProvider)

  def withActorRefProvider(name: ProviderSelection): BootstrapSetup =
    new BootstrapSetup(classLoader, config, defaultExecutionContext, Some(name))

}

object ActorSystem {

  val Version: String = akka.Version.current // generated file

  /**
   * Creates a new ActorSystem with the name "default",
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def create(): ActorSystem = apply()

  /**
   * Creates a new ActorSystem with the specified name,
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def create(name: String): ActorSystem = apply(name)

  /**
   * Java API: Creates a new actor system with the specified name and settings
   * The core actor system settings are defined in [[BootstrapSetup]]
   */
  def create(name: String, setups: ActorSystemSetup): ActorSystem = apply(name, setups)

  /**
   * Java API: Shortcut for creating an actor system with custom bootstrap settings.
   * Same behavior as calling `ActorSystem.create(name, ActorSystemSetup.create(bootstrapSettings))`
   */
  def create(name: String, bootstrapSetup: BootstrapSetup): ActorSystem =
    create(name, ActorSystemSetup.create(bootstrapSetup))

  /**
   * Creates a new ActorSystem with the specified name, and the specified Config, then
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def create(name: String, config: Config): ActorSystem = apply(name, config)

  /**
   * Creates a new ActorSystem with the specified name, the specified Config, and specified ClassLoader
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def create(name: String, config: Config, classLoader: ClassLoader): ActorSystem = apply(name, config, classLoader)

  /**
   * Creates a new ActorSystem with the specified name, the specified Config, the specified ClassLoader,
   * and the specified ExecutionContext. The ExecutionContext will be used as the default executor inside this ActorSystem.
   * If `null` is passed in for the Config, ClassLoader and/or ExecutionContext parameters, the respective default value
   * will be used. If no Config is given, the default reference config will be obtained from the ClassLoader.
   * If no ClassLoader is given, it obtains the current ClassLoader by first inspecting the current
   * threads' getContextClassLoader, then tries to walk the stack to find the callers class loader, then
   * falls back to the ClassLoader associated with the ActorSystem class. If no ExecutionContext is given, the
   * system will fallback to the executor configured under "akka.actor.default-dispatcher.default-executor.fallback".
   * Note that the given ExecutionContext will be used by all dispatchers that have been configured with
   * executor = "default-executor", including those that have not defined the executor setting and thereby fallback
   * to the default of "default-dispatcher.executor".
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def create(
      name: String,
      config: Config,
      classLoader: ClassLoader,
      defaultExecutionContext: ExecutionContext): ActorSystem =
    apply(name, Option(config), Option(classLoader), Option(defaultExecutionContext))

  /**
   * Creates a new ActorSystem with the name "default",
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def apply(): ActorSystem = apply("default")

  /**
   * Creates a new ActorSystem with the specified name,
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def apply(name: String): ActorSystem = apply(name, None, None, None)

  /**
   * Scala API: Creates a new actor system with the specified name and settings
   * The core actor system settings are defined in [[BootstrapSetup]]
   */
  def apply(name: String, setup: ActorSystemSetup): ActorSystem = {
    val bootstrapSettings = setup.get[BootstrapSetup]
    val cl = bootstrapSettings.flatMap(_.classLoader).getOrElse(findClassLoader())
    val appConfig = bootstrapSettings.flatMap(_.config).getOrElse(ConfigFactory.load(cl))
    val defaultEC = bootstrapSettings.flatMap(_.defaultExecutionContext)

    new ActorSystemImpl(name, appConfig, cl, defaultEC, None, setup).start()
  }

  /**
   * Scala API: Shortcut for creating an actor system with custom bootstrap settings.
   * Same behavior as calling `ActorSystem(name, ActorSystemSetup(bootstrapSetup))`
   */
  def apply(name: String, bootstrapSetup: BootstrapSetup): ActorSystem =
    create(name, ActorSystemSetup.create(bootstrapSetup))

  /**
   * Creates a new ActorSystem with the specified name, and the specified Config, then
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def apply(name: String, config: Config): ActorSystem = apply(name, Option(config), None, None)

  /**
   * Creates a new ActorSystem with the specified name, the specified Config, and specified ClassLoader
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def apply(name: String, config: Config, classLoader: ClassLoader): ActorSystem =
    apply(name, Option(config), Option(classLoader), None)

  /**
   * Creates a new ActorSystem with the specified name,
   * the specified ClassLoader if given, otherwise obtains the current ClassLoader by first inspecting the current
   * threads' getContextClassLoader, then tries to walk the stack to find the callers class loader, then
   * falls back to the ClassLoader associated with the ActorSystem class.
   * If an ExecutionContext is given, it will be used as the default executor inside this ActorSystem.
   * If no ExecutionContext is given, the system will fallback to the executor configured under "akka.actor.default-dispatcher.default-executor.fallback".
   * The system will use the passed in config, or falls back to the default reference configuration using the ClassLoader.
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def apply(
      name: String,
      config: Option[Config] = None,
      classLoader: Option[ClassLoader] = None,
      defaultExecutionContext: Option[ExecutionContext] = None): ActorSystem =
    apply(name, ActorSystemSetup(BootstrapSetup(classLoader, config, defaultExecutionContext)))

  /**
   * INTERNAL API
   */
  @InternalApi private[akka] object Settings {

    /**
     * INTERNAL API
     *
     * When using Akka Typed the Slf4jLogger should be used by default.
     * Looking for config property `akka.use-slf4j` (defined in akka-actor-typed) and
     * that `Slf4jLogger` (akka-slf4j) is in  classpath.
     * Then adds `Slf4jLogger` to configured loggers and removes `DefaultLogger`.
     */
    @InternalApi private[akka] def amendSlf4jConfig(config: Config, dynamicAccess: DynamicAccess): Config = {
      val slf4jLoggerClassName = "akka.event.slf4j.Slf4jLogger"
      val slf4jLoggingFilterClassName = "akka.event.slf4j.Slf4jLoggingFilter"
      val loggersConfKey = "akka.loggers"
      val loggingFilterConfKey = "akka.logging-filter"
      val configuredLoggers = immutableSeq(config.getStringList(loggersConfKey))
      val configuredLoggingFilter = config.getString(loggingFilterConfKey)

      val loggingFilterAlreadyConfigured =
        configuredLoggingFilter == slf4jLoggingFilterClassName || configuredLoggingFilter != classOf[
            DefaultLoggingFilter].getName

      def newLoggingFilterConfStr = s"""$loggingFilterConfKey = "$slf4jLoggingFilterClassName""""

      if (configuredLoggers.contains(slf4jLoggerClassName)) {
        // already configured explicitly
        if (loggingFilterAlreadyConfigured)
          config
        else
          ConfigFactory.parseString(newLoggingFilterConfStr).withFallback(config)
      } else {
        val confKey = "akka.use-slf4j"
        if (config.hasPath(confKey) && config.getBoolean(confKey) && dynamicAccess.classIsOnClasspath(
              slf4jLoggerClassName)) {
          val newLoggers = slf4jLoggerClassName +: configuredLoggers.filterNot(_ == classOf[DefaultLogger].getName)
          val newLoggersConfStr = s"$loggersConfKey = [${newLoggers.mkString("\"", "\", \"", "\"")}]"
          val newConfStr =
            if (loggingFilterAlreadyConfigured) newLoggersConfStr
            else newLoggersConfStr + "\n" + newLoggingFilterConfStr
          ConfigFactory.parseString(newConfStr).withFallback(config)
        } else
          config
      }
    }
  }

  /**
   * Settings are the overall ActorSystem Settings which also provides a convenient access to the Config object.
   *
   * For more detailed information about the different possible configuration options, look in the Akka Documentation under "Configuration"
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  class Settings(classLoader: ClassLoader, cfg: Config, final val name: String, val setup: ActorSystemSetup) {

    def this(classLoader: ClassLoader, cfg: Config, name: String) = this(classLoader, cfg, name, ActorSystemSetup())

    /**
     * The backing Config of this ActorSystem's Settings
     *
     * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
     */
    final val config: Config = {
      cfg.checkValid(
        ConfigFactory
          .defaultReference(classLoader)
          .withoutPath(Dispatchers.InternalDispatcherId), // allow this to be both string and config object
        "akka")
      cfg
    }

    import config._

    import akka.util.Helpers.ConfigOps

    final val ConfigVersion: String = getString("akka.version")

    private final val providerSelectionSetup = setup
      .get[BootstrapSetup]
      .flatMap(_.actorRefProvider)
      .map(_.identifier)
      .getOrElse(getString("akka.actor.provider"))

    final val ProviderSelectionType: ProviderSelection = ProviderSelection(providerSelectionSetup)

    final val ProviderClass: String = ProviderSelectionType.fqcn

    final val HasCluster: Boolean = ProviderSelectionType.hasCluster

    final val SupervisorStrategyClass: String = getString("akka.actor.guardian-supervisor-strategy")
    final val CreationTimeout: Timeout = Timeout(config.getMillisDuration("akka.actor.creation-timeout"))
    final val UnstartedPushTimeout: Timeout = Timeout(config.getMillisDuration("akka.actor.unstarted-push-timeout"))

    final val AllowJavaSerialization: Boolean = getBoolean("akka.actor.allow-java-serialization")
    @deprecated("Always enabled from Akka 2.6.0", "2.6.0")
    final val EnableAdditionalSerializationBindings: Boolean = true
    final val SerializeAllMessages: Boolean = getBoolean("akka.actor.serialize-messages")
    final val SerializeAllCreators: Boolean = getBoolean("akka.actor.serialize-creators")
    final val NoSerializationVerificationNeededClassPrefix: Set[String] = {
      import akka.util.ccompat.JavaConverters._
      getStringList("akka.actor.no-serialization-verification-needed-class-prefix").asScala.toSet
    }

    final val LogLevel: String = getString("akka.loglevel")
    final val StdoutLogLevel: String = getString("akka.stdout-loglevel")
    final val Loggers: immutable.Seq[String] = immutableSeq(getStringList("akka.loggers"))
    final val LoggersDispatcher: String = getString("akka.loggers-dispatcher")
    final val LoggingFilter: String = getString("akka.logging-filter")
    final val LoggerStartTimeout: Timeout = Timeout(config.getMillisDuration("akka.logger-startup-timeout"))
    final val LogConfigOnStart: Boolean = config.getBoolean("akka.log-config-on-start")
    final val LogDeadLetters: Int = toRootLowerCase(config.getString("akka.log-dead-letters")) match {
      case "off" | "false" => 0
      case "on" | "true"   => Int.MaxValue
      case _               => config.getInt("akka.log-dead-letters")
    }
    final val LogDeadLettersDuringShutdown: Boolean = config.getBoolean("akka.log-dead-letters-during-shutdown")
    final val LogDeadLettersSuspendDuration: Duration = {
      val key = "akka.log-dead-letters-suspend-duration"
      toRootLowerCase(config.getString(key)) match {
        case "infinite" => Duration.Inf
        case _          => config.getMillisDuration(key)
      }
    }

    final val AddLoggingReceive: Boolean = getBoolean("akka.actor.debug.receive")
    final val DebugAutoReceive: Boolean = getBoolean("akka.actor.debug.autoreceive")
    final val DebugLifecycle: Boolean = getBoolean("akka.actor.debug.lifecycle")
    final val FsmDebugEvent: Boolean = getBoolean("akka.actor.debug.fsm")
    final val DebugEventStream: Boolean = getBoolean("akka.actor.debug.event-stream")
    final val DebugUnhandledMessage: Boolean = getBoolean("akka.actor.debug.unhandled")
    final val DebugRouterMisconfiguration: Boolean = getBoolean("akka.actor.debug.router-misconfiguration")

    final val Home: Option[String] = config.getString("akka.home") match {
      case "" => None
      case x  => Some(x)
    }

    final val SchedulerClass: String = getString("akka.scheduler.implementation")
    final val Daemonicity: Boolean = getBoolean("akka.daemonic")
    final val JvmExitOnFatalError: Boolean = getBoolean("akka.jvm-exit-on-fatal-error")
    final val JvmShutdownHooks: Boolean = getBoolean("akka.jvm-shutdown-hooks")
    final val FailMixedVersions: Boolean = getBoolean("akka.fail-mixed-versions")

    final val CoordinatedShutdownTerminateActorSystem: Boolean = getBoolean(
      "akka.coordinated-shutdown.terminate-actor-system")
    final val CoordinatedShutdownRunByActorSystemTerminate: Boolean = getBoolean(
      "akka.coordinated-shutdown.run-by-actor-system-terminate")
    if (CoordinatedShutdownRunByActorSystemTerminate && !CoordinatedShutdownTerminateActorSystem)
      throw new ConfigurationException(
        "akka.coordinated-shutdown.run-by-actor-system-terminate=on and " +
        "akka.coordinated-shutdown.terminate-actor-system=off is not a supported configuration combination.")

    final val DefaultVirtualNodesFactor: Int = getInt("akka.actor.deployment.default.virtual-nodes-factor")

    if (ConfigVersion != Version)
      throw new akka.ConfigurationException(
        "Akka JAR version [" + Version + "] does not match the provided config version [" + ConfigVersion + "]")

    /**
     * Returns the String representation of the Config that this Settings is backed by
     */
    override def toString: String = config.root.render

  }

  private[akka] def findClassLoader(): ClassLoader = Reflect.findClassLoader()
}

/**
 * An actor system is a hierarchical group of actors which share common
 * configuration, e.g. dispatchers, deployments, remote capabilities and
 * addresses. It is also the entry point for creating or looking up actors.
 *
 * There are several possibilities for creating actors (see [[akka.actor.Props]]
 * for details on `props`):
 *
 * {{{
 * // Java or Scala
 * system.actorOf(props, "name")
 * system.actorOf(props)
 *
 * // Scala
 * system.actorOf(Props[MyActor], "name")
 * system.actorOf(Props(classOf[MyActor], arg1, arg2), "name")
 *
 * // Java
 * system.actorOf(Props.create(MyActor.class), "name");
 * system.actorOf(Props.create(MyActor.class, arg1, arg2), "name");
 * }}}
 *
 * Where no name is given explicitly, one will be automatically generated.
 *
 * <b><i>Important Notice:</i></b>
 *
 * This class is not meant to be extended by user code. If you want to
 * actually roll your own Akka, it will probably be better to look into
 * extending [[akka.actor.ExtendedActorSystem]] instead, but beware that you
 * are completely on your own in that case!
 */
abstract class ActorSystem extends ActorRefFactory with ClassicActorSystemProvider {
  import ActorSystem._

  /**
   * The name of this actor system, used to distinguish multiple ones within
   * the same JVM & class loader.
   */
  def name: String

  /**
   * The core settings extracted from the supplied configuration.
   */
  def settings: Settings

  /**
   * Log the configuration.
   */
  def logConfiguration(): Unit

  /**
   * Construct a path below the application guardian to be used with [[ActorSystem#actorSelection]].
   */
  def /(name: String): ActorPath

  /**
   * Java API: Create a new child actor path.
   */
  def child(child: String): ActorPath = /(child)

  /**
   * Construct a path below the application guardian to be used with [[ActorSystem#actorSelection]].
   */
  def /(name: Iterable[String]): ActorPath

  /**
   * Java API: Recursively create a descendant’s path by appending all child names.
   */
  def descendant(names: java.lang.Iterable[String]): ActorPath = /(immutableSeq(names))

  /**
   * Start-up time in milliseconds since the epoch.
   */
  val startTime: Long = System.currentTimeMillis

  /**
   * Up-time of this actor system in seconds.
   */
  def uptime: Long = (System.currentTimeMillis - startTime) / 1000

  /**
   * Main event bus of this actor system, used for example for logging.
   */
  def eventStream: EventStream

  /**
   * Java API: Main event bus of this actor system, used for example for logging.
   */
  def getEventStream: EventStream = eventStream

  /**
   * Convenient logging adapter for logging to the [[ActorSystem#eventStream]].
   */
  def log: LoggingAdapter

  /**
   * Actor reference where messages are re-routed to which were addressed to
   * stopped or non-existing actors. Delivery to this actor is done on a best
   * effort basis and hence not strictly guaranteed.
   */
  def deadLetters: ActorRef

  /**
   * Light-weight scheduler for running asynchronous tasks after some deadline
   * in the future. Not terribly precise but cheap.
   */
  def scheduler: Scheduler

  /**
   * Java API: Light-weight scheduler for running asynchronous tasks after some deadline
   * in the future. Not terribly precise but cheap.
   */
  def getScheduler: Scheduler = scheduler

  /**
   * Helper object for looking up configured dispatchers.
   */
  def dispatchers: Dispatchers

  /**
   * Default dispatcher as configured. This dispatcher is used for all actors
   * in the actor system which do not have a different dispatcher configured
   * explicitly.
   * Importing this member will place the default MessageDispatcher in scope.
   */
  implicit def dispatcher: ExecutionContextExecutor

  /**
   * Java API: Default dispatcher as configured. This dispatcher is used for all actors
   * in the actor system which do not have a different dispatcher configured
   * explicitly.
   * Importing this member will place the default MessageDispatcher in scope.
   */
  def getDispatcher: ExecutionContextExecutor = dispatcher

  /**
   * Helper object for looking up configured mailbox types.
   */
  def mailboxes: Mailboxes

  /**
   * Register a block of code (callback) to run after [[ActorSystem.terminate]] has been issued and
   * all actors in this actor system have been stopped.
   * Multiple code blocks may be registered by calling this method multiple times.
   * The callbacks will be run sequentially in reverse order of registration, i.e.
   * last registration is run first.
   * Note that ActorSystem will not terminate until all the registered callbacks are finished.
   *
   * Throws a RejectedExecutionException if the System has already been terminated or if termination has been initiated.
   *
   * Scala API
   */
  def registerOnTermination[T](code: => T): Unit

  /**
   * Java API: Register a block of code (callback) to run after [[ActorSystem.terminate]] has been issued and
   * all actors in this actor system have been stopped.
   * Multiple code blocks may be registered by calling this method multiple times.
   * The callbacks will be run sequentially in reverse order of registration, i.e.
   * last registration is run first.
   * Note that ActorSystem will not terminate until all the registered callbacks are finished.
   *
   * Throws a RejectedExecutionException if the System has already been terminated or if termination has been initiated.
   */
  def registerOnTermination(code: Runnable): Unit

  /**
   * Terminates this actor system by running [[CoordinatedShutdown]] with reason
   * [[CoordinatedShutdown.ActorSystemTerminateReason]].
   *
   * If `akka.coordinated-shutdown.run-by-actor-system-terminate` is configured to `off`
   * it will not run `CoordinatedShutdown`, but the `ActorSystem` and its actors
   * will still be terminated.
   *
   * This will stop the guardian actor, which in turn
   * will recursively stop all its child actors, and finally the system guardian
   * (below which the logging actors reside) and then execute all registered
   * termination handlers (see [[ActorSystem#registerOnTermination]]).
   * Be careful to not schedule any operations on completion of the returned future
   * using the dispatcher of this actor system as it will have been shut down before the
   * future completes.
   */
  def terminate(): Future[Terminated]

  /**
   * Returns a Future which will be completed after the ActorSystem has been terminated
   * and termination hooks have been executed. If you registered any callback with
   * [[ActorSystem#registerOnTermination]], the returned Future from this method will not complete
   * until all the registered callbacks are finished. Be careful to not schedule any operations,
   * such as `onComplete`, on the dispatchers (`ExecutionContext`) of this actor system as they
   * will have been shut down before this future completes.
   */
  def whenTerminated: Future[Terminated]

  /**
   * Returns a CompletionStage which will be completed after the ActorSystem has been terminated
   * and termination hooks have been executed. If you registered any callback with
   * [[ActorSystem#registerOnTermination]], the returned CompletionStage from this method will not complete
   * until all the registered callbacks are finished. Be careful to not schedule any operations,
   * such as `thenRunAsync`, on the dispatchers (`Executor`) of this actor system as they
   * will have been shut down before this CompletionStage completes.
   */
  def getWhenTerminated: CompletionStage[Terminated]

  /**
   * Registers the provided extension and creates its payload, if this extension isn't already registered
   * This method has putIfAbsent-semantics, this method can potentially block, waiting for the initialization
   * of the payload, if is in the process of registration from another Thread of execution
   */
  def registerExtension[T <: Extension](ext: ExtensionId[T]): T

  /**
   * Returns the payload that is associated with the provided extension
   * throws an IllegalStateException if it is not registered.
   * This method can potentially block, waiting for the initialization
   * of the payload, if is in the process of registration from another Thread of execution
   */
  def extension[T <: Extension](ext: ExtensionId[T]): T

  /**
   * Returns whether the specified extension is already registered, this method can potentially block, waiting for the initialization
   * of the payload, if is in the process of registration from another Thread of execution
   */
  def hasExtension(ext: ExtensionId[_ <: Extension]): Boolean
}

/**
 * More powerful interface to the actor system’s implementation which is presented to extensions (see [[akka.actor.Extension]]).
 *
 * <b><i>Important Notice:</i></b>
 *
 * This class is not meant to be extended by user code. If you want to
 * actually roll your own Akka, beware that you are completely on your own in
 * that case!
 */
@DoNotInherit
abstract class ExtendedActorSystem extends ActorSystem {

  /**
   * The ActorRefProvider is the only entity which creates all actor references within this actor system.
   */
  def provider: ActorRefProvider

  /**
   * The top-level supervisor of all actors created using system.actorOf(...).
   */
  def guardian: InternalActorRef

  /**
   * The top-level supervisor of all system-internal services like logging.
   */
  def systemGuardian: InternalActorRef

  /**
   * Create an actor in the "/system" namespace. This actor will be shut down
   * during system.terminate only after all user actors have terminated.
   *
   * This is only intended to be used by libraries (and Akka itself).
   * Applications should use ordinary `actorOf`.
   */
  def systemActorOf(props: Props, name: String): ActorRef

  /**
   * A ThreadFactory that can be used if the transport needs to create any Threads
   */
  def threadFactory: ThreadFactory

  /**
   * ClassLoader wrapper which is used for reflective accesses internally. This is set
   * to use the context class loader, if one is set, or the class loader which
   * loaded the ActorSystem implementation. The context class loader is also
   * set on all threads created by the ActorSystem, if one was set during
   * creation.
   */
  def dynamicAccess: DynamicAccess

  /**
   * Filter of log events that is used by the LoggingAdapter before
   * publishing log events to the eventStream
   */
  def logFilter: LoggingFilter

  /**
   * For debugging: traverse actor hierarchy and make string representation.
   * Careful, this may OOM on large actor systems, and it is only meant for
   * helping debugging in case something already went terminally wrong.
   */
  private[akka] def printTree: String

  /**
   * INTERNAL API: final step of `terminate()`
   */
  @InternalApi private[akka] def finalTerminate(): Unit

  /**
   * INTERNAL API
   */
  @InternalApi private[akka] def isTerminating(): Boolean

}

/**
 * Internal API
 */
@InternalApi
private[akka] class ActorSystemImpl(
    val name: String,
    applicationConfig: Config,
    classLoader: ClassLoader,
    defaultExecutionContext: Option[ExecutionContext],
    val guardianProps: Option[Props],
    setup: ActorSystemSetup)
    extends ExtendedActorSystem {

  if (!name.matches("""^[a-zA-Z0-9][a-zA-Z0-9-_]*$"""))
    throw new IllegalArgumentException(
      "invalid ActorSystem name [" + name +
      "], must contain only word characters (i.e. [a-zA-Z0-9] plus non-leading '-' or '_')")

  import ActorSystem._

  @volatile private var logDeadLetterListener: Option[ActorRef] = None

  private val _dynamicAccess: DynamicAccess = createDynamicAccess()

  final val settings: Settings = {
    val config = Settings.amendSlf4jConfig(
      applicationConfig.withFallback(ConfigFactory.defaultReference(classLoader)),
      _dynamicAccess)
    new Settings(classLoader, config, name, setup)
  }

  protected def uncaughtExceptionHandler: Thread.UncaughtExceptionHandler =
    new Thread.UncaughtExceptionHandler() {
      def uncaughtException(thread: Thread, cause: Throwable): Unit = {
        cause match {
          case NonFatal(_) | _: InterruptedException | _: NotImplementedError | _: ControlThrowable =>
            log.error(cause, "Uncaught error from thread [{}]", thread.getName)
          case _ =>
            if (cause.isInstanceOf[IncompatibleClassChangeError] && cause.getMessage.startsWith("akka"))
              System.err.println(
                s"""Detected ${cause.getClass.getName} error, which MAY be caused by incompatible Akka versions on the classpath.
                  | Please note that a given Akka version MUST be the same across all modules of Akka that you are using,
                  | e.g. if you use akka-actor [${akka.Version.current} (resolved from current classpath)] all other core
                  | Akka modules MUST be of the same version. External projects like Alpakka, Persistence plugins or Akka
                  | HTTP etc. have their own version numbers - please make sure you're using a compatible set of libraries.
                 """.stripMargin.replaceAll("[\r\n]", ""))

            if (settings.JvmExitOnFatalError)
              try logFatalError("shutting down JVM since 'akka.jvm-exit-on-fatal-error' is enabled for", cause, thread)
              finally System.exit(-1)
            else
              try logFatalError("shutting down", cause, thread)
              finally terminate()
        }
      }

      @inline
      private def logFatalError(message: String, cause: Throwable, thread: Thread): Unit = {
        // First log to stderr as this has the best chance to get through in an 'emergency panic' situation:
        import System.err
        err.print("Uncaught error from thread [")
        err.print(thread.getName)
        err.print("]: ")
        err.print(cause.getMessage)
        err.print(", ")
        err.print(message)
        err.print(" ActorSystem[")
        err.print(name)
        err.println("]")
        System.err.flush()
        cause.printStackTrace(System.err)
        System.err.flush()

        // Also log using the normal infrastructure - hope for the best:
        markerLogging.error(
          LogMarker.Security,
          cause,
          "Uncaught error from thread [{}]: " + cause.getMessage + ", " + message + " ActorSystem[{}]",
          thread.getName,
          name)
      }
    }

  final val threadFactory: MonitorableThreadFactory =
    MonitorableThreadFactory(name, settings.Daemonicity, Option(classLoader), uncaughtExceptionHandler)

  /**
   * This is an extension point: by overriding this method, subclasses can
   * control all reflection activities of an actor system.
   */
  protected def createDynamicAccess(): DynamicAccess = new ReflectiveDynamicAccess(classLoader)

  def dynamicAccess: DynamicAccess = _dynamicAccess

  def logConfiguration(): Unit = log.info(settings.toString)

  protected def systemImpl: ActorSystemImpl = this

  def systemActorOf(props: Props, name: String): ActorRef =
    systemGuardian.underlying.attachChild(props, name, systemService = true)

  def actorOf(props: Props, name: String): ActorRef =
    if (guardianProps.isEmpty) guardian.underlying.attachChild(props, name, systemService = false)
    else
      throw new UnsupportedOperationException(
        s"cannot create top-level actor [$name] from the outside on ActorSystem with custom user guardian")

  def actorOf(props: Props): ActorRef =
    if (guardianProps.isEmpty) guardian.underlying.attachChild(props, systemService = false)
    else
      throw new UnsupportedOperationException(
        "cannot create top-level actor from the outside on ActorSystem with custom user guardian")

  def stop(actor: ActorRef): Unit = {
    val path = actor.path
    val guard = guardian.path
    val sys = systemGuardian.path
    path.parent match {
      case `guard` => guardian ! StopChild(actor)
      case `sys`   => systemGuardian ! StopChild(actor)
      case _       => actor.asInstanceOf[InternalActorRef].stop()
    }
  }

  import settings._

  // this provides basic logging (to stdout) until .start() is called below
  val eventStream = new EventStream(this, DebugEventStream)
  eventStream.startStdoutLogger(settings)

  val logFilter: LoggingFilter = {
    val arguments = Vector(classOf[Settings] -> settings, classOf[EventStream] -> eventStream)
    dynamicAccess.createInstanceFor[LoggingFilter](LoggingFilter, arguments).get
  }

  private[this] val markerLogging =
    new MarkerLoggingAdapter(eventStream, getClass.getName + "(" + name + ")", this.getClass, logFilter)
  val log: LoggingAdapter = markerLogging

  val scheduler: Scheduler = createScheduler()

  val provider: ActorRefProvider = try {
    val arguments = Vector(
      classOf[String] -> name,
      classOf[Settings] -> settings,
      classOf[EventStream] -> eventStream,
      classOf[DynamicAccess] -> dynamicAccess)

    dynamicAccess.createInstanceFor[ActorRefProvider](ProviderClass, arguments).get
  } catch {
    case NonFatal(e) =>
      Try(stopScheduler())
      throw e
  }

  def deadLetters: ActorRef = provider.deadLetters

  val mailboxes: Mailboxes = new Mailboxes(settings, eventStream, dynamicAccess, deadLetters)

  val dispatchers: Dispatchers = new Dispatchers(
    settings,
    DefaultDispatcherPrerequisites(
      threadFactory,
      eventStream,
      scheduler,
      dynamicAccess,
      settings,
      mailboxes,
      defaultExecutionContext),
    log)

  val dispatcher: ExecutionContextExecutor = dispatchers.defaultGlobalDispatcher

  private[this] final val terminationCallbacks = new TerminationCallbacks(provider.terminationFuture)(dispatcher)

  override def whenTerminated: Future[Terminated] = terminationCallbacks.terminationFuture
  override def getWhenTerminated: CompletionStage[Terminated] = FutureConverters.toJava(whenTerminated)
  def lookupRoot: InternalActorRef = provider.rootGuardian
  def guardian: LocalActorRef = provider.guardian
  def systemGuardian: LocalActorRef = provider.systemGuardian

  def /(actorName: String): ActorPath = guardian.path / actorName
  def /(path: Iterable[String]): ActorPath = guardian.path / path

  override def classicSystem: ActorSystem = this

  // Used for ManifestInfo.checkSameVersion
  private def allModules: List[String] =
    List(
      "akka-actor",
      "akka-actor-testkit-typed",
      "akka-actor-typed",
      "akka-cluster",
      "akka-cluster-metrics",
      "akka-cluster-sharding",
      "akka-cluster-sharding-typed",
      "akka-cluster-tools",
      "akka-cluster-typed",
      "akka-coordination",
      "akka-discovery",
      "akka-distributed-data",
      "akka-testkit",
      "akka-multi-node-testkit",
      "akka-osgi",
      "akka-persistence",
      "akka-persistence-query",
      "akka-persistence-shared",
      "akka-persistence-testkit",
      "akka-persistence-typed",
      "akka-pki",
      "akka-protobuf",
      "akka-protobuf-v3",
      "akka-remote",
      "akka-serialization-jackson",
      "akka-slf4j",
      "akka-stream",
      "akka-stream-testkit",
      "akka-stream-typed",
      "akka-stream-testkit")

  @volatile private var _initialized = false

  /**
   *  Asserts that the ActorSystem has been fully initialized. Can be used to guard code blocks that might accidentally
   *  be run during initialization but require a fully initialized ActorSystem before proceeding.
   */
  def assertInitialized(): Unit =
    if (!_initialized)
      throw new IllegalStateException(
        "The calling code expected that the ActorSystem was initialized but it wasn't yet. " +
        "This is probably a bug in the ActorSystem initialization sequence often related to initialization of extensions. " +
        "Please report at https://github.com/akka/akka/issues.")
  private lazy val _start: this.type = try {

    registerOnTermination(stopScheduler())
    // the provider is expected to start default loggers, LocalActorRefProvider does this
    provider.init(this)
    // at this point it should be initialized "enough" for most extensions that we might want to guard against otherwise
    _initialized = true

    if (settings.LogDeadLetters > 0)
      logDeadLetterListener = Some(systemActorOf(Props[DeadLetterListener](), "deadLetterListener"))
    eventStream.startUnsubscriber()
    ManifestInfo(this).checkSameVersion("Akka", allModules, logWarning = true)
    if (!terminating)
      loadExtensions()
    if (LogConfigOnStart) logConfiguration()
    this
  } catch {
    case NonFatal(e) =>
      try terminate()
      catch { case NonFatal(_) => Try(stopScheduler()) }
      throw e
  }

  def start(): this.type = _start
  def registerOnTermination[T](code: => T): Unit = { registerOnTermination(new Runnable { def run = code }) }
  def registerOnTermination(code: Runnable): Unit = { terminationCallbacks.add(code) }

  @volatile private var terminating = false

  override def terminate(): Future[Terminated] = {
    terminating = true
    if (settings.CoordinatedShutdownRunByActorSystemTerminate && !aborting) {
      // Note that the combination CoordinatedShutdownRunByActorSystemTerminate==true &&
      // CoordinatedShutdownTerminateActorSystem==false is disallowed, checked in Settings.
      // It's not a combination that is valuable to support and it would be complicated to
      // protect against concurrency race conditions between calls to ActorSystem.terminate()
      // and CoordinateShutdown.run()

      // it will call finalTerminate() at the end
      CoordinatedShutdown(this).run(CoordinatedShutdown.ActorSystemTerminateReason)
    } else {
      finalTerminate()
    }
    whenTerminated
  }

  override private[akka] def finalTerminate(): Unit = {
    terminating = true
    // these actions are idempotent
    if (!settings.LogDeadLettersDuringShutdown) logDeadLetterListener.foreach(stop)
    guardian.stop()
  }

  override private[akka] def isTerminating(): Boolean = {
    terminating || aborting || CoordinatedShutdown(this).shutdownReason().isDefined
  }

  @volatile var aborting = false

  /**
   * This kind of shutdown attempts to bring the system down and release its
   * resources more forcefully than plain shutdown. For example it will not
   * run CoordinatedShutdown and not wait for remote-deployed child actors to
   * terminate before terminating their parents.
   */
  def abort(): Unit = {
    aborting = true
    terminate()
  }

  //#create-scheduler
  /**
   * Create the scheduler service. This one needs one special behavior: if
   * Closeable, it MUST execute all outstanding tasks upon .close() in order
   * to properly shutdown all dispatchers.
   *
   * Furthermore, this timer service MUST throw IllegalStateException if it
   * cannot schedule a task. Once scheduled, the task MUST be executed. If
   * executed upon close(), the task may execute before its timeout.
   */
  protected def createScheduler(): Scheduler =
    dynamicAccess
      .createInstanceFor[Scheduler](
        settings.SchedulerClass,
        immutable.Seq(
          classOf[Config] -> settings.config,
          classOf[LoggingAdapter] -> log,
          classOf[ThreadFactory] -> threadFactory.withName(threadFactory.name + "-scheduler")))
      .get
  //#create-scheduler

  /*
   * This is called after the last actor has signaled its termination, i.e.
   * after the last dispatcher has had its chance to schedule its shutdown
   * action.
   */
  protected def stopScheduler(): Unit = scheduler match {
    case x: Closeable => x.close()
    case _            =>
  }

  // For each ExtensionId, either:
  // 1) a CountDownLatch (if it's still in the process of being registered),
  // 2) a Throwable (if it failed initializing), or
  // 3) the registered extension.
  private val extensions = new ConcurrentHashMap[ExtensionId[_], AnyRef]

  /**
   * Returns any extension registered to the specified Extension or returns null if not registered
   */
  @tailrec
  private def findExtension[T <: Extension](ext: ExtensionId[T]): T = extensions.get(ext) match {
    case c: CountDownLatch =>
      blocking {
        val awaitMillis = settings.CreationTimeout.duration.toMillis
        if (!c.await(awaitMillis, TimeUnit.MILLISECONDS))
          throw new IllegalStateException(
            s"Initialization of [$ext] took more than [$awaitMillis ms]. " +
            (if (ext == SerializationExtension)
               "A serializer must not access the SerializationExtension from its constructor. Use lazy init."
             else "Could be deadlock due to cyclic initialization of extensions."))
      }
      findExtension(ext) //Registration in process, await completion and retry
    case t: Throwable => throw t //Initialization failed, throw same again
    case other =>
      other.asInstanceOf[T] //could be a T or null, in which case we return the null as T
  }

  @tailrec
  final def registerExtension[T <: Extension](ext: ExtensionId[T]): T = {
    findExtension(ext) match {
      case null => //Doesn't already exist, commence registration
        val inProcessOfRegistration = new CountDownLatch(1)
        extensions.putIfAbsent(ext, inProcessOfRegistration) match { // Signal that registration is in process
          case null =>
            try { // Signal was successfully sent
              ext.createExtension(this) match { // Create and initialize the extension
                case null =>
                  throw new IllegalStateException(s"Extension instance created as 'null' for extension [$ext]")
                case instance =>
                  extensions.replace(ext, inProcessOfRegistration, instance) //Replace our in process signal with the initialized extension
                  instance //Profit!
              }
            } catch {
              case t: Throwable =>
                extensions.replace(ext, inProcessOfRegistration, t) //In case shit hits the fan, remove the inProcess signal
                throw t //Escalate to caller
            } finally {
              inProcessOfRegistration.countDown() //Always notify listeners of the inProcess signal
            }
          case _ =>
            registerExtension(ext) //Someone else is in process of registering an extension for this Extension, retry
        }
      case existing => existing.asInstanceOf[T]
    }
  }

  def extension[T <: Extension](ext: ExtensionId[T]): T = findExtension(ext) match {
    case null => throw new IllegalArgumentException(s"Trying to get non-registered extension [$ext]")
    case some => some.asInstanceOf[T]
  }

  def hasExtension(ext: ExtensionId[_ <: Extension]): Boolean = findExtension(ext) != null

  private def loadExtensions(): Unit = {

    /*
     * @param throwOnLoadFail
     *  Throw exception when an extension fails to load (needed for backwards compatibility.
     *    when the extension cannot be found at all we throw regardless of this setting)
     */
    def loadExtensions(key: String, throwOnLoadFail: Boolean): Unit = {

      immutableSeq(settings.config.getStringList(key)).foreach { fqcn =>
        dynamicAccess.getObjectFor[AnyRef](fqcn).recoverWith {
          case firstProblem =>
            dynamicAccess.createInstanceFor[AnyRef](fqcn, Nil).recoverWith { case _ => Failure(firstProblem) }
        } match {
          case Success(p: ExtensionIdProvider) =>
            registerExtension(p.lookup)
          case Success(p: ExtensionId[_]) =>
            registerExtension(p)
          case Success(_) =>
            if (!throwOnLoadFail) log.error("[{}] is not an 'ExtensionIdProvider' or 'ExtensionId', skipping...", fqcn)
            else throw new RuntimeException(s"[$fqcn] is not an 'ExtensionIdProvider' or 'ExtensionId'")
          case Failure(problem) =>
            if (!throwOnLoadFail) log.error(problem, "While trying to load extension [{}], skipping...", fqcn)
            else throw new RuntimeException(s"While trying to load extension [$fqcn]", problem)
        }
      }
    }

    loadExtensions("akka.library-extensions", throwOnLoadFail = true)
    loadExtensions("akka.extensions", throwOnLoadFail = false)
  }

  override def toString: String = lookupRoot.path.root.address.toString

  override def printTree: String = {
    def printNode(node: ActorRef, indent: String): String = {
      node match {
        case wc: ActorRefWithCell =>
          val cell = wc.underlying
          (if (indent.isEmpty) "-> " else indent.dropRight(1) + "⌊-> ") +
          node.path.name + " " + Logging.simpleName(node) + " " +
          (cell match {
            case real: ActorCell =>
              val realActor = real.actor
              if (realActor ne null) realActor.getClass else "null"
            case _ => Logging.simpleName(cell)
          }) +
          (cell match {
            case real: ActorCell => " status=" + real.mailbox.currentStatus
            case _               => ""
          }) +
          " " + (cell.childrenRefs match {
            case ChildrenContainer.TerminatingChildrenContainer(_, toDie, reason) =>
              "Terminating(" + reason + ")" +
              (toDie.toSeq.sorted.mkString("\n" + indent + "   |    toDie: ", "\n" + indent + "   |           ", ""))
            case x @ (ChildrenContainer.TerminatedChildrenContainer | ChildrenContainer.EmptyChildrenContainer) =>
              x.toString
            case n: ChildrenContainer.NormalChildrenContainer => n.c.size.toString + " children"
            case x                                            => Logging.simpleName(x)
          }) +
          (if (cell.childrenRefs.children.isEmpty) "" else "\n") +
          ({
            val children = cell.childrenRefs.children.toSeq.sorted
            val bulk = children.dropRight(1).map(printNode(_, indent + "   |"))
            bulk ++ (children.lastOption.map(printNode(_, indent + "    ")))
          }.mkString("\n"))
        case _ =>
          indent + node.path.name + " " + Logging.simpleName(node)
      }
    }
    printNode(lookupRoot, "")
  }

  final class TerminationCallbacks[T](upStreamTerminated: Future[T])(implicit ec: ExecutionContext) {
    private[this] final val done = Promise[T]()
    private[this] final val ref = new AtomicReference(done)

    // onComplete never fires twice so safe to avoid null check
    upStreamTerminated.onComplete { t =>
      ref.getAndSet(null).complete(t)
    }

    /**
     * Adds a Runnable that will be executed on ActorSystem termination.
     * Note that callbacks are executed in reverse order of insertion.
     *
     * @param r The callback to be executed on ActorSystem termination
     * Throws RejectedExecutionException if called after ActorSystem has been terminated.
     */
    final def add(r: Runnable): Unit = {
      @tailrec def addRec(r: Runnable, p: Promise[T]): Unit = ref.get match {
        case null                               => throw new RejectedExecutionException("ActorSystem already terminated.")
        case some if ref.compareAndSet(some, p) => some.completeWith(p.future.andThen { case _ => r.run() })
        case _                                  => addRec(r, p)
      }
      addRec(r, Promise[T]())
    }

    /**
     * Returns a Future which will be completed once all registered callbacks have been executed.
     */
    def terminationFuture: Future[T] = done.future
  }
}

Mar 28, 2021 10:24:35 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Mar 28, 2021 10:24:35 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: null
java.lang.NullPointerException
	at scala.reflect.internal.Definitions$DefinitionsClass.isByNameParamType(Definitions.scala:419)
	at scala.reflect.internal.TreeInfo.isStableIdent(TreeInfo.scala:136)
	at scala.reflect.internal.TreeInfo.isStableIdentifier(TreeInfo.scala:109)
	at scala.reflect.internal.TreeInfo.isPath(TreeInfo.scala:98)
	at scala.tools.nsc.interactive.Global.stabilizedType(Global.scala:963)
	at scala.tools.nsc.interactive.Global.typedTreeAt(Global.scala:811)
	at scala.meta.internal.pc.SignatureHelpProvider.signatureHelp(SignatureHelpProvider.scala:23)

Mar 28, 2021 10:24:43 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: null
/*
 * Copyright (C) Lightbend Inc. <https://www.lightbend.com>
 */

package play.api.db

import java.sql.Connection

import javax.sql.DataSource

/**
 * Database API.
 */
trait Database {

  /**
   * The configuration name for this database.
   */
  def name: String

  /**
   * The underlying JDBC data source for this database.
   */
  def dataSource: DataSource

  /**
   * The JDBC connection URL this database, i.e. `jdbc:...`
   * Normally retrieved via a connection.
   */
  def url: String

  /**
   * Get a JDBC connection from the underlying data source.
   * Autocommit is enabled by default.
   *
   * Don't forget to release the connection at some point by calling close().
   *
   * @return a JDBC connection
   */
  def getConnection(): Connection

  /**
   * Get a JDBC connection from the underlying data source.
   *
   * Don't forget to release the connection at some point by calling close().
   *
   * @param autocommit determines whether to autocommit the connection
   * @return a JDBC connection
   */
  def getConnection(autocommit: Boolean): Connection

  /**
   * Execute a block of code, providing a JDBC connection.
   * The connection and all created statements are automatically released.
   *
   * @param block code to execute
   * @return the result of the code block
   */
  def withConnection[A](block: Connection => A): A

  /**
   * Execute a block of code, providing a JDBC connection.
   * The connection and all created statements are automatically released.
   *
   * @param autocommit determines whether to autocommit the connection
   * @param block code to execute
   * @return the result of the code block
   */
  def withConnection[A](autocommit: Boolean)(block: Connection => A): A

  /**
   * Execute a block of code in the scope of a JDBC transaction.
   * The connection and all created statements are automatically released.
   * The transaction is automatically committed, unless an exception occurs.
   *
   * @param block code to execute
   * @return the result of the code block
   */
  def withTransaction[A](block: Connection => A): A

  /**
   * Execute a block of code in the scope of a JDBC transaction.
   * The connection and all created statements are automatically released.
   * The transaction is automatically committed, unless an exception occurs.
   *
   * @param isolationLevel determines transaction isolation level
   * @param block code to execute
   * @return the result of the code block
   */
  def withTransaction[A](isolationLevel: TransactionIsolationLevel)(block: Connection => A): A

  /**
   * Shutdown this database, closing the underlying data source.
   */
  def shutdown(): Unit
}

Mar 28, 2021 10:31:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1346
[0m2021.03.28 22:31:16 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:31:16 INFO  time: compiled root in 0.19s[0m
[0m2021.03.28 22:31:45 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:31:45 INFO  time: compiled root in 0.13s[0m
[0m2021.03.28 22:32:14 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:32:14 INFO  time: compiled root in 0.15s[0m
[0m2021.03.28 22:32:19 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:32:19 INFO  time: compiled root in 0.13s[0m
[0m2021.03.28 22:32:22 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:32:22 INFO  time: compiled root in 0.3s[0m
[0m2021.03.28 22:32:32 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:32:33 INFO  time: compiled root in 1.09s[0m
[0m2021.03.28 22:38:37 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:38:37 INFO  time: compiled root in 93ms[0m
[0m2021.03.28 22:39:52 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:39:53 INFO  time: compiled root in 1.45s[0m
Mar 28, 2021 10:41:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1597
Mar 28, 2021 10:41:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1603
Mar 28, 2021 10:41:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1609
Mar 28, 2021 10:44:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1626
[0m2021.03.28 22:47:19 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:47:19 INFO  time: compiled root in 0.39s[0m
[0m2021.03.28 22:47:31 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:47:31 INFO  time: compiled root in 0.7s[0m
Mar 28, 2021 10:55:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1654
[0m2021.03.28 22:56:47 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:56:47 INFO  time: compiled root in 0.12s[0m
/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package scala.concurrent


import java.util.concurrent.{ ExecutorService, Executor }
import scala.annotation.implicitNotFound

/**
 * An `ExecutionContext` can execute program logic asynchronously,
 * typically but not necessarily on a thread pool.
 *
 * A general purpose `ExecutionContext` must be asynchronous in executing
 * any `Runnable` that is passed into its `execute`-method. A special purpose
 * `ExecutionContext` may be synchronous but must only be passed to code that
 * is explicitly safe to be run using a synchronously executing `ExecutionContext`.
 *
 * APIs such as `Future.onComplete` require you to provide a callback
 * and an implicit `ExecutionContext`. The implicit `ExecutionContext`
 * will be used to execute the callback.
 *
 * While it is possible to simply import
 * `scala.concurrent.ExecutionContext.Implicits.global` to obtain an
 * implicit `ExecutionContext`, application developers should carefully
 * consider where they want to set execution policy;
 * ideally, one place per application—or per logically related section of code—
 * will make a decision about which `ExecutionContext` to use.
 * That is, you will mostly want to avoid hardcoding, especially via an import,
 * `scala.concurrent.ExecutionContext.Implicits.global`.
 * The recommended approach is to add `(implicit ec: ExecutionContext)` to methods,
 * or class constructor parameters, which need an `ExecutionContext`.
 * 
 * Then locally import a specific `ExecutionContext` in one place for the entire
 * application or module, passing it implicitly to individual methods.
 * Alternatively define a local implicit val with the required `ExecutionContext`.
 *
 * A custom `ExecutionContext` may be appropriate to execute code
 * which blocks on IO or performs long-running computations.
 * `ExecutionContext.fromExecutorService` and `ExecutionContext.fromExecutor`
 * are good ways to create a custom `ExecutionContext`.
 *
 * The intent of `ExecutionContext` is to lexically scope code execution.
 * That is, each method, class, file, package, or application determines
 * how to run its own code. This avoids issues such as running
 * application callbacks on a thread pool belonging to a networking library.
 * The size of a networking library's thread pool can be safely configured,
 * knowing that only that library's network operations will be affected.
 * Application callback execution can be configured separately.
 */
@implicitNotFound("""Cannot find an implicit ExecutionContext. You might pass
an (implicit ec: ExecutionContext) parameter to your method.

The ExecutionContext is used to configure how and on which
thread pools Futures will run, so the specific ExecutionContext
that is selected is important.

If your application does not define an ExecutionContext elsewhere,
consider using Scala's global ExecutionContext by defining
the following:

implicit val ec: scala.concurrent.ExecutionContext = scala.concurrent.ExecutionContext.global""")
trait ExecutionContext {

  /** Runs a block of code on this execution context.
   *
   *  @param runnable  the task to execute
   */
  def execute(runnable: Runnable): Unit

  /** Reports that an asynchronous computation failed.
   *
   *  @param cause  the cause of the failure
   */
  def reportFailure(@deprecatedName('t) cause: Throwable): Unit

  /** Prepares for the execution of a task. Returns the prepared
     *  execution context. The recommended implementation of
     *  `prepare` is to return `this`.
     *
     *  This method should no longer be overridden or called. It was
     *  originally expected that `prepare` would be called by
     *  all libraries that consume ExecutionContexts, in order to
     *  capture thread local context. However, this usage has proven
     *  difficult to implement in practice and instead it is
     *  now better to avoid using `prepare` entirely.
     *
     *  Instead, if an `ExecutionContext` needs to capture thread
     *  local context, it should capture that context when it is
     *  constructed, so that it doesn't need any additional
     *  preparation later.
     */
  @deprecated("preparation of ExecutionContexts will be removed", "2.12.0")
  def prepare(): ExecutionContext = this
}

/**
 * An [[ExecutionContext]] that is also a
 * Java [[http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html Executor]].
 */
trait ExecutionContextExecutor extends ExecutionContext with Executor

/**
 * An [[ExecutionContext]] that is also a
 * Java [[http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html ExecutorService]].
 */
trait ExecutionContextExecutorService extends ExecutionContextExecutor with ExecutorService


/** Contains factory methods for creating execution contexts.
 */
object ExecutionContext {
  /**
   * The explicit global `ExecutionContext`. Invoke `global` when you want to provide the global
   * `ExecutionContext` explicitly.
   *
   * The default `ExecutionContext` implementation is backed by a work-stealing thread pool.
   * It can be configured via the following [[scala.sys.SystemProperties]]:
   *
   * `scala.concurrent.context.minThreads` = defaults to "1"
   * `scala.concurrent.context.numThreads` = defaults to "x1" (i.e. the current number of available processors * 1)
   * `scala.concurrent.context.maxThreads` = defaults to "x1" (i.e. the current number of available processors * 1)
   * `scala.concurrent.context.maxExtraThreads` = defaults to "256"
   *
   * The pool size of threads is then `numThreads` bounded by `minThreads` on the lower end and `maxThreads` on the high end.
   *
   * The `maxExtraThreads` is the maximum number of extra threads to have at any given time to evade deadlock,
   * see [[scala.concurrent.BlockContext]].
   *
   * @return the global `ExecutionContext`
   */
  def global: ExecutionContextExecutor = Implicits.global.asInstanceOf[ExecutionContextExecutor]

  object Implicits {
    /**
     * The implicit global `ExecutionContext`. Import `global` when you want to provide the global
     * `ExecutionContext` implicitly.
     *
     * The default `ExecutionContext` implementation is backed by a work-stealing thread pool. By default,
     * the thread pool uses a target number of worker threads equal to the number of
     * [[https://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#availableProcessors-- available processors]].
     */
    implicit lazy val global: ExecutionContext = impl.ExecutionContextImpl.fromExecutor(null: Executor)
  }

  /** Creates an `ExecutionContext` from the given `ExecutorService`.
   *
   *  @param e         the `ExecutorService` to use. If `null`, a new `ExecutorService` is created with [[scala.concurrent.ExecutionContext$.global default configuration]].
   *  @param reporter  a function for error reporting
   *  @return          the `ExecutionContext` using the given `ExecutorService`
   */
  def fromExecutorService(e: ExecutorService, reporter: Throwable => Unit): ExecutionContextExecutorService =
    impl.ExecutionContextImpl.fromExecutorService(e, reporter)

  /** Creates an `ExecutionContext` from the given `ExecutorService` with the [[scala.concurrent.ExecutionContext$.defaultReporter default reporter]].
   *
   *  If it is guaranteed that none of the executed tasks are blocking, a single-threaded `ExecutorService`
   *  can be used to create an `ExecutionContext` as follows:
   *
   *  {{{
   *  import java.util.concurrent.Executors
   *  val ec = ExecutionContext.fromExecutorService(Executors.newSingleThreadExecutor())
   *  }}}
   *
   *  @param e the `ExecutorService` to use. If `null`, a new `ExecutorService` is created with [[scala.concurrent.ExecutionContext$.global default configuration]].
   *  @return  the `ExecutionContext` using the given `ExecutorService`
   */
  def fromExecutorService(e: ExecutorService): ExecutionContextExecutorService = fromExecutorService(e, defaultReporter)

  /** Creates an `ExecutionContext` from the given `Executor`.
   *
   *  @param e         the `Executor` to use. If `null`, a new `Executor` is created with [[scala.concurrent.ExecutionContext$.global default configuration]].
   *  @param reporter  a function for error reporting
   *  @return          the `ExecutionContext` using the given `Executor`
   */
  def fromExecutor(e: Executor, reporter: Throwable => Unit): ExecutionContextExecutor =
    impl.ExecutionContextImpl.fromExecutor(e, reporter)

  /** Creates an `ExecutionContext` from the given `Executor` with the [[scala.concurrent.ExecutionContext$.defaultReporter default reporter]].
   *
   *  @param e the `Executor` to use. If `null`, a new `Executor` is created with [[scala.concurrent.ExecutionContext$.global default configuration]].
   *  @return  the `ExecutionContext` using the given `Executor`
   */
  def fromExecutor(e: Executor): ExecutionContextExecutor = fromExecutor(e, defaultReporter)

  /** The default reporter simply prints the stack trace of the `Throwable` to [[http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#err System.err]].
   *
   *  @return the function for error reporting
   */
  def defaultReporter: Throwable => Unit = _.printStackTrace()
}



[0m2021.03.28 22:56:57 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:56:57 INFO  time: compiled root in 0.76s[0m
Mar 28, 2021 10:58:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1740
Mar 28, 2021 10:58:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1840
Mar 28, 2021 10:58:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1845
[0m2021.03.28 22:58:59 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:59:00 INFO  time: compiled root in 1.01s[0m
[0m2021.03.28 22:59:12 INFO  compiling root (1 scala source)[0m
[0m2021.03.28 22:59:12 INFO  time: compiled root in 0.85s[0m
Mar 28, 2021 10:59:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1913
[0m2021.03.28 23:26:05 INFO  shutting down Metals[0m
[0m2021.03.28 23:26:05 INFO  Shut down connection with build server.[0m
[0m2021.03.28 23:26:05 INFO  Shut down connection with build server.[0m
[0m2021.03.28 23:26:05 INFO  Shut down connection with build server.[0m
No more data in the client stdin, exiting...
No more data in the client stdin, exiting...
No more data in the client stdin, exiting...
No more data in the server stdin, exiting...
No more data in the server stdin, exiting...
No more data in the server stdin, exiting...
No more data in the server stdin, exiting...
No more data in the server stdin, exiting...
No more data in the server stdin, exiting...
[0m2021.03.29 19:43:14 INFO  Started: Metals version 0.10.0 in workspace '/Users/davidashley/Documents/Scala/scalabackend/scalabackend' for client vscode 1.54.3.[0m
[0m2021.03.29 19:43:14 INFO  time: initialize in 0.41s[0m
[0m2021.03.29 19:43:14 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher8937033567860956949/bsp.socket'...
Waiting for the bsp connection to come up...
[0m2021.03.29 19:43:14 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/HomeController.scala[0m
[0m2021.03.29 19:43:15 INFO  skipping build import with status 'Installed'[0m
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher8937033567860956949/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher8937033567860956949/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.29 19:43:16 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.03.29 19:43:16 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher8822012358059941766/bsp.socket'...[0m
2021.03.29 19:43:16 INFO  Attempting to connect to the build server...[0m
Waiting for the bsp connection to come up...
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher1067390763733347557/bsp.socket'...
Waiting for the bsp connection to come up...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher1067390763733347557/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher1067390763733347557/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.29 19:43:15 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher8822012358059941766/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher8822012358059941766/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.29 19:43:16 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.03.29 19:43:15 INFO  time: Connected to build server in 1.28s[0m
[0m2021.03.29 19:43:15 INFO  Connected to Build server: Bloop v1.4.8[0m
[0m2021.03.29 19:43:18 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m
[0m2021.03.29 19:43:18 INFO  time: Imported build in 0.29s[0m
/*
 * Copyright (C) 2009-2020 Lightbend Inc. <https://www.lightbend.com>
 */

package akka.actor

import java.io.Closeable
import java.util.Optional
import java.util.concurrent._
import java.util.concurrent.atomic.AtomicReference

import scala.annotation.tailrec
import scala.collection.immutable
import scala.compat.java8.FutureConverters
import scala.compat.java8.OptionConverters._
import scala.concurrent.{ ExecutionContext, ExecutionContextExecutor, Future, Promise }
import scala.concurrent.blocking
import scala.concurrent.duration.Duration
import scala.util.{ Failure, Success, Try }
import scala.util.control.{ ControlThrowable, NonFatal }

import com.typesafe.config.{ Config, ConfigFactory }

import akka.ConfigurationException
import akka.actor.dungeon.ChildrenContainer
import akka.actor.setup.{ ActorSystemSetup, Setup }
import akka.annotation.DoNotInherit
import akka.annotation.InternalApi
import akka.dispatch._
import akka.event._
import akka.event.Logging.DefaultLogger
import akka.japi.Util.immutableSeq
import akka.serialization.SerializationExtension
import akka.util._
import akka.util.Helpers.toRootLowerCase

object BootstrapSetup {

  /**
   * Scala API: Construct a bootstrap settings with default values. Note that passing that to the actor system is the
   * same as not passing any [[BootstrapSetup]] at all. You can use the returned instance to derive
   * one that has other values than defaults using the various `with`-methods.
   */
  def apply(): BootstrapSetup = {
    new BootstrapSetup()
  }

  /**
   * Scala API: Create bootstrap settings needed for starting the actor system
   *
   * @see [[BootstrapSetup]] for description of the properties
   */
  def apply(
      classLoader: Option[ClassLoader],
      config: Option[Config],
      defaultExecutionContext: Option[ExecutionContext]): BootstrapSetup =
    new BootstrapSetup(classLoader, config, defaultExecutionContext)

  /**
   * Scala API: Short for using custom config but keeping default classloader and default execution context
   */
  def apply(config: Config): BootstrapSetup = apply(None, Some(config), None)

  /**
   * Java API: Create bootstrap settings needed for starting the actor system
   *
   * @see [[BootstrapSetup]] for description of the properties
   */
  def create(
      classLoader: Optional[ClassLoader],
      config: Optional[Config],
      defaultExecutionContext: Optional[ExecutionContext]): BootstrapSetup =
    apply(classLoader.asScala, config.asScala, defaultExecutionContext.asScala)

  /**
   * Java  API: Short for using custom config but keeping default classloader and default execution context
   */
  def create(config: Config): BootstrapSetup = apply(config)

  /**
   * Java API: Construct a bootstrap settings with default values. Note that passing that to the actor system is the
   * same as not passing any [[BootstrapSetup]] at all. You can use the returned instance to derive
   * one that has other values than defaults using the various `with`-methods.
   */
  def create(): BootstrapSetup = {
    new BootstrapSetup()
  }

}

/**
 * @param identifier the simple name of the selected provider
 * @param fqcn the fully-qualified class name of the selected provider
 */
abstract class ProviderSelection private (
    private[akka] val identifier: String,
    private[akka] val fqcn: String,
    private[akka] val hasCluster: Boolean)
object ProviderSelection {
  private[akka] val RemoteActorRefProvider = "akka.remote.RemoteActorRefProvider"
  private[akka] val ClusterActorRefProvider = "akka.cluster.ClusterActorRefProvider"

  case object Local extends ProviderSelection("local", classOf[LocalActorRefProvider].getName, hasCluster = false)
  // these two cannot be referenced by class as they may not be on the classpath
  case object Remote extends ProviderSelection("remote", RemoteActorRefProvider, hasCluster = false)
  case object Cluster extends ProviderSelection("cluster", ClusterActorRefProvider, hasCluster = true)
  final case class Custom(override val fqcn: String) extends ProviderSelection("custom", fqcn, hasCluster = false)

  /**
   * JAVA API
   */
  def local(): ProviderSelection = Local

  /**
   * JAVA API
   */
  def remote(): ProviderSelection = Remote

  /**
   * JAVA API
   */
  def cluster(): ProviderSelection = Cluster

  /** INTERNAL API */
  @InternalApi private[akka] def apply(providerClass: String): ProviderSelection =
    providerClass match {
      case "local" => Local
      // additional fqcn for older configs not using 'remote' or 'cluster'
      case "remote" | RemoteActorRefProvider   => Remote
      case "cluster" | ClusterActorRefProvider => Cluster
      case fqcn                                => Custom(fqcn)
    }
}

/**
 * Core bootstrap settings of the actor system, create using one of the factories in [[BootstrapSetup]],
 * constructor is *Internal API*.
 *
 * @param classLoader If no ClassLoader is given, it obtains the current ClassLoader by first inspecting the current
 *                    threads' getContextClassLoader, then tries to walk the stack to find the callers class loader, then
 *                    falls back to the ClassLoader associated with the ActorSystem class.
 * @param config Configuration to use for the actor system. If no Config is given, the default reference config will be obtained from the ClassLoader.
 * @param defaultExecutionContext If defined the ExecutionContext will be used as the default executor inside this ActorSystem.
 *                                If no ExecutionContext is given, the system will fallback to the executor configured under
 *                                "akka.actor.default-dispatcher.default-executor.fallback".
 * @param actorRefProvider Overrides the `akka.actor.provider` setting in config, can be `local` (default), `remote` or
 *                         `cluster`. It can also be a fully qualified class name of a provider.
 */
final class BootstrapSetup private (
    val classLoader: Option[ClassLoader] = None,
    val config: Option[Config] = None,
    val defaultExecutionContext: Option[ExecutionContext] = None,
    val actorRefProvider: Option[ProviderSelection] = None)
    extends Setup {

  def withClassloader(classLoader: ClassLoader): BootstrapSetup =
    new BootstrapSetup(Some(classLoader), config, defaultExecutionContext, actorRefProvider)

  def withConfig(config: Config): BootstrapSetup =
    new BootstrapSetup(classLoader, Some(config), defaultExecutionContext, actorRefProvider)

  def withDefaultExecutionContext(executionContext: ExecutionContext): BootstrapSetup =
    new BootstrapSetup(classLoader, config, Some(executionContext), actorRefProvider)

  def withActorRefProvider(name: ProviderSelection): BootstrapSetup =
    new BootstrapSetup(classLoader, config, defaultExecutionContext, Some(name))

}

object ActorSystem {

  val Version: String = akka.Version.current // generated file

  /**
   * Creates a new ActorSystem with the name "default",
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def create(): ActorSystem = apply()

  /**
   * Creates a new ActorSystem with the specified name,
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def create(name: String): ActorSystem = apply(name)

  /**
   * Java API: Creates a new actor system with the specified name and settings
   * The core actor system settings are defined in [[BootstrapSetup]]
   */
  def create(name: String, setups: ActorSystemSetup): ActorSystem = apply(name, setups)

  /**
   * Java API: Shortcut for creating an actor system with custom bootstrap settings.
   * Same behavior as calling `ActorSystem.create(name, ActorSystemSetup.create(bootstrapSettings))`
   */
  def create(name: String, bootstrapSetup: BootstrapSetup): ActorSystem =
    create(name, ActorSystemSetup.create(bootstrapSetup))

  /**
   * Creates a new ActorSystem with the specified name, and the specified Config, then
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def create(name: String, config: Config): ActorSystem = apply(name, config)

  /**
   * Creates a new ActorSystem with the specified name, the specified Config, and specified ClassLoader
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def create(name: String, config: Config, classLoader: ClassLoader): ActorSystem = apply(name, config, classLoader)

  /**
   * Creates a new ActorSystem with the specified name, the specified Config, the specified ClassLoader,
   * and the specified ExecutionContext. The ExecutionContext will be used as the default executor inside this ActorSystem.
   * If `null` is passed in for the Config, ClassLoader and/or ExecutionContext parameters, the respective default value
   * will be used. If no Config is given, the default reference config will be obtained from the ClassLoader.
   * If no ClassLoader is given, it obtains the current ClassLoader by first inspecting the current
   * threads' getContextClassLoader, then tries to walk the stack to find the callers class loader, then
   * falls back to the ClassLoader associated with the ActorSystem class. If no ExecutionContext is given, the
   * system will fallback to the executor configured under "akka.actor.default-dispatcher.default-executor.fallback".
   * Note that the given ExecutionContext will be used by all dispatchers that have been configured with
   * executor = "default-executor", including those that have not defined the executor setting and thereby fallback
   * to the default of "default-dispatcher.executor".
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def create(
      name: String,
      config: Config,
      classLoader: ClassLoader,
      defaultExecutionContext: ExecutionContext): ActorSystem =
    apply(name, Option(config), Option(classLoader), Option(defaultExecutionContext))

  /**
   * Creates a new ActorSystem with the name "default",
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def apply(): ActorSystem = apply("default")

  /**
   * Creates a new ActorSystem with the specified name,
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def apply(name: String): ActorSystem = apply(name, None, None, None)

  /**
   * Scala API: Creates a new actor system with the specified name and settings
   * The core actor system settings are defined in [[BootstrapSetup]]
   */
  def apply(name: String, setup: ActorSystemSetup): ActorSystem = {
    val bootstrapSettings = setup.get[BootstrapSetup]
    val cl = bootstrapSettings.flatMap(_.classLoader).getOrElse(findClassLoader())
    val appConfig = bootstrapSettings.flatMap(_.config).getOrElse(ConfigFactory.load(cl))
    val defaultEC = bootstrapSettings.flatMap(_.defaultExecutionContext)

    new ActorSystemImpl(name, appConfig, cl, defaultEC, None, setup).start()
  }

  /**
   * Scala API: Shortcut for creating an actor system with custom bootstrap settings.
   * Same behavior as calling `ActorSystem(name, ActorSystemSetup(bootstrapSetup))`
   */
  def apply(name: String, bootstrapSetup: BootstrapSetup): ActorSystem =
    create(name, ActorSystemSetup.create(bootstrapSetup))

  /**
   * Creates a new ActorSystem with the specified name, and the specified Config, then
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def apply(name: String, config: Config): ActorSystem = apply(name, Option(config), None, None)

  /**
   * Creates a new ActorSystem with the specified name, the specified Config, and specified ClassLoader
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def apply(name: String, config: Config, classLoader: ClassLoader): ActorSystem =
    apply(name, Option(config), Option(classLoader), None)

  /**
   * Creates a new ActorSystem with the specified name,
   * the specified ClassLoader if given, otherwise obtains the current ClassLoader by first inspecting the current
   * threads' getContextClassLoader, then tries to walk the stack to find the callers class loader, then
   * falls back to the ClassLoader associated with the ActorSystem class.
   * If an ExecutionContext is given, it will be used as the default executor inside this ActorSystem.
   * If no ExecutionContext is given, the system will fallback to the executor configured under "akka.actor.default-dispatcher.default-executor.fallback".
   * The system will use the passed in config, or falls back to the default reference configuration using the ClassLoader.
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def apply(
      name: String,
      config: Option[Config] = None,
      classLoader: Option[ClassLoader] = None,
      defaultExecutionContext: Option[ExecutionContext] = None): ActorSystem =
    apply(name, ActorSystemSetup(BootstrapSetup(classLoader, config, defaultExecutionContext)))

  /**
   * INTERNAL API
   */
  @InternalApi private[akka] object Settings {

    /**
     * INTERNAL API
     *
     * When using Akka Typed the Slf4jLogger should be used by default.
     * Looking for config property `akka.use-slf4j` (defined in akka-actor-typed) and
     * that `Slf4jLogger` (akka-slf4j) is in  classpath.
     * Then adds `Slf4jLogger` to configured loggers and removes `DefaultLogger`.
     */
    @InternalApi private[akka] def amendSlf4jConfig(config: Config, dynamicAccess: DynamicAccess): Config = {
      val slf4jLoggerClassName = "akka.event.slf4j.Slf4jLogger"
      val slf4jLoggingFilterClassName = "akka.event.slf4j.Slf4jLoggingFilter"
      val loggersConfKey = "akka.loggers"
      val loggingFilterConfKey = "akka.logging-filter"
      val configuredLoggers = immutableSeq(config.getStringList(loggersConfKey))
      val configuredLoggingFilter = config.getString(loggingFilterConfKey)

      val loggingFilterAlreadyConfigured =
        configuredLoggingFilter == slf4jLoggingFilterClassName || configuredLoggingFilter != classOf[
            DefaultLoggingFilter].getName

      def newLoggingFilterConfStr = s"""$loggingFilterConfKey = "$slf4jLoggingFilterClassName""""

      if (configuredLoggers.contains(slf4jLoggerClassName)) {
        // already configured explicitly
        if (loggingFilterAlreadyConfigured)
          config
        else
          ConfigFactory.parseString(newLoggingFilterConfStr).withFallback(config)
      } else {
        val confKey = "akka.use-slf4j"
        if (config.hasPath(confKey) && config.getBoolean(confKey) && dynamicAccess.classIsOnClasspath(
              slf4jLoggerClassName)) {
          val newLoggers = slf4jLoggerClassName +: configuredLoggers.filterNot(_ == classOf[DefaultLogger].getName)
          val newLoggersConfStr = s"$loggersConfKey = [${newLoggers.mkString("\"", "\", \"", "\"")}]"
          val newConfStr =
            if (loggingFilterAlreadyConfigured) newLoggersConfStr
            else newLoggersConfStr + "\n" + newLoggingFilterConfStr
          ConfigFactory.parseString(newConfStr).withFallback(config)
        } else
          config
      }
    }
  }

  /**
   * Settings are the overall ActorSystem Settings which also provides a convenient access to the Config object.
   *
   * For more detailed information about the different possible configuration options, look in the Akka Documentation under "Configuration"
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  class Settings(classLoader: ClassLoader, cfg: Config, final val name: String, val setup: ActorSystemSetup) {

    def this(classLoader: ClassLoader, cfg: Config, name: String) = this(classLoader, cfg, name, ActorSystemSetup())

    /**
     * The backing Config of this ActorSystem's Settings
     *
     * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
     */
    final val config: Config = {
      cfg.checkValid(
        ConfigFactory
          .defaultReference(classLoader)
          .withoutPath(Dispatchers.InternalDispatcherId), // allow this to be both string and config object
        "akka")
      cfg
    }

    import config._

    import akka.util.Helpers.ConfigOps

    final val ConfigVersion: String = getString("akka.version")

    private final val providerSelectionSetup = setup
      .get[BootstrapSetup]
      .flatMap(_.actorRefProvider)
      .map(_.identifier)
      .getOrElse(getString("akka.actor.provider"))

    final val ProviderSelectionType: ProviderSelection = ProviderSelection(providerSelectionSetup)

    final val ProviderClass: String = ProviderSelectionType.fqcn

    final val HasCluster: Boolean = ProviderSelectionType.hasCluster

    final val SupervisorStrategyClass: String = getString("akka.actor.guardian-supervisor-strategy")
    final val CreationTimeout: Timeout = Timeout(config.getMillisDuration("akka.actor.creation-timeout"))
    final val UnstartedPushTimeout: Timeout = Timeout(config.getMillisDuration("akka.actor.unstarted-push-timeout"))

    final val AllowJavaSerialization: Boolean = getBoolean("akka.actor.allow-java-serialization")
    @deprecated("Always enabled from Akka 2.6.0", "2.6.0")
    final val EnableAdditionalSerializationBindings: Boolean = true
    final val SerializeAllMessages: Boolean = getBoolean("akka.actor.serialize-messages")
    final val SerializeAllCreators: Boolean = getBoolean("akka.actor.serialize-creators")
    final val NoSerializationVerificationNeededClassPrefix: Set[String] = {
      import akka.util.ccompat.JavaConverters._
      getStringList("akka.actor.no-serialization-verification-needed-class-prefix").asScala.toSet
    }

    final val LogLevel: String = getString("akka.loglevel")
    final val StdoutLogLevel: String = getString("akka.stdout-loglevel")
    final val Loggers: immutable.Seq[String] = immutableSeq(getStringList("akka.loggers"))
    final val LoggersDispatcher: String = getString("akka.loggers-dispatcher")
    final val LoggingFilter: String = getString("akka.logging-filter")
    final val LoggerStartTimeout: Timeout = Timeout(config.getMillisDuration("akka.logger-startup-timeout"))
    final val LogConfigOnStart: Boolean = config.getBoolean("akka.log-config-on-start")
    final val LogDeadLetters: Int = toRootLowerCase(config.getString("akka.log-dead-letters")) match {
      case "off" | "false" => 0
      case "on" | "true"   => Int.MaxValue
      case _               => config.getInt("akka.log-dead-letters")
    }
    final val LogDeadLettersDuringShutdown: Boolean = config.getBoolean("akka.log-dead-letters-during-shutdown")
    final val LogDeadLettersSuspendDuration: Duration = {
      val key = "akka.log-dead-letters-suspend-duration"
      toRootLowerCase(config.getString(key)) match {
        case "infinite" => Duration.Inf
        case _          => config.getMillisDuration(key)
      }
    }

    final val AddLoggingReceive: Boolean = getBoolean("akka.actor.debug.receive")
    final val DebugAutoReceive: Boolean = getBoolean("akka.actor.debug.autoreceive")
    final val DebugLifecycle: Boolean = getBoolean("akka.actor.debug.lifecycle")
    final val FsmDebugEvent: Boolean = getBoolean("akka.actor.debug.fsm")
    final val DebugEventStream: Boolean = getBoolean("akka.actor.debug.event-stream")
    final val DebugUnhandledMessage: Boolean = getBoolean("akka.actor.debug.unhandled")
    final val DebugRouterMisconfiguration: Boolean = getBoolean("akka.actor.debug.router-misconfiguration")

    final val Home: Option[String] = config.getString("akka.home") match {
      case "" => None
      case x  => Some(x)
    }

    final val SchedulerClass: String = getString("akka.scheduler.implementation")
    final val Daemonicity: Boolean = getBoolean("akka.daemonic")
    final val JvmExitOnFatalError: Boolean = getBoolean("akka.jvm-exit-on-fatal-error")
    final val JvmShutdownHooks: Boolean = getBoolean("akka.jvm-shutdown-hooks")
    final val FailMixedVersions: Boolean = getBoolean("akka.fail-mixed-versions")

    final val CoordinatedShutdownTerminateActorSystem: Boolean = getBoolean(
      "akka.coordinated-shutdown.terminate-actor-system")
    final val CoordinatedShutdownRunByActorSystemTerminate: Boolean = getBoolean(
      "akka.coordinated-shutdown.run-by-actor-system-terminate")
    if (CoordinatedShutdownRunByActorSystemTerminate && !CoordinatedShutdownTerminateActorSystem)
      throw new ConfigurationException(
        "akka.coordinated-shutdown.run-by-actor-system-terminate=on and " +
        "akka.coordinated-shutdown.terminate-actor-system=off is not a supported configuration combination.")

    final val DefaultVirtualNodesFactor: Int = getInt("akka.actor.deployment.default.virtual-nodes-factor")

    if (ConfigVersion != Version)
      throw new akka.ConfigurationException(
        "Akka JAR version [" + Version + "] does not match the provided config version [" + ConfigVersion + "]")

    /**
     * Returns the String representation of the Config that this Settings is backed by
     */
    override def toString: String = config.root.render

  }

  private[akka] def findClassLoader(): ClassLoader = Reflect.findClassLoader()
}

/**
 * An actor system is a hierarchical group of actors which share common
 * configuration, e.g. dispatchers, deployments, remote capabilities and
 * addresses. It is also the entry point for creating or looking up actors.
 *
 * There are several possibilities for creating actors (see [[akka.actor.Props]]
 * for details on `props`):
 *
 * {{{
 * // Java or Scala
 * system.actorOf(props, "name")
 * system.actorOf(props)
 *
 * // Scala
 * system.actorOf(Props[MyActor], "name")
 * system.actorOf(Props(classOf[MyActor], arg1, arg2), "name")
 *
 * // Java
 * system.actorOf(Props.create(MyActor.class), "name");
 * system.actorOf(Props.create(MyActor.class, arg1, arg2), "name");
 * }}}
 *
 * Where no name is given explicitly, one will be automatically generated.
 *
 * <b><i>Important Notice:</i></b>
 *
 * This class is not meant to be extended by user code. If you want to
 * actually roll your own Akka, it will probably be better to look into
 * extending [[akka.actor.ExtendedActorSystem]] instead, but beware that you
 * are completely on your own in that case!
 */
abstract class ActorSystem extends ActorRefFactory with ClassicActorSystemProvider {
  import ActorSystem._

  /**
   * The name of this actor system, used to distinguish multiple ones within
   * the same JVM & class loader.
   */
  def name: String

  /**
   * The core settings extracted from the supplied configuration.
   */
  def settings: Settings

  /**
   * Log the configuration.
   */
  def logConfiguration(): Unit

  /**
   * Construct a path below the application guardian to be used with [[ActorSystem#actorSelection]].
   */
  def /(name: String): ActorPath

  /**
   * Java API: Create a new child actor path.
   */
  def child(child: String): ActorPath = /(child)

  /**
   * Construct a path below the application guardian to be used with [[ActorSystem#actorSelection]].
   */
  def /(name: Iterable[String]): ActorPath

  /**
   * Java API: Recursively create a descendant’s path by appending all child names.
   */
  def descendant(names: java.lang.Iterable[String]): ActorPath = /(immutableSeq(names))

  /**
   * Start-up time in milliseconds since the epoch.
   */
  val startTime: Long = System.currentTimeMillis

  /**
   * Up-time of this actor system in seconds.
   */
  def uptime: Long = (System.currentTimeMillis - startTime) / 1000

  /**
   * Main event bus of this actor system, used for example for logging.
   */
  def eventStream: EventStream

  /**
   * Java API: Main event bus of this actor system, used for example for logging.
   */
  def getEventStream: EventStream = eventStream

  /**
   * Convenient logging adapter for logging to the [[ActorSystem#eventStream]].
   */
  def log: LoggingAdapter

  /**
   * Actor reference where messages are re-routed to which were addressed to
   * stopped or non-existing actors. Delivery to this actor is done on a best
   * effort basis and hence not strictly guaranteed.
   */
  def deadLetters: ActorRef

  /**
   * Light-weight scheduler for running asynchronous tasks after some deadline
   * in the future. Not terribly precise but cheap.
   */
  def scheduler: Scheduler

  /**
   * Java API: Light-weight scheduler for running asynchronous tasks after some deadline
   * in the future. Not terribly precise but cheap.
   */
  def getScheduler: Scheduler = scheduler

  /**
   * Helper object for looking up configured dispatchers.
   */
  def dispatchers: Dispatchers

  /**
   * Default dispatcher as configured. This dispatcher is used for all actors
   * in the actor system which do not have a different dispatcher configured
   * explicitly.
   * Importing this member will place the default MessageDispatcher in scope.
   */
  implicit def dispatcher: ExecutionContextExecutor

  /**
   * Java API: Default dispatcher as configured. This dispatcher is used for all actors
   * in the actor system which do not have a different dispatcher configured
   * explicitly.
   * Importing this member will place the default MessageDispatcher in scope.
   */
  def getDispatcher: ExecutionContextExecutor = dispatcher

  /**
   * Helper object for looking up configured mailbox types.
   */
  def mailboxes: Mailboxes

  /**
   * Register a block of code (callback) to run after [[ActorSystem.terminate]] has been issued and
   * all actors in this actor system have been stopped.
   * Multiple code blocks may be registered by calling this method multiple times.
   * The callbacks will be run sequentially in reverse order of registration, i.e.
   * last registration is run first.
   * Note that ActorSystem will not terminate until all the registered callbacks are finished.
   *
   * Throws a RejectedExecutionException if the System has already been terminated or if termination has been initiated.
   *
   * Scala API
   */
  def registerOnTermination[T](code: => T): Unit

  /**
   * Java API: Register a block of code (callback) to run after [[ActorSystem.terminate]] has been issued and
   * all actors in this actor system have been stopped.
   * Multiple code blocks may be registered by calling this method multiple times.
   * The callbacks will be run sequentially in reverse order of registration, i.e.
   * last registration is run first.
   * Note that ActorSystem will not terminate until all the registered callbacks are finished.
   *
   * Throws a RejectedExecutionException if the System has already been terminated or if termination has been initiated.
   */
  def registerOnTermination(code: Runnable): Unit

  /**
   * Terminates this actor system by running [[CoordinatedShutdown]] with reason
   * [[CoordinatedShutdown.ActorSystemTerminateReason]].
   *
   * If `akka.coordinated-shutdown.run-by-actor-system-terminate` is configured to `off`
   * it will not run `CoordinatedShutdown`, but the `ActorSystem` and its actors
   * will still be terminated.
   *
   * This will stop the guardian actor, which in turn
   * will recursively stop all its child actors, and finally the system guardian
   * (below which the logging actors reside) and then execute all registered
   * termination handlers (see [[ActorSystem#registerOnTermination]]).
   * Be careful to not schedule any operations on completion of the returned future
   * using the dispatcher of this actor system as it will have been shut down before the
   * future completes.
   */
  def terminate(): Future[Terminated]

  /**
   * Returns a Future which will be completed after the ActorSystem has been terminated
   * and termination hooks have been executed. If you registered any callback with
   * [[ActorSystem#registerOnTermination]], the returned Future from this method will not complete
   * until all the registered callbacks are finished. Be careful to not schedule any operations,
   * such as `onComplete`, on the dispatchers (`ExecutionContext`) of this actor system as they
   * will have been shut down before this future completes.
   */
  def whenTerminated: Future[Terminated]

  /**
   * Returns a CompletionStage which will be completed after the ActorSystem has been terminated
   * and termination hooks have been executed. If you registered any callback with
   * [[ActorSystem#registerOnTermination]], the returned CompletionStage from this method will not complete
   * until all the registered callbacks are finished. Be careful to not schedule any operations,
   * such as `thenRunAsync`, on the dispatchers (`Executor`) of this actor system as they
   * will have been shut down before this CompletionStage completes.
   */
  def getWhenTerminated: CompletionStage[Terminated]

  /**
   * Registers the provided extension and creates its payload, if this extension isn't already registered
   * This method has putIfAbsent-semantics, this method can potentially block, waiting for the initialization
   * of the payload, if is in the process of registration from another Thread of execution
   */
  def registerExtension[T <: Extension](ext: ExtensionId[T]): T

  /**
   * Returns the payload that is associated with the provided extension
   * throws an IllegalStateException if it is not registered.
   * This method can potentially block, waiting for the initialization
   * of the payload, if is in the process of registration from another Thread of execution
   */
  def extension[T <: Extension](ext: ExtensionId[T]): T

  /**
   * Returns whether the specified extension is already registered, this method can potentially block, waiting for the initialization
   * of the payload, if is in the process of registration from another Thread of execution
   */
  def hasExtension(ext: ExtensionId[_ <: Extension]): Boolean
}

/**
 * More powerful interface to the actor system’s implementation which is presented to extensions (see [[akka.actor.Extension]]).
 *
 * <b><i>Important Notice:</i></b>
 *
 * This class is not meant to be extended by user code. If you want to
 * actually roll your own Akka, beware that you are completely on your own in
 * that case!
 */
@DoNotInherit
abstract class ExtendedActorSystem extends ActorSystem {

  /**
   * The ActorRefProvider is the only entity which creates all actor references within this actor system.
   */
  def provider: ActorRefProvider

  /**
   * The top-level supervisor of all actors created using system.actorOf(...).
   */
  def guardian: InternalActorRef

  /**
   * The top-level supervisor of all system-internal services like logging.
   */
  def systemGuardian: InternalActorRef

  /**
   * Create an actor in the "/system" namespace. This actor will be shut down
   * during system.terminate only after all user actors have terminated.
   *
   * This is only intended to be used by libraries (and Akka itself).
   * Applications should use ordinary `actorOf`.
   */
  def systemActorOf(props: Props, name: String): ActorRef

  /**
   * A ThreadFactory that can be used if the transport needs to create any Threads
   */
  def threadFactory: ThreadFactory

  /**
   * ClassLoader wrapper which is used for reflective accesses internally. This is set
   * to use the context class loader, if one is set, or the class loader which
   * loaded the ActorSystem implementation. The context class loader is also
   * set on all threads created by the ActorSystem, if one was set during
   * creation.
   */
  def dynamicAccess: DynamicAccess

  /**
   * Filter of log events that is used by the LoggingAdapter before
   * publishing log events to the eventStream
   */
  def logFilter: LoggingFilter

  /**
   * For debugging: traverse actor hierarchy and make string representation.
   * Careful, this may OOM on large actor systems, and it is only meant for
   * helping debugging in case something already went terminally wrong.
   */
  private[akka] def printTree: String

  /**
   * INTERNAL API: final step of `terminate()`
   */
  @InternalApi private[akka] def finalTerminate(): Unit

  /**
   * INTERNAL API
   */
  @InternalApi private[akka] def isTerminating(): Boolean

}

/**
 * Internal API
 */
@InternalApi
private[akka] class ActorSystemImpl(
    val name: String,
    applicationConfig: Config,
    classLoader: ClassLoader,
    defaultExecutionContext: Option[ExecutionContext],
    val guardianProps: Option[Props],
    setup: ActorSystemSetup)
    extends ExtendedActorSystem {

  if (!name.matches("""^[a-zA-Z0-9][a-zA-Z0-9-_]*$"""))
    throw new IllegalArgumentException(
      "invalid ActorSystem name [" + name +
      "], must contain only word characters (i.e. [a-zA-Z0-9] plus non-leading '-' or '_')")

  import ActorSystem._

  @volatile private var logDeadLetterListener: Option[ActorRef] = None

  private val _dynamicAccess: DynamicAccess = createDynamicAccess()

  final val settings: Settings = {
    val config = Settings.amendSlf4jConfig(
      applicationConfig.withFallback(ConfigFactory.defaultReference(classLoader)),
      _dynamicAccess)
    new Settings(classLoader, config, name, setup)
  }

  protected def uncaughtExceptionHandler: Thread.UncaughtExceptionHandler =
    new Thread.UncaughtExceptionHandler() {
      def uncaughtException(thread: Thread, cause: Throwable): Unit = {
        cause match {
          case NonFatal(_) | _: InterruptedException | _: NotImplementedError | _: ControlThrowable =>
            log.error(cause, "Uncaught error from thread [{}]", thread.getName)
          case _ =>
            if (cause.isInstanceOf[IncompatibleClassChangeError] && cause.getMessage.startsWith("akka"))
              System.err.println(
                s"""Detected ${cause.getClass.getName} error, which MAY be caused by incompatible Akka versions on the classpath.
                  | Please note that a given Akka version MUST be the same across all modules of Akka that you are using,
                  | e.g. if you use akka-actor [${akka.Version.current} (resolved from current classpath)] all other core
                  | Akka modules MUST be of the same version. External projects like Alpakka, Persistence plugins or Akka
                  | HTTP etc. have their own version numbers - please make sure you're using a compatible set of libraries.
                 """.stripMargin.replaceAll("[\r\n]", ""))

            if (settings.JvmExitOnFatalError)
              try logFatalError("shutting down JVM since 'akka.jvm-exit-on-fatal-error' is enabled for", cause, thread)
              finally System.exit(-1)
            else
              try logFatalError("shutting down", cause, thread)
              finally terminate()
        }
      }

      @inline
      private def logFatalError(message: String, cause: Throwable, thread: Thread): Unit = {
        // First log to stderr as this has the best chance to get through in an 'emergency panic' situation:
        import System.err
        err.print("Uncaught error from thread [")
        err.print(thread.getName)
        err.print("]: ")
        err.print(cause.getMessage)
        err.print(", ")
        err.print(message)
        err.print(" ActorSystem[")
        err.print(name)
        err.println("]")
        System.err.flush()
        cause.printStackTrace(System.err)
        System.err.flush()

        // Also log using the normal infrastructure - hope for the best:
        markerLogging.error(
          LogMarker.Security,
          cause,
          "Uncaught error from thread [{}]: " + cause.getMessage + ", " + message + " ActorSystem[{}]",
          thread.getName,
          name)
      }
    }

  final val threadFactory: MonitorableThreadFactory =
    MonitorableThreadFactory(name, settings.Daemonicity, Option(classLoader), uncaughtExceptionHandler)

  /**
   * This is an extension point: by overriding this method, subclasses can
   * control all reflection activities of an actor system.
   */
  protected def createDynamicAccess(): DynamicAccess = new ReflectiveDynamicAccess(classLoader)

  def dynamicAccess: DynamicAccess = _dynamicAccess

  def logConfiguration(): Unit = log.info(settings.toString)

  protected def systemImpl: ActorSystemImpl = this

  def systemActorOf(props: Props, name: String): ActorRef =
    systemGuardian.underlying.attachChild(props, name, systemService = true)

  def actorOf(props: Props, name: String): ActorRef =
    if (guardianProps.isEmpty) guardian.underlying.attachChild(props, name, systemService = false)
    else
      throw new UnsupportedOperationException(
        s"cannot create top-level actor [$name] from the outside on ActorSystem with custom user guardian")

  def actorOf(props: Props): ActorRef =
    if (guardianProps.isEmpty) guardian.underlying.attachChild(props, systemService = false)
    else
      throw new UnsupportedOperationException(
        "cannot create top-level actor from the outside on ActorSystem with custom user guardian")

  def stop(actor: ActorRef): Unit = {
    val path = actor.path
    val guard = guardian.path
    val sys = systemGuardian.path
    path.parent match {
      case `guard` => guardian ! StopChild(actor)
      case `sys`   => systemGuardian ! StopChild(actor)
      case _       => actor.asInstanceOf[InternalActorRef].stop()
    }
  }

  import settings._

  // this provides basic logging (to stdout) until .start() is called below
  val eventStream = new EventStream(this, DebugEventStream)
  eventStream.startStdoutLogger(settings)

  val logFilter: LoggingFilter = {
    val arguments = Vector(classOf[Settings] -> settings, classOf[EventStream] -> eventStream)
    dynamicAccess.createInstanceFor[LoggingFilter](LoggingFilter, arguments).get
  }

  private[this] val markerLogging =
    new MarkerLoggingAdapter(eventStream, getClass.getName + "(" + name + ")", this.getClass, logFilter)
  val log: LoggingAdapter = markerLogging

  val scheduler: Scheduler = createScheduler()

  val provider: ActorRefProvider = try {
    val arguments = Vector(
      classOf[String] -> name,
      classOf[Settings] -> settings,
      classOf[EventStream] -> eventStream,
      classOf[DynamicAccess] -> dynamicAccess)

    dynamicAccess.createInstanceFor[ActorRefProvider](ProviderClass, arguments).get
  } catch {
    case NonFatal(e) =>
      Try(stopScheduler())
      throw e
  }

  def deadLetters: ActorRef = provider.deadLetters

  val mailboxes: Mailboxes = new Mailboxes(settings, eventStream, dynamicAccess, deadLetters)

  val dispatchers: Dispatchers = new Dispatchers(
    settings,
    DefaultDispatcherPrerequisites(
      threadFactory,
      eventStream,
      scheduler,
      dynamicAccess,
      settings,
      mailboxes,
      defaultExecutionContext),
    log)

  val dispatcher: ExecutionContextExecutor = dispatchers.defaultGlobalDispatcher

  private[this] final val terminationCallbacks = new TerminationCallbacks(provider.terminationFuture)(dispatcher)

  override def whenTerminated: Future[Terminated] = terminationCallbacks.terminationFuture
  override def getWhenTerminated: CompletionStage[Terminated] = FutureConverters.toJava(whenTerminated)
  def lookupRoot: InternalActorRef = provider.rootGuardian
  def guardian: LocalActorRef = provider.guardian
  def systemGuardian: LocalActorRef = provider.systemGuardian

  def /(actorName: String): ActorPath = guardian.path / actorName
  def /(path: Iterable[String]): ActorPath = guardian.path / path

  override def classicSystem: ActorSystem = this

  // Used for ManifestInfo.checkSameVersion
  private def allModules: List[String] =
    List(
      "akka-actor",
      "akka-actor-testkit-typed",
      "akka-actor-typed",
      "akka-cluster",
      "akka-cluster-metrics",
      "akka-cluster-sharding",
      "akka-cluster-sharding-typed",
      "akka-cluster-tools",
      "akka-cluster-typed",
      "akka-coordination",
      "akka-discovery",
      "akka-distributed-data",
      "akka-testkit",
      "akka-multi-node-testkit",
      "akka-osgi",
      "akka-persistence",
      "akka-persistence-query",
      "akka-persistence-shared",
      "akka-persistence-testkit",
      "akka-persistence-typed",
      "akka-pki",
      "akka-protobuf",
      "akka-protobuf-v3",
      "akka-remote",
      "akka-serialization-jackson",
      "akka-slf4j",
      "akka-stream",
      "akka-stream-testkit",
      "akka-stream-typed",
      "akka-stream-testkit")

  @volatile private var _initialized = false

  /**
   *  Asserts that the ActorSystem has been fully initialized. Can be used to guard code blocks that might accidentally
   *  be run during initialization but require a fully initialized ActorSystem before proceeding.
   */
  def assertInitialized(): Unit =
    if (!_initialized)
      throw new IllegalStateException(
        "The calling code expected that the ActorSystem was initialized but it wasn't yet. " +
        "This is probably a bug in the ActorSystem initialization sequence often related to initialization of extensions. " +
        "Please report at https://github.com/akka/akka/issues.")
  private lazy val _start: this.type = try {

    registerOnTermination(stopScheduler())
    // the provider is expected to start default loggers, LocalActorRefProvider does this
    provider.init(this)
    // at this point it should be initialized "enough" for most extensions that we might want to guard against otherwise
    _initialized = true

    if (settings.LogDeadLetters > 0)
      logDeadLetterListener = Some(systemActorOf(Props[DeadLetterListener](), "deadLetterListener"))
    eventStream.startUnsubscriber()
    ManifestInfo(this).checkSameVersion("Akka", allModules, logWarning = true)
    if (!terminating)
      loadExtensions()
    if (LogConfigOnStart) logConfiguration()
    this
  } catch {
    case NonFatal(e) =>
      try terminate()
      catch { case NonFatal(_) => Try(stopScheduler()) }
      throw e
  }

  def start(): this.type = _start
  def registerOnTermination[T](code: => T): Unit = { registerOnTermination(new Runnable { def run = code }) }
  def registerOnTermination(code: Runnable): Unit = { terminationCallbacks.add(code) }

  @volatile private var terminating = false

  override def terminate(): Future[Terminated] = {
    terminating = true
    if (settings.CoordinatedShutdownRunByActorSystemTerminate && !aborting) {
      // Note that the combination CoordinatedShutdownRunByActorSystemTerminate==true &&
      // CoordinatedShutdownTerminateActorSystem==false is disallowed, checked in Settings.
      // It's not a combination that is valuable to support and it would be complicated to
      // protect against concurrency race conditions between calls to ActorSystem.terminate()
      // and CoordinateShutdown.run()

      // it will call finalTerminate() at the end
      CoordinatedShutdown(this).run(CoordinatedShutdown.ActorSystemTerminateReason)
    } else {
      finalTerminate()
    }
    whenTerminated
  }

  override private[akka] def finalTerminate(): Unit = {
    terminating = true
    // these actions are idempotent
    if (!settings.LogDeadLettersDuringShutdown) logDeadLetterListener.foreach(stop)
    guardian.stop()
  }

  override private[akka] def isTerminating(): Boolean = {
    terminating || aborting || CoordinatedShutdown(this).shutdownReason().isDefined
  }

  @volatile var aborting = false

  /**
   * This kind of shutdown attempts to bring the system down and release its
   * resources more forcefully than plain shutdown. For example it will not
   * run CoordinatedShutdown and not wait for remote-deployed child actors to
   * terminate before terminating their parents.
   */
  def abort(): Unit = {
    aborting = true
    terminate()
  }

  //#create-scheduler
  /**
   * Create the scheduler service. This one needs one special behavior: if
   * Closeable, it MUST execute all outstanding tasks upon .close() in order
   * to properly shutdown all dispatchers.
   *
   * Furthermore, this timer service MUST throw IllegalStateException if it
   * cannot schedule a task. Once scheduled, the task MUST be executed. If
   * executed upon close(), the task may execute before its timeout.
   */
  protected def createScheduler(): Scheduler =
    dynamicAccess
      .createInstanceFor[Scheduler](
        settings.SchedulerClass,
        immutable.Seq(
          classOf[Config] -> settings.config,
          classOf[LoggingAdapter] -> log,
          classOf[ThreadFactory] -> threadFactory.withName(threadFactory.name + "-scheduler")))
      .get
  //#create-scheduler

  /*
   * This is called after the last actor has signaled its termination, i.e.
   * after the last dispatcher has had its chance to schedule its shutdown
   * action.
   */
  protected def stopScheduler(): Unit = scheduler match {
    case x: Closeable => x.close()
    case _            =>
  }

  // For each ExtensionId, either:
  // 1) a CountDownLatch (if it's still in the process of being registered),
  // 2) a Throwable (if it failed initializing), or
  // 3) the registered extension.
  private val extensions = new ConcurrentHashMap[ExtensionId[_], AnyRef]

  /**
   * Returns any extension registered to the specified Extension or returns null if not registered
   */
  @tailrec
  private def findExtension[T <: Extension](ext: ExtensionId[T]): T = extensions.get(ext) match {
    case c: CountDownLatch =>
      blocking {
        val awaitMillis = settings.CreationTimeout.duration.toMillis
        if (!c.await(awaitMillis, TimeUnit.MILLISECONDS))
          throw new IllegalStateException(
            s"Initialization of [$ext] took more than [$awaitMillis ms]. " +
            (if (ext == SerializationExtension)
               "A serializer must not access the SerializationExtension from its constructor. Use lazy init."
             else "Could be deadlock due to cyclic initialization of extensions."))
      }
      findExtension(ext) //Registration in process, await completion and retry
    case t: Throwable => throw t //Initialization failed, throw same again
    case other =>
      other.asInstanceOf[T] //could be a T or null, in which case we return the null as T
  }

  @tailrec
  final def registerExtension[T <: Extension](ext: ExtensionId[T]): T = {
    findExtension(ext) match {
      case null => //Doesn't already exist, commence registration
        val inProcessOfRegistration = new CountDownLatch(1)
        extensions.putIfAbsent(ext, inProcessOfRegistration) match { // Signal that registration is in process
          case null =>
            try { // Signal was successfully sent
              ext.createExtension(this) match { // Create and initialize the extension
                case null =>
                  throw new IllegalStateException(s"Extension instance created as 'null' for extension [$ext]")
                case instance =>
                  extensions.replace(ext, inProcessOfRegistration, instance) //Replace our in process signal with the initialized extension
                  instance //Profit!
              }
            } catch {
              case t: Throwable =>
                extensions.replace(ext, inProcessOfRegistration, t) //In case shit hits the fan, remove the inProcess signal
                throw t //Escalate to caller
            } finally {
              inProcessOfRegistration.countDown() //Always notify listeners of the inProcess signal
            }
          case _ =>
            registerExtension(ext) //Someone else is in process of registering an extension for this Extension, retry
        }
      case existing => existing.asInstanceOf[T]
    }
  }

  def extension[T <: Extension](ext: ExtensionId[T]): T = findExtension(ext) match {
    case null => throw new IllegalArgumentException(s"Trying to get non-registered extension [$ext]")
    case some => some.asInstanceOf[T]
  }

  def hasExtension(ext: ExtensionId[_ <: Extension]): Boolean = findExtension(ext) != null

  private def loadExtensions(): Unit = {

    /*
     * @param throwOnLoadFail
     *  Throw exception when an extension fails to load (needed for backwards compatibility.
     *    when the extension cannot be found at all we throw regardless of this setting)
     */
    def loadExtensions(key: String, throwOnLoadFail: Boolean): Unit = {

      immutableSeq(settings.config.getStringList(key)).foreach { fqcn =>
        dynamicAccess.getObjectFor[AnyRef](fqcn).recoverWith {
          case firstProblem =>
            dynamicAccess.createInstanceFor[AnyRef](fqcn, Nil).recoverWith { case _ => Failure(firstProblem) }
        } match {
          case Success(p: ExtensionIdProvider) =>
            registerExtension(p.lookup)
          case Success(p: ExtensionId[_]) =>
            registerExtension(p)
          case Success(_) =>
            if (!throwOnLoadFail) log.error("[{}] is not an 'ExtensionIdProvider' or 'ExtensionId', skipping...", fqcn)
            else throw new RuntimeException(s"[$fqcn] is not an 'ExtensionIdProvider' or 'ExtensionId'")
          case Failure(problem) =>
            if (!throwOnLoadFail) log.error(problem, "While trying to load extension [{}], skipping...", fqcn)
            else throw new RuntimeException(s"While trying to load extension [$fqcn]", problem)
        }
      }
    }

    loadExtensions("akka.library-extensions", throwOnLoadFail = true)
    loadExtensions("akka.extensions", throwOnLoadFail = false)
  }

  override def toString: String = lookupRoot.path.root.address.toString

  override def printTree: String = {
    def printNode(node: ActorRef, indent: String): String = {
      node match {
        case wc: ActorRefWithCell =>
          val cell = wc.underlying
          (if (indent.isEmpty) "-> " else indent.dropRight(1) + "⌊-> ") +
          node.path.name + " " + Logging.simpleName(node) + " " +
          (cell match {
            case real: ActorCell =>
              val realActor = real.actor
              if (realActor ne null) realActor.getClass else "null"
            case _ => Logging.simpleName(cell)
          }) +
          (cell match {
            case real: ActorCell => " status=" + real.mailbox.currentStatus
            case _               => ""
          }) +
          " " + (cell.childrenRefs match {
            case ChildrenContainer.TerminatingChildrenContainer(_, toDie, reason) =>
              "Terminating(" + reason + ")" +
              (toDie.toSeq.sorted.mkString("\n" + indent + "   |    toDie: ", "\n" + indent + "   |           ", ""))
            case x @ (ChildrenContainer.TerminatedChildrenContainer | ChildrenContainer.EmptyChildrenContainer) =>
              x.toString
            case n: ChildrenContainer.NormalChildrenContainer => n.c.size.toString + " children"
            case x                                            => Logging.simpleName(x)
          }) +
          (if (cell.childrenRefs.children.isEmpty) "" else "\n") +
          ({
            val children = cell.childrenRefs.children.toSeq.sorted
            val bulk = children.dropRight(1).map(printNode(_, indent + "   |"))
            bulk ++ (children.lastOption.map(printNode(_, indent + "    ")))
          }.mkString("\n"))
        case _ =>
          indent + node.path.name + " " + Logging.simpleName(node)
      }
    }
    printNode(lookupRoot, "")
  }

  final class TerminationCallbacks[T](upStreamTerminated: Future[T])(implicit ec: ExecutionContext) {
    private[this] final val done = Promise[T]()
    private[this] final val ref = new AtomicReference(done)

    // onComplete never fires twice so safe to avoid null check
    upStreamTerminated.onComplete { t =>
      ref.getAndSet(null).complete(t)
    }

    /**
     * Adds a Runnable that will be executed on ActorSystem termination.
     * Note that callbacks are executed in reverse order of insertion.
     *
     * @param r The callback to be executed on ActorSystem termination
     * Throws RejectedExecutionException if called after ActorSystem has been terminated.
     */
    final def add(r: Runnable): Unit = {
      @tailrec def addRec(r: Runnable, p: Promise[T]): Unit = ref.get match {
        case null                               => throw new RejectedExecutionException("ActorSystem already terminated.")
        case some if ref.compareAndSet(some, p) => some.completeWith(p.future.andThen { case _ => r.run() })
        case _                                  => addRec(r, p)
      }
      addRec(r, Promise[T]())
    }

    /**
     * Returns a Future which will be completed once all registered callbacks have been executed.
     */
    def terminationFuture: Future[T] = done.future
  }
}

[0m2021.03.29 19:43:24 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m
package controllers

import javax.inject._
import play.api._
import play.api.mvc._
import _root_.db.ScalaApplicationDatabase

/** This controller creates an `Action` to handle HTTP requests to the
  * application's home page.
  */
@Singleton
class HomeController @Inject() (
    val controllerComponents: ControllerComponents,
    val db: ScalaApplicationDatabase
) extends BaseController {

  /** Create an Action to render an HTML page.
    *
    * The configuration in the `routes` file means that this method
    * will be called when the application receives a `GET` request with
    * a path of `/`.
    */
  def index() = Action { implicit request: Request[AnyContent] =>
    println("hit index")
    db.updateSomething()
    Ok(views.html.index())
  }
}

[0m2021.03.29 19:43:24 INFO  time: code lens generation in 9.61s[0m
[0m2021.03.29 19:43:26 INFO  time: indexed workspace in 8.25s[0m
/*
 * Copyright (C) 2009-2020 Lightbend Inc. <https://www.lightbend.com>
 */

package akka.actor

import java.io.Closeable
import java.util.Optional
import java.util.concurrent._
import java.util.concurrent.atomic.AtomicReference

import scala.annotation.tailrec
import scala.collection.immutable
import scala.compat.java8.FutureConverters
import scala.compat.java8.OptionConverters._
import scala.concurrent.{ ExecutionContext, ExecutionContextExecutor, Future, Promise }
import scala.concurrent.blocking
import scala.concurrent.duration.Duration
import scala.util.{ Failure, Success, Try }
import scala.util.control.{ ControlThrowable, NonFatal }

import com.typesafe.config.{ Config, ConfigFactory }

import akka.ConfigurationException
import akka.actor.dungeon.ChildrenContainer
import akka.actor.setup.{ ActorSystemSetup, Setup }
import akka.annotation.DoNotInherit
import akka.annotation.InternalApi
import akka.dispatch._
import akka.event._
import akka.event.Logging.DefaultLogger
import akka.japi.Util.immutableSeq
import akka.serialization.SerializationExtension
import akka.util._
import akka.util.Helpers.toRootLowerCase

object BootstrapSetup {

  /**
   * Scala API: Construct a bootstrap settings with default values. Note that passing that to the actor system is the
   * same as not passing any [[BootstrapSetup]] at all. You can use the returned instance to derive
   * one that has other values than defaults using the various `with`-methods.
   */
  def apply(): BootstrapSetup = {
    new BootstrapSetup()
  }

  /**
   * Scala API: Create bootstrap settings needed for starting the actor system
   *
   * @see [[BootstrapSetup]] for description of the properties
   */
  def apply(
      classLoader: Option[ClassLoader],
      config: Option[Config],
      defaultExecutionContext: Option[ExecutionContext]): BootstrapSetup =
    new BootstrapSetup(classLoader, config, defaultExecutionContext)

  /**
   * Scala API: Short for using custom config but keeping default classloader and default execution context
   */
  def apply(config: Config): BootstrapSetup = apply(None, Some(config), None)

  /**
   * Java API: Create bootstrap settings needed for starting the actor system
   *
   * @see [[BootstrapSetup]] for description of the properties
   */
  def create(
      classLoader: Optional[ClassLoader],
      config: Optional[Config],
      defaultExecutionContext: Optional[ExecutionContext]): BootstrapSetup =
    apply(classLoader.asScala, config.asScala, defaultExecutionContext.asScala)

  /**
   * Java  API: Short for using custom config but keeping default classloader and default execution context
   */
  def create(config: Config): BootstrapSetup = apply(config)

  /**
   * Java API: Construct a bootstrap settings with default values. Note that passing that to the actor system is the
   * same as not passing any [[BootstrapSetup]] at all. You can use the returned instance to derive
   * one that has other values than defaults using the various `with`-methods.
   */
  def create(): BootstrapSetup = {
    new BootstrapSetup()
  }

}

/**
 * @param identifier the simple name of the selected provider
 * @param fqcn the fully-qualified class name of the selected provider
 */
abstract class ProviderSelection private (
    private[akka] val identifier: String,
    private[akka] val fqcn: String,
    private[akka] val hasCluster: Boolean)
object ProviderSelection {
  private[akka] val RemoteActorRefProvider = "akka.remote.RemoteActorRefProvider"
  private[akka] val ClusterActorRefProvider = "akka.cluster.ClusterActorRefProvider"

  case object Local extends ProviderSelection("local", classOf[LocalActorRefProvider].getName, hasCluster = false)
  // these two cannot be referenced by class as they may not be on the classpath
  case object Remote extends ProviderSelection("remote", RemoteActorRefProvider, hasCluster = false)
  case object Cluster extends ProviderSelection("cluster", ClusterActorRefProvider, hasCluster = true)
  final case class Custom(override val fqcn: String) extends ProviderSelection("custom", fqcn, hasCluster = false)

  /**
   * JAVA API
   */
  def local(): ProviderSelection = Local

  /**
   * JAVA API
   */
  def remote(): ProviderSelection = Remote

  /**
   * JAVA API
   */
  def cluster(): ProviderSelection = Cluster

  /** INTERNAL API */
  @InternalApi private[akka] def apply(providerClass: String): ProviderSelection =
    providerClass match {
      case "local" => Local
      // additional fqcn for older configs not using 'remote' or 'cluster'
      case "remote" | RemoteActorRefProvider   => Remote
      case "cluster" | ClusterActorRefProvider => Cluster
      case fqcn                                => Custom(fqcn)
    }
}

/**
 * Core bootstrap settings of the actor system, create using one of the factories in [[BootstrapSetup]],
 * constructor is *Internal API*.
 *
 * @param classLoader If no ClassLoader is given, it obtains the current ClassLoader by first inspecting the current
 *                    threads' getContextClassLoader, then tries to walk the stack to find the callers class loader, then
 *                    falls back to the ClassLoader associated with the ActorSystem class.
 * @param config Configuration to use for the actor system. If no Config is given, the default reference config will be obtained from the ClassLoader.
 * @param defaultExecutionContext If defined the ExecutionContext will be used as the default executor inside this ActorSystem.
 *                                If no ExecutionContext is given, the system will fallback to the executor configured under
 *                                "akka.actor.default-dispatcher.default-executor.fallback".
 * @param actorRefProvider Overrides the `akka.actor.provider` setting in config, can be `local` (default), `remote` or
 *                         `cluster`. It can also be a fully qualified class name of a provider.
 */
final class BootstrapSetup private (
    val classLoader: Option[ClassLoader] = None,
    val config: Option[Config] = None,
    val defaultExecutionContext: Option[ExecutionContext] = None,
    val actorRefProvider: Option[ProviderSelection] = None)
    extends Setup {

  def withClassloader(classLoader: ClassLoader): BootstrapSetup =
    new BootstrapSetup(Some(classLoader), config, defaultExecutionContext, actorRefProvider)

  def withConfig(config: Config): BootstrapSetup =
    new BootstrapSetup(classLoader, Some(config), defaultExecutionContext, actorRefProvider)

  def withDefaultExecutionContext(executionContext: ExecutionContext): BootstrapSetup =
    new BootstrapSetup(classLoader, config, Some(executionContext), actorRefProvider)

  def withActorRefProvider(name: ProviderSelection): BootstrapSetup =
    new BootstrapSetup(classLoader, config, defaultExecutionContext, Some(name))

}

object ActorSystem {

  val Version: String = akka.Version.current // generated file

  /**
   * Creates a new ActorSystem with the name "default",
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def create(): ActorSystem = apply()

  /**
   * Creates a new ActorSystem with the specified name,
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def create(name: String): ActorSystem = apply(name)

  /**
   * Java API: Creates a new actor system with the specified name and settings
   * The core actor system settings are defined in [[BootstrapSetup]]
   */
  def create(name: String, setups: ActorSystemSetup): ActorSystem = apply(name, setups)

  /**
   * Java API: Shortcut for creating an actor system with custom bootstrap settings.
   * Same behavior as calling `ActorSystem.create(name, ActorSystemSetup.create(bootstrapSettings))`
   */
  def create(name: String, bootstrapSetup: BootstrapSetup): ActorSystem =
    create(name, ActorSystemSetup.create(bootstrapSetup))

  /**
   * Creates a new ActorSystem with the specified name, and the specified Config, then
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def create(name: String, config: Config): ActorSystem = apply(name, config)

  /**
   * Creates a new ActorSystem with the specified name, the specified Config, and specified ClassLoader
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def create(name: String, config: Config, classLoader: ClassLoader): ActorSystem = apply(name, config, classLoader)

  /**
   * Creates a new ActorSystem with the specified name, the specified Config, the specified ClassLoader,
   * and the specified ExecutionContext. The ExecutionContext will be used as the default executor inside this ActorSystem.
   * If `null` is passed in for the Config, ClassLoader and/or ExecutionContext parameters, the respective default value
   * will be used. If no Config is given, the default reference config will be obtained from the ClassLoader.
   * If no ClassLoader is given, it obtains the current ClassLoader by first inspecting the current
   * threads' getContextClassLoader, then tries to walk the stack to find the callers class loader, then
   * falls back to the ClassLoader associated with the ActorSystem class. If no ExecutionContext is given, the
   * system will fallback to the executor configured under "akka.actor.default-dispatcher.default-executor.fallback".
   * Note that the given ExecutionContext will be used by all dispatchers that have been configured with
   * executor = "default-executor", including those that have not defined the executor setting and thereby fallback
   * to the default of "default-dispatcher.executor".
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def create(
      name: String,
      config: Config,
      classLoader: ClassLoader,
      defaultExecutionContext: ExecutionContext): ActorSystem =
    apply(name, Option(config), Option(classLoader), Option(defaultExecutionContext))

  /**
   * Creates a new ActorSystem with the name "default",
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def apply(): ActorSystem = apply("default")

  /**
   * Creates a new ActorSystem with the specified name,
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def apply(name: String): ActorSystem = apply(name, None, None, None)

  /**
   * Scala API: Creates a new actor system with the specified name and settings
   * The core actor system settings are defined in [[BootstrapSetup]]
   */
  def apply(name: String, setup: ActorSystemSetup): ActorSystem = {
    val bootstrapSettings = setup.get[BootstrapSetup]
    val cl = bootstrapSettings.flatMap(_.classLoader).getOrElse(findClassLoader())
    val appConfig = bootstrapSettings.flatMap(_.config).getOrElse(ConfigFactory.load(cl))
    val defaultEC = bootstrapSettings.flatMap(_.defaultExecutionContext)

    new ActorSystemImpl(name, appConfig, cl, defaultEC, None, setup).start()
  }

  /**
   * Scala API: Shortcut for creating an actor system with custom bootstrap settings.
   * Same behavior as calling `ActorSystem(name, ActorSystemSetup(bootstrapSetup))`
   */
  def apply(name: String, bootstrapSetup: BootstrapSetup): ActorSystem =
    create(name, ActorSystemSetup.create(bootstrapSetup))

  /**
   * Creates a new ActorSystem with the specified name, and the specified Config, then
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def apply(name: String, config: Config): ActorSystem = apply(name, Option(config), None, None)

  /**
   * Creates a new ActorSystem with the specified name, the specified Config, and specified ClassLoader
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def apply(name: String, config: Config, classLoader: ClassLoader): ActorSystem =
    apply(name, Option(config), Option(classLoader), None)

  /**
   * Creates a new ActorSystem with the specified name,
   * the specified ClassLoader if given, otherwise obtains the current ClassLoader by first inspecting the current
   * threads' getContextClassLoader, then tries to walk the stack to find the callers class loader, then
   * falls back to the ClassLoader associated with the ActorSystem class.
   * If an ExecutionContext is given, it will be used as the default executor inside this ActorSystem.
   * If no ExecutionContext is given, the system will fallback to the executor configured under "akka.actor.default-dispatcher.default-executor.fallback".
   * The system will use the passed in config, or falls back to the default reference configuration using the ClassLoader.
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def apply(
      name: String,
      config: Option[Config] = None,
      classLoader: Option[ClassLoader] = None,
      defaultExecutionContext: Option[ExecutionContext] = None): ActorSystem =
    apply(name, ActorSystemSetup(BootstrapSetup(classLoader, config, defaultExecutionContext)))

  /**
   * INTERNAL API
   */
  @InternalApi private[akka] object Settings {

    /**
     * INTERNAL API
     *
     * When using Akka Typed the Slf4jLogger should be used by default.
     * Looking for config property `akka.use-slf4j` (defined in akka-actor-typed) and
     * that `Slf4jLogger` (akka-slf4j) is in  classpath.
     * Then adds `Slf4jLogger` to configured loggers and removes `DefaultLogger`.
     */
    @InternalApi private[akka] def amendSlf4jConfig(config: Config, dynamicAccess: DynamicAccess): Config = {
      val slf4jLoggerClassName = "akka.event.slf4j.Slf4jLogger"
      val slf4jLoggingFilterClassName = "akka.event.slf4j.Slf4jLoggingFilter"
      val loggersConfKey = "akka.loggers"
      val loggingFilterConfKey = "akka.logging-filter"
      val configuredLoggers = immutableSeq(config.getStringList(loggersConfKey))
      val configuredLoggingFilter = config.getString(loggingFilterConfKey)

      val loggingFilterAlreadyConfigured =
        configuredLoggingFilter == slf4jLoggingFilterClassName || configuredLoggingFilter != classOf[
            DefaultLoggingFilter].getName

      def newLoggingFilterConfStr = s"""$loggingFilterConfKey = "$slf4jLoggingFilterClassName""""

      if (configuredLoggers.contains(slf4jLoggerClassName)) {
        // already configured explicitly
        if (loggingFilterAlreadyConfigured)
          config
        else
          ConfigFactory.parseString(newLoggingFilterConfStr).withFallback(config)
      } else {
        val confKey = "akka.use-slf4j"
        if (config.hasPath(confKey) && config.getBoolean(confKey) && dynamicAccess.classIsOnClasspath(
              slf4jLoggerClassName)) {
          val newLoggers = slf4jLoggerClassName +: configuredLoggers.filterNot(_ == classOf[DefaultLogger].getName)
          val newLoggersConfStr = s"$loggersConfKey = [${newLoggers.mkString("\"", "\", \"", "\"")}]"
          val newConfStr =
            if (loggingFilterAlreadyConfigured) newLoggersConfStr
            else newLoggersConfStr + "\n" + newLoggingFilterConfStr
          ConfigFactory.parseString(newConfStr).withFallback(config)
        } else
          config
      }
    }
  }

  /**
   * Settings are the overall ActorSystem Settings which also provides a convenient access to the Config object.
   *
   * For more detailed information about the different possible configuration options, look in the Akka Documentation under "Configuration"
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  class Settings(classLoader: ClassLoader, cfg: Config, final val name: String, val setup: ActorSystemSetup) {

    def this(classLoader: ClassLoader, cfg: Config, name: String) = this(classLoader, cfg, name, ActorSystemSetup())

    /**
     * The backing Config of this ActorSystem's Settings
     *
     * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
     */
    final val config: Config = {
      cfg.checkValid(
        ConfigFactory
          .defaultReference(classLoader)
          .withoutPath(Dispatchers.InternalDispatcherId), // allow this to be both string and config object
        "akka")
      cfg
    }

    import config._

    import akka.util.Helpers.ConfigOps

    final val ConfigVersion: String = getString("akka.version")

    private final val providerSelectionSetup = setup
      .get[BootstrapSetup]
      .flatMap(_.actorRefProvider)
      .map(_.identifier)
      .getOrElse(getString("akka.actor.provider"))

    final val ProviderSelectionType: ProviderSelection = ProviderSelection(providerSelectionSetup)

    final val ProviderClass: String = ProviderSelectionType.fqcn

    final val HasCluster: Boolean = ProviderSelectionType.hasCluster

    final val SupervisorStrategyClass: String = getString("akka.actor.guardian-supervisor-strategy")
    final val CreationTimeout: Timeout = Timeout(config.getMillisDuration("akka.actor.creation-timeout"))
    final val UnstartedPushTimeout: Timeout = Timeout(config.getMillisDuration("akka.actor.unstarted-push-timeout"))

    final val AllowJavaSerialization: Boolean = getBoolean("akka.actor.allow-java-serialization")
    @deprecated("Always enabled from Akka 2.6.0", "2.6.0")
    final val EnableAdditionalSerializationBindings: Boolean = true
    final val SerializeAllMessages: Boolean = getBoolean("akka.actor.serialize-messages")
    final val SerializeAllCreators: Boolean = getBoolean("akka.actor.serialize-creators")
    final val NoSerializationVerificationNeededClassPrefix: Set[String] = {
      import akka.util.ccompat.JavaConverters._
      getStringList("akka.actor.no-serialization-verification-needed-class-prefix").asScala.toSet
    }

    final val LogLevel: String = getString("akka.loglevel")
    final val StdoutLogLevel: String = getString("akka.stdout-loglevel")
    final val Loggers: immutable.Seq[String] = immutableSeq(getStringList("akka.loggers"))
    final val LoggersDispatcher: String = getString("akka.loggers-dispatcher")
    final val LoggingFilter: String = getString("akka.logging-filter")
    final val LoggerStartTimeout: Timeout = Timeout(config.getMillisDuration("akka.logger-startup-timeout"))
    final val LogConfigOnStart: Boolean = config.getBoolean("akka.log-config-on-start")
    final val LogDeadLetters: Int = toRootLowerCase(config.getString("akka.log-dead-letters")) match {
      case "off" | "false" => 0
      case "on" | "true"   => Int.MaxValue
      case _               => config.getInt("akka.log-dead-letters")
    }
    final val LogDeadLettersDuringShutdown: Boolean = config.getBoolean("akka.log-dead-letters-during-shutdown")
    final val LogDeadLettersSuspendDuration: Duration = {
      val key = "akka.log-dead-letters-suspend-duration"
      toRootLowerCase(config.getString(key)) match {
        case "infinite" => Duration.Inf
        case _          => config.getMillisDuration(key)
      }
    }

    final val AddLoggingReceive: Boolean = getBoolean("akka.actor.debug.receive")
    final val DebugAutoReceive: Boolean = getBoolean("akka.actor.debug.autoreceive")
    final val DebugLifecycle: Boolean = getBoolean("akka.actor.debug.lifecycle")
    final val FsmDebugEvent: Boolean = getBoolean("akka.actor.debug.fsm")
    final val DebugEventStream: Boolean = getBoolean("akka.actor.debug.event-stream")
    final val DebugUnhandledMessage: Boolean = getBoolean("akka.actor.debug.unhandled")
    final val DebugRouterMisconfiguration: Boolean = getBoolean("akka.actor.debug.router-misconfiguration")

    final val Home: Option[String] = config.getString("akka.home") match {
      case "" => None
      case x  => Some(x)
    }

    final val SchedulerClass: String = getString("akka.scheduler.implementation")
    final val Daemonicity: Boolean = getBoolean("akka.daemonic")
    final val JvmExitOnFatalError: Boolean = getBoolean("akka.jvm-exit-on-fatal-error")
    final val JvmShutdownHooks: Boolean = getBoolean("akka.jvm-shutdown-hooks")
    final val FailMixedVersions: Boolean = getBoolean("akka.fail-mixed-versions")

    final val CoordinatedShutdownTerminateActorSystem: Boolean = getBoolean(
      "akka.coordinated-shutdown.terminate-actor-system")
    final val CoordinatedShutdownRunByActorSystemTerminate: Boolean = getBoolean(
      "akka.coordinated-shutdown.run-by-actor-system-terminate")
    if (CoordinatedShutdownRunByActorSystemTerminate && !CoordinatedShutdownTerminateActorSystem)
      throw new ConfigurationException(
        "akka.coordinated-shutdown.run-by-actor-system-terminate=on and " +
        "akka.coordinated-shutdown.terminate-actor-system=off is not a supported configuration combination.")

    final val DefaultVirtualNodesFactor: Int = getInt("akka.actor.deployment.default.virtual-nodes-factor")

    if (ConfigVersion != Version)
      throw new akka.ConfigurationException(
        "Akka JAR version [" + Version + "] does not match the provided config version [" + ConfigVersion + "]")

    /**
     * Returns the String representation of the Config that this Settings is backed by
     */
    override def toString: String = config.root.render

  }

  private[akka] def findClassLoader(): ClassLoader = Reflect.findClassLoader()
}

/**
 * An actor system is a hierarchical group of actors which share common
 * configuration, e.g. dispatchers, deployments, remote capabilities and
 * addresses. It is also the entry point for creating or looking up actors.
 *
 * There are several possibilities for creating actors (see [[akka.actor.Props]]
 * for details on `props`):
 *
 * {{{
 * // Java or Scala
 * system.actorOf(props, "name")
 * system.actorOf(props)
 *
 * // Scala
 * system.actorOf(Props[MyActor], "name")
 * system.actorOf(Props(classOf[MyActor], arg1, arg2), "name")
 *
 * // Java
 * system.actorOf(Props.create(MyActor.class), "name");
 * system.actorOf(Props.create(MyActor.class, arg1, arg2), "name");
 * }}}
 *
 * Where no name is given explicitly, one will be automatically generated.
 *
 * <b><i>Important Notice:</i></b>
 *
 * This class is not meant to be extended by user code. If you want to
 * actually roll your own Akka, it will probably be better to look into
 * extending [[akka.actor.ExtendedActorSystem]] instead, but beware that you
 * are completely on your own in that case!
 */
abstract class ActorSystem extends ActorRefFactory with ClassicActorSystemProvider {
  import ActorSystem._

  /**
   * The name of this actor system, used to distinguish multiple ones within
   * the same JVM & class loader.
   */
  def name: String

  /**
   * The core settings extracted from the supplied configuration.
   */
  def settings: Settings

  /**
   * Log the configuration.
   */
  def logConfiguration(): Unit

  /**
   * Construct a path below the application guardian to be used with [[ActorSystem#actorSelection]].
   */
  def /(name: String): ActorPath

  /**
   * Java API: Create a new child actor path.
   */
  def child(child: String): ActorPath = /(child)

  /**
   * Construct a path below the application guardian to be used with [[ActorSystem#actorSelection]].
   */
  def /(name: Iterable[String]): ActorPath

  /**
   * Java API: Recursively create a descendant’s path by appending all child names.
   */
  def descendant(names: java.lang.Iterable[String]): ActorPath = /(immutableSeq(names))

  /**
   * Start-up time in milliseconds since the epoch.
   */
  val startTime: Long = System.currentTimeMillis

  /**
   * Up-time of this actor system in seconds.
   */
  def uptime: Long = (System.currentTimeMillis - startTime) / 1000

  /**
   * Main event bus of this actor system, used for example for logging.
   */
  def eventStream: EventStream

  /**
   * Java API: Main event bus of this actor system, used for example for logging.
   */
  def getEventStream: EventStream = eventStream

  /**
   * Convenient logging adapter for logging to the [[ActorSystem#eventStream]].
   */
  def log: LoggingAdapter

  /**
   * Actor reference where messages are re-routed to which were addressed to
   * stopped or non-existing actors. Delivery to this actor is done on a best
   * effort basis and hence not strictly guaranteed.
   */
  def deadLetters: ActorRef

  /**
   * Light-weight scheduler for running asynchronous tasks after some deadline
   * in the future. Not terribly precise but cheap.
   */
  def scheduler: Scheduler

  /**
   * Java API: Light-weight scheduler for running asynchronous tasks after some deadline
   * in the future. Not terribly precise but cheap.
   */
  def getScheduler: Scheduler = scheduler

  /**
   * Helper object for looking up configured dispatchers.
   */
  def dispatchers: Dispatchers

  /**
   * Default dispatcher as configured. This dispatcher is used for all actors
   * in the actor system which do not have a different dispatcher configured
   * explicitly.
   * Importing this member will place the default MessageDispatcher in scope.
   */
  implicit def dispatcher: ExecutionContextExecutor

  /**
   * Java API: Default dispatcher as configured. This dispatcher is used for all actors
   * in the actor system which do not have a different dispatcher configured
   * explicitly.
   * Importing this member will place the default MessageDispatcher in scope.
   */
  def getDispatcher: ExecutionContextExecutor = dispatcher

  /**
   * Helper object for looking up configured mailbox types.
   */
  def mailboxes: Mailboxes

  /**
   * Register a block of code (callback) to run after [[ActorSystem.terminate]] has been issued and
   * all actors in this actor system have been stopped.
   * Multiple code blocks may be registered by calling this method multiple times.
   * The callbacks will be run sequentially in reverse order of registration, i.e.
   * last registration is run first.
   * Note that ActorSystem will not terminate until all the registered callbacks are finished.
   *
   * Throws a RejectedExecutionException if the System has already been terminated or if termination has been initiated.
   *
   * Scala API
   */
  def registerOnTermination[T](code: => T): Unit

  /**
   * Java API: Register a block of code (callback) to run after [[ActorSystem.terminate]] has been issued and
   * all actors in this actor system have been stopped.
   * Multiple code blocks may be registered by calling this method multiple times.
   * The callbacks will be run sequentially in reverse order of registration, i.e.
   * last registration is run first.
   * Note that ActorSystem will not terminate until all the registered callbacks are finished.
   *
   * Throws a RejectedExecutionException if the System has already been terminated or if termination has been initiated.
   */
  def registerOnTermination(code: Runnable): Unit

  /**
   * Terminates this actor system by running [[CoordinatedShutdown]] with reason
   * [[CoordinatedShutdown.ActorSystemTerminateReason]].
   *
   * If `akka.coordinated-shutdown.run-by-actor-system-terminate` is configured to `off`
   * it will not run `CoordinatedShutdown`, but the `ActorSystem` and its actors
   * will still be terminated.
   *
   * This will stop the guardian actor, which in turn
   * will recursively stop all its child actors, and finally the system guardian
   * (below which the logging actors reside) and then execute all registered
   * termination handlers (see [[ActorSystem#registerOnTermination]]).
   * Be careful to not schedule any operations on completion of the returned future
   * using the dispatcher of this actor system as it will have been shut down before the
   * future completes.
   */
  def terminate(): Future[Terminated]

  /**
   * Returns a Future which will be completed after the ActorSystem has been terminated
   * and termination hooks have been executed. If you registered any callback with
   * [[ActorSystem#registerOnTermination]], the returned Future from this method will not complete
   * until all the registered callbacks are finished. Be careful to not schedule any operations,
   * such as `onComplete`, on the dispatchers (`ExecutionContext`) of this actor system as they
   * will have been shut down before this future completes.
   */
  def whenTerminated: Future[Terminated]

  /**
   * Returns a CompletionStage which will be completed after the ActorSystem has been terminated
   * and termination hooks have been executed. If you registered any callback with
   * [[ActorSystem#registerOnTermination]], the returned CompletionStage from this method will not complete
   * until all the registered callbacks are finished. Be careful to not schedule any operations,
   * such as `thenRunAsync`, on the dispatchers (`Executor`) of this actor system as they
   * will have been shut down before this CompletionStage completes.
   */
  def getWhenTerminated: CompletionStage[Terminated]

  /**
   * Registers the provided extension and creates its payload, if this extension isn't already registered
   * This method has putIfAbsent-semantics, this method can potentially block, waiting for the initialization
   * of the payload, if is in the process of registration from another Thread of execution
   */
  def registerExtension[T <: Extension](ext: ExtensionId[T]): T

  /**
   * Returns the payload that is associated with the provided extension
   * throws an IllegalStateException if it is not registered.
   * This method can potentially block, waiting for the initialization
   * of the payload, if is in the process of registration from another Thread of execution
   */
  def extension[T <: Extension](ext: ExtensionId[T]): T

  /**
   * Returns whether the specified extension is already registered, this method can potentially block, waiting for the initialization
   * of the payload, if is in the process of registration from another Thread of execution
   */
  def hasExtension(ext: ExtensionId[_ <: Extension]): Boolean
}

/**
 * More powerful interface to the actor system’s implementation which is presented to extensions (see [[akka.actor.Extension]]).
 *
 * <b><i>Important Notice:</i></b>
 *
 * This class is not meant to be extended by user code. If you want to
 * actually roll your own Akka, beware that you are completely on your own in
 * that case!
 */
@DoNotInherit
abstract class ExtendedActorSystem extends ActorSystem {

  /**
   * The ActorRefProvider is the only entity which creates all actor references within this actor system.
   */
  def provider: ActorRefProvider

  /**
   * The top-level supervisor of all actors created using system.actorOf(...).
   */
  def guardian: InternalActorRef

  /**
   * The top-level supervisor of all system-internal services like logging.
   */
  def systemGuardian: InternalActorRef

  /**
   * Create an actor in the "/system" namespace. This actor will be shut down
   * during system.terminate only after all user actors have terminated.
   *
   * This is only intended to be used by libraries (and Akka itself).
   * Applications should use ordinary `actorOf`.
   */
  def systemActorOf(props: Props, name: String): ActorRef

  /**
   * A ThreadFactory that can be used if the transport needs to create any Threads
   */
  def threadFactory: ThreadFactory

  /**
   * ClassLoader wrapper which is used for reflective accesses internally. This is set
   * to use the context class loader, if one is set, or the class loader which
   * loaded the ActorSystem implementation. The context class loader is also
   * set on all threads created by the ActorSystem, if one was set during
   * creation.
   */
  def dynamicAccess: DynamicAccess

  /**
   * Filter of log events that is used by the LoggingAdapter before
   * publishing log events to the eventStream
   */
  def logFilter: LoggingFilter

  /**
   * For debugging: traverse actor hierarchy and make string representation.
   * Careful, this may OOM on large actor systems, and it is only meant for
   * helping debugging in case something already went terminally wrong.
   */
  private[akka] def printTree: String

  /**
   * INTERNAL API: final step of `terminate()`
   */
  @InternalApi private[akka] def finalTerminate(): Unit

  /**
   * INTERNAL API
   */
  @InternalApi private[akka] def isTerminating(): Boolean

}

/**
 * Internal API
 */
@InternalApi
private[akka] class ActorSystemImpl(
    val name: String,
    applicationConfig: Config,
    classLoader: ClassLoader,
    defaultExecutionContext: Option[ExecutionContext],
    val guardianProps: Option[Props],
    setup: ActorSystemSetup)
    extends ExtendedActorSystem {

  if (!name.matches("""^[a-zA-Z0-9][a-zA-Z0-9-_]*$"""))
    throw new IllegalArgumentException(
      "invalid ActorSystem name [" + name +
      "], must contain only word characters (i.e. [a-zA-Z0-9] plus non-leading '-' or '_')")

  import ActorSystem._

  @volatile private var logDeadLetterListener: Option[ActorRef] = None

  private val _dynamicAccess: DynamicAccess = createDynamicAccess()

  final val settings: Settings = {
    val config = Settings.amendSlf4jConfig(
      applicationConfig.withFallback(ConfigFactory.defaultReference(classLoader)),
      _dynamicAccess)
    new Settings(classLoader, config, name, setup)
  }

  protected def uncaughtExceptionHandler: Thread.UncaughtExceptionHandler =
    new Thread.UncaughtExceptionHandler() {
      def uncaughtException(thread: Thread, cause: Throwable): Unit = {
        cause match {
          case NonFatal(_) | _: InterruptedException | _: NotImplementedError | _: ControlThrowable =>
            log.error(cause, "Uncaught error from thread [{}]", thread.getName)
          case _ =>
            if (cause.isInstanceOf[IncompatibleClassChangeError] && cause.getMessage.startsWith("akka"))
              System.err.println(
                s"""Detected ${cause.getClass.getName} error, which MAY be caused by incompatible Akka versions on the classpath.
                  | Please note that a given Akka version MUST be the same across all modules of Akka that you are using,
                  | e.g. if you use akka-actor [${akka.Version.current} (resolved from current classpath)] all other core
                  | Akka modules MUST be of the same version. External projects like Alpakka, Persistence plugins or Akka
                  | HTTP etc. have their own version numbers - please make sure you're using a compatible set of libraries.
                 """.stripMargin.replaceAll("[\r\n]", ""))

            if (settings.JvmExitOnFatalError)
              try logFatalError("shutting down JVM since 'akka.jvm-exit-on-fatal-error' is enabled for", cause, thread)
              finally System.exit(-1)
            else
              try logFatalError("shutting down", cause, thread)
              finally terminate()
        }
      }

      @inline
      private def logFatalError(message: String, cause: Throwable, thread: Thread): Unit = {
        // First log to stderr as this has the best chance to get through in an 'emergency panic' situation:
        import System.err
        err.print("Uncaught error from thread [")
        err.print(thread.getName)
        err.print("]: ")
        err.print(cause.getMessage)
        err.print(", ")
        err.print(message)
        err.print(" ActorSystem[")
        err.print(name)
        err.println("]")
        System.err.flush()
        cause.printStackTrace(System.err)
        System.err.flush()

        // Also log using the normal infrastructure - hope for the best:
        markerLogging.error(
          LogMarker.Security,
          cause,
          "Uncaught error from thread [{}]: " + cause.getMessage + ", " + message + " ActorSystem[{}]",
          thread.getName,
          name)
      }
    }

  final val threadFactory: MonitorableThreadFactory =
    MonitorableThreadFactory(name, settings.Daemonicity, Option(classLoader), uncaughtExceptionHandler)

  /**
   * This is an extension point: by overriding this method, subclasses can
   * control all reflection activities of an actor system.
   */
  protected def createDynamicAccess(): DynamicAccess = new ReflectiveDynamicAccess(classLoader)

  def dynamicAccess: DynamicAccess = _dynamicAccess

  def logConfiguration(): Unit = log.info(settings.toString)

  protected def systemImpl: ActorSystemImpl = this

  def systemActorOf(props: Props, name: String): ActorRef =
    systemGuardian.underlying.attachChild(props, name, systemService = true)

  def actorOf(props: Props, name: String): ActorRef =
    if (guardianProps.isEmpty) guardian.underlying.attachChild(props, name, systemService = false)
    else
      throw new UnsupportedOperationException(
        s"cannot create top-level actor [$name] from the outside on ActorSystem with custom user guardian")

  def actorOf(props: Props): ActorRef =
    if (guardianProps.isEmpty) guardian.underlying.attachChild(props, systemService = false)
    else
      throw new UnsupportedOperationException(
        "cannot create top-level actor from the outside on ActorSystem with custom user guardian")

  def stop(actor: ActorRef): Unit = {
    val path = actor.path
    val guard = guardian.path
    val sys = systemGuardian.path
    path.parent match {
      case `guard` => guardian ! StopChild(actor)
      case `sys`   => systemGuardian ! StopChild(actor)
      case _       => actor.asInstanceOf[InternalActorRef].stop()
    }
  }

  import settings._

  // this provides basic logging (to stdout) until .start() is called below
  val eventStream = new EventStream(this, DebugEventStream)
  eventStream.startStdoutLogger(settings)

  val logFilter: LoggingFilter = {
    val arguments = Vector(classOf[Settings] -> settings, classOf[EventStream] -> eventStream)
    dynamicAccess.createInstanceFor[LoggingFilter](LoggingFilter, arguments).get
  }

  private[this] val markerLogging =
    new MarkerLoggingAdapter(eventStream, getClass.getName + "(" + name + ")", this.getClass, logFilter)
  val log: LoggingAdapter = markerLogging

  val scheduler: Scheduler = createScheduler()

  val provider: ActorRefProvider = try {
    val arguments = Vector(
      classOf[String] -> name,
      classOf[Settings] -> settings,
      classOf[EventStream] -> eventStream,
      classOf[DynamicAccess] -> dynamicAccess)

    dynamicAccess.createInstanceFor[ActorRefProvider](ProviderClass, arguments).get
  } catch {
    case NonFatal(e) =>
      Try(stopScheduler())
      throw e
  }

  def deadLetters: ActorRef = provider.deadLetters

  val mailboxes: Mailboxes = new Mailboxes(settings, eventStream, dynamicAccess, deadLetters)

  val dispatchers: Dispatchers = new Dispatchers(
    settings,
    DefaultDispatcherPrerequisites(
      threadFactory,
      eventStream,
      scheduler,
      dynamicAccess,
      settings,
      mailboxes,
      defaultExecutionContext),
    log)

  val dispatcher: ExecutionContextExecutor = dispatchers.defaultGlobalDispatcher

  private[this] final val terminationCallbacks = new TerminationCallbacks(provider.terminationFuture)(dispatcher)

  override def whenTerminated: Future[Terminated] = terminationCallbacks.terminationFuture
  override def getWhenTerminated: CompletionStage[Terminated] = FutureConverters.toJava(whenTerminated)
  def lookupRoot: InternalActorRef = provider.rootGuardian
  def guardian: LocalActorRef = provider.guardian
  def systemGuardian: LocalActorRef = provider.systemGuardian

  def /(actorName: String): ActorPath = guardian.path / actorName
  def /(path: Iterable[String]): ActorPath = guardian.path / path

  override def classicSystem: ActorSystem = this

  // Used for ManifestInfo.checkSameVersion
  private def allModules: List[String] =
    List(
      "akka-actor",
      "akka-actor-testkit-typed",
      "akka-actor-typed",
      "akka-cluster",
      "akka-cluster-metrics",
      "akka-cluster-sharding",
      "akka-cluster-sharding-typed",
      "akka-cluster-tools",
      "akka-cluster-typed",
      "akka-coordination",
      "akka-discovery",
      "akka-distributed-data",
      "akka-testkit",
      "akka-multi-node-testkit",
      "akka-osgi",
      "akka-persistence",
      "akka-persistence-query",
      "akka-persistence-shared",
      "akka-persistence-testkit",
      "akka-persistence-typed",
      "akka-pki",
      "akka-protobuf",
      "akka-protobuf-v3",
      "akka-remote",
      "akka-serialization-jackson",
      "akka-slf4j",
      "akka-stream",
      "akka-stream-testkit",
      "akka-stream-typed",
      "akka-stream-testkit")

  @volatile private var _initialized = false

  /**
   *  Asserts that the ActorSystem has been fully initialized. Can be used to guard code blocks that might accidentally
   *  be run during initialization but require a fully initialized ActorSystem before proceeding.
   */
  def assertInitialized(): Unit =
    if (!_initialized)
      throw new IllegalStateException(
        "The calling code expected that the ActorSystem was initialized but it wasn't yet. " +
        "This is probably a bug in the ActorSystem initialization sequence often related to initialization of extensions. " +
        "Please report at https://github.com/akka/akka/issues.")
  private lazy val _start: this.type = try {

    registerOnTermination(stopScheduler())
    // the provider is expected to start default loggers, LocalActorRefProvider does this
    provider.init(this)
    // at this point it should be initialized "enough" for most extensions that we might want to guard against otherwise
    _initialized = true

    if (settings.LogDeadLetters > 0)
      logDeadLetterListener = Some(systemActorOf(Props[DeadLetterListener](), "deadLetterListener"))
    eventStream.startUnsubscriber()
    ManifestInfo(this).checkSameVersion("Akka", allModules, logWarning = true)
    if (!terminating)
      loadExtensions()
    if (LogConfigOnStart) logConfiguration()
    this
  } catch {
    case NonFatal(e) =>
      try terminate()
      catch { case NonFatal(_) => Try(stopScheduler()) }
      throw e
  }

  def start(): this.type = _start
  def registerOnTermination[T](code: => T): Unit = { registerOnTermination(new Runnable { def run = code }) }
  def registerOnTermination(code: Runnable): Unit = { terminationCallbacks.add(code) }

  @volatile private var terminating = false

  override def terminate(): Future[Terminated] = {
    terminating = true
    if (settings.CoordinatedShutdownRunByActorSystemTerminate && !aborting) {
      // Note that the combination CoordinatedShutdownRunByActorSystemTerminate==true &&
      // CoordinatedShutdownTerminateActorSystem==false is disallowed, checked in Settings.
      // It's not a combination that is valuable to support and it would be complicated to
      // protect against concurrency race conditions between calls to ActorSystem.terminate()
      // and CoordinateShutdown.run()

      // it will call finalTerminate() at the end
      CoordinatedShutdown(this).run(CoordinatedShutdown.ActorSystemTerminateReason)
    } else {
      finalTerminate()
    }
    whenTerminated
  }

  override private[akka] def finalTerminate(): Unit = {
    terminating = true
    // these actions are idempotent
    if (!settings.LogDeadLettersDuringShutdown) logDeadLetterListener.foreach(stop)
    guardian.stop()
  }

  override private[akka] def isTerminating(): Boolean = {
    terminating || aborting || CoordinatedShutdown(this).shutdownReason().isDefined
  }

  @volatile var aborting = false

  /**
   * This kind of shutdown attempts to bring the system down and release its
   * resources more forcefully than plain shutdown. For example it will not
   * run CoordinatedShutdown and not wait for remote-deployed child actors to
   * terminate before terminating their parents.
   */
  def abort(): Unit = {
    aborting = true
    terminate()
  }

  //#create-scheduler
  /**
   * Create the scheduler service. This one needs one special behavior: if
   * Closeable, it MUST execute all outstanding tasks upon .close() in order
   * to properly shutdown all dispatchers.
   *
   * Furthermore, this timer service MUST throw IllegalStateException if it
   * cannot schedule a task. Once scheduled, the task MUST be executed. If
   * executed upon close(), the task may execute before its timeout.
   */
  protected def createScheduler(): Scheduler =
    dynamicAccess
      .createInstanceFor[Scheduler](
        settings.SchedulerClass,
        immutable.Seq(
          classOf[Config] -> settings.config,
          classOf[LoggingAdapter] -> log,
          classOf[ThreadFactory] -> threadFactory.withName(threadFactory.name + "-scheduler")))
      .get
  //#create-scheduler

  /*
   * This is called after the last actor has signaled its termination, i.e.
   * after the last dispatcher has had its chance to schedule its shutdown
   * action.
   */
  protected def stopScheduler(): Unit = scheduler match {
    case x: Closeable => x.close()
    case _            =>
  }

  // For each ExtensionId, either:
  // 1) a CountDownLatch (if it's still in the process of being registered),
  // 2) a Throwable (if it failed initializing), or
  // 3) the registered extension.
  private val extensions = new ConcurrentHashMap[ExtensionId[_], AnyRef]

  /**
   * Returns any extension registered to the specified Extension or returns null if not registered
   */
  @tailrec
  private def findExtension[T <: Extension](ext: ExtensionId[T]): T = extensions.get(ext) match {
    case c: CountDownLatch =>
      blocking {
        val awaitMillis = settings.CreationTimeout.duration.toMillis
        if (!c.await(awaitMillis, TimeUnit.MILLISECONDS))
          throw new IllegalStateException(
            s"Initialization of [$ext] took more than [$awaitMillis ms]. " +
            (if (ext == SerializationExtension)
               "A serializer must not access the SerializationExtension from its constructor. Use lazy init."
             else "Could be deadlock due to cyclic initialization of extensions."))
      }
      findExtension(ext) //Registration in process, await completion and retry
    case t: Throwable => throw t //Initialization failed, throw same again
    case other =>
      other.asInstanceOf[T] //could be a T or null, in which case we return the null as T
  }

  @tailrec
  final def registerExtension[T <: Extension](ext: ExtensionId[T]): T = {
    findExtension(ext) match {
      case null => //Doesn't already exist, commence registration
        val inProcessOfRegistration = new CountDownLatch(1)
        extensions.putIfAbsent(ext, inProcessOfRegistration) match { // Signal that registration is in process
          case null =>
            try { // Signal was successfully sent
              ext.createExtension(this) match { // Create and initialize the extension
                case null =>
                  throw new IllegalStateException(s"Extension instance created as 'null' for extension [$ext]")
                case instance =>
                  extensions.replace(ext, inProcessOfRegistration, instance) //Replace our in process signal with the initialized extension
                  instance //Profit!
              }
            } catch {
              case t: Throwable =>
                extensions.replace(ext, inProcessOfRegistration, t) //In case shit hits the fan, remove the inProcess signal
                throw t //Escalate to caller
            } finally {
              inProcessOfRegistration.countDown() //Always notify listeners of the inProcess signal
            }
          case _ =>
            registerExtension(ext) //Someone else is in process of registering an extension for this Extension, retry
        }
      case existing => existing.asInstanceOf[T]
    }
  }

  def extension[T <: Extension](ext: ExtensionId[T]): T = findExtension(ext) match {
    case null => throw new IllegalArgumentException(s"Trying to get non-registered extension [$ext]")
    case some => some.asInstanceOf[T]
  }

  def hasExtension(ext: ExtensionId[_ <: Extension]): Boolean = findExtension(ext) != null

  private def loadExtensions(): Unit = {

    /*
     * @param throwOnLoadFail
     *  Throw exception when an extension fails to load (needed for backwards compatibility.
     *    when the extension cannot be found at all we throw regardless of this setting)
     */
    def loadExtensions(key: String, throwOnLoadFail: Boolean): Unit = {

      immutableSeq(settings.config.getStringList(key)).foreach { fqcn =>
        dynamicAccess.getObjectFor[AnyRef](fqcn).recoverWith {
          case firstProblem =>
            dynamicAccess.createInstanceFor[AnyRef](fqcn, Nil).recoverWith { case _ => Failure(firstProblem) }
        } match {
          case Success(p: ExtensionIdProvider) =>
            registerExtension(p.lookup)
          case Success(p: ExtensionId[_]) =>
            registerExtension(p)
          case Success(_) =>
            if (!throwOnLoadFail) log.error("[{}] is not an 'ExtensionIdProvider' or 'ExtensionId', skipping...", fqcn)
            else throw new RuntimeException(s"[$fqcn] is not an 'ExtensionIdProvider' or 'ExtensionId'")
          case Failure(problem) =>
            if (!throwOnLoadFail) log.error(problem, "While trying to load extension [{}], skipping...", fqcn)
            else throw new RuntimeException(s"While trying to load extension [$fqcn]", problem)
        }
      }
    }

    loadExtensions("akka.library-extensions", throwOnLoadFail = true)
    loadExtensions("akka.extensions", throwOnLoadFail = false)
  }

  override def toString: String = lookupRoot.path.root.address.toString

  override def printTree: String = {
    def printNode(node: ActorRef, indent: String): String = {
      node match {
        case wc: ActorRefWithCell =>
          val cell = wc.underlying
          (if (indent.isEmpty) "-> " else indent.dropRight(1) + "⌊-> ") +
          node.path.name + " " + Logging.simpleName(node) + " " +
          (cell match {
            case real: ActorCell =>
              val realActor = real.actor
              if (realActor ne null) realActor.getClass else "null"
            case _ => Logging.simpleName(cell)
          }) +
          (cell match {
            case real: ActorCell => " status=" + real.mailbox.currentStatus
            case _               => ""
          }) +
          " " + (cell.childrenRefs match {
            case ChildrenContainer.TerminatingChildrenContainer(_, toDie, reason) =>
              "Terminating(" + reason + ")" +
              (toDie.toSeq.sorted.mkString("\n" + indent + "   |    toDie: ", "\n" + indent + "   |           ", ""))
            case x @ (ChildrenContainer.TerminatedChildrenContainer | ChildrenContainer.EmptyChildrenContainer) =>
              x.toString
            case n: ChildrenContainer.NormalChildrenContainer => n.c.size.toString + " children"
            case x                                            => Logging.simpleName(x)
          }) +
          (if (cell.childrenRefs.children.isEmpty) "" else "\n") +
          ({
            val children = cell.childrenRefs.children.toSeq.sorted
            val bulk = children.dropRight(1).map(printNode(_, indent + "   |"))
            bulk ++ (children.lastOption.map(printNode(_, indent + "    ")))
          }.mkString("\n"))
        case _ =>
          indent + node.path.name + " " + Logging.simpleName(node)
      }
    }
    printNode(lookupRoot, "")
  }

  final class TerminationCallbacks[T](upStreamTerminated: Future[T])(implicit ec: ExecutionContext) {
    private[this] final val done = Promise[T]()
    private[this] final val ref = new AtomicReference(done)

    // onComplete never fires twice so safe to avoid null check
    upStreamTerminated.onComplete { t =>
      ref.getAndSet(null).complete(t)
    }

    /**
     * Adds a Runnable that will be executed on ActorSystem termination.
     * Note that callbacks are executed in reverse order of insertion.
     *
     * @param r The callback to be executed on ActorSystem termination
     * Throws RejectedExecutionException if called after ActorSystem has been terminated.
     */
    final def add(r: Runnable): Unit = {
      @tailrec def addRec(r: Runnable, p: Promise[T]): Unit = ref.get match {
        case null                               => throw new RejectedExecutionException("ActorSystem already terminated.")
        case some if ref.compareAndSet(some, p) => some.completeWith(p.future.andThen { case _ => r.run() })
        case _                                  => addRec(r, p)
      }
      addRec(r, Promise[T]())
    }

    /**
     * Returns a Future which will be completed once all registered callbacks have been executed.
     */
    def terminationFuture: Future[T] = done.future
  }
}

[0m2021.03.30 00:19:08 INFO  shutting down Metals[0m
[0m2021.03.30 00:19:09 INFO  Shut down connection with build server.[0m
[0m2021.03.30 00:19:09 INFO  Shut down connection with build server.[0m
[0m2021.03.30 00:19:09 INFO  Shut down connection with build server.[0m
No more data in the client stdin, exiting...
No more data in the client stdin, exiting...
No more data in the client stdin, exiting...
No more data in the server stdin, exiting...
No more data in the server stdin, exiting...
No more data in the server stdin, exiting...
No more data in the server stdin, exiting...
No more data in the server stdin, exiting...
No more data in the server stdin, exiting...
[0m2021.03.30 20:14:15 INFO  Started: Metals version 0.10.0 in workspace '/Users/davidashley/Documents/Scala/scalabackend/scalabackend' for client vscode 1.54.3.[0m
[0m2021.03.30 20:14:15 INFO  time: initialize in 0.41s[0m
[0m2021.03.30 20:14:16 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
[0m2021.03.30 20:14:15 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/HomeController.scala[0m
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher3025958990840334887/bsp.socket'...
Waiting for the bsp connection to come up...
[0m2021.03.30 20:14:15 INFO  skipping build import with status 'Installed'[0m
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
[0m2021.03.30 20:14:19 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
No server running at 127.0.0.1:8212, let's fire one...
Resolving ch.epfl.scala:bloop-frontend_2.12:1.4.8...
Starting bloop server at 127.0.0.1:8212...
Attempting a connection to the server...
Attempting a connection to the server...
Attempting a connection to the server...
Attempting a connection to the server...
Attempting a connection to the server...
Attempting a connection to the server...
Attempting a connection to the server...
Attempting a connection to the server...
Attempting a connection to the server...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Loading 2 projects from '/Users/davidashley/Documents/Scala/scalabackend/scalabackend/.bloop'...
[0m[32m[D][0m Loading project from '/Users/davidashley/Documents/Scala/scalabackend/scalabackend/.bloop/root-test.json'
[0m[32m[D][0m Loading project from '/Users/davidashley/Documents/Scala/scalabackend/scalabackend/.bloop/root.json'
[0m[32m[D][0m Cache miss for scala instance org.scala-lang:scala-compiler:2.13.3.
[0m[32m[D][0m   => /Users/davidashley/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/java/dev/jna/jna/5.3.1/jna-5.3.1.jar
[0m[32m[D][0m   => /Users/davidashley/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/jline/jline/3.15.0/jline-3.15.0.jar
[0m[32m[D][0m   => /Users/davidashley/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-compiler/2.13.3/scala-compiler-2.13.3.jar
[0m[32m[D][0m   => /Users/davidashley/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.3/scala-library-2.13.3.jar
[0m[32m[D][0m   => /Users/davidashley/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-reflect/2.13.3/scala-reflect-2.13.3.jar
[0m[32m[D][0m Configured SemanticDB in projects 'root-test', 'root'
[0m[32m[D][0m Loading previous analysis for 'root-test' from '/Users/davidashley/Documents/Scala/scalabackend/scalabackend/target/streams/test/bloopAnalysisOut/_global/streams/inc_compile_2.13.zip'.
[0m[32m[D][0m Loading previous analysis for 'root' from '/Users/davidashley/Documents/Scala/scalabackend/scalabackend/target/streams/compile/bloopAnalysisOut/_global/streams/inc_compile_2.13.zip'.
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher3025958990840334887/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher3025958990840334887/bsp.socket...
package controllers

import javax.inject._
import play.api._
import play.api.mvc._
import _root_.db.ScalaApplicationDatabase

/** This controller creates an `Action` to handle HTTP requests to the
  * application's home page.
  */
@Singleton
class HomeController @Inject() (
    val controllerComponents: ControllerComponents,
    val db: ScalaApplicationDatabase
) extends BaseController {

  /** Create an Action to render an HTML page.
    *
    * The configuration in the `routes` file means that this method
    * will be called when the application receives a `GET` request with
    * a path of `/`.
    */
  def index() = Action { implicit request: Request[AnyContent] =>
    println("hit index")
    db.updateSomething()
    Ok(views.html.index())
  }
}

Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.30 20:14:21 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.03.30 20:14:22 INFO  time: code lens generation in 5.89s[0m
[0m2021.03.30 20:14:21 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
[0m2021.03.30 20:14:21 INFO Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher242340135951741881/bsp.socket'... 
Attempting to connect to the build server...[0m
Waiting for the bsp connection to come up...
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher7842216442256911129/bsp.socket'...
Waiting for the bsp connection to come up...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher7842216442256911129/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher7842216442256911129/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.30 20:14:22 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher242340135951741881/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher242340135951741881/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.30 20:14:22 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.03.30 20:14:22 INFO  time: Connected to build server in 6.23s[0m
[0m2021.03.30 20:14:22 INFO  Connected to Build server: Bloop v1.4.8[0m
[0m2021.03.30 20:14:22 INFO  time: Imported build in 0.17s[0m
[0m2021.03.30 20:14:26 INFO  time: indexed workspace in 3.52s[0m
[0m2021.03.30 20:14:27 INFO  compiling root (9 scala sources and 1 java source)[0m
[0m2021.03.30 20:14:40 INFO  compiling root-test (1 scala source)[0m
[0m2021.03.30 20:14:40 INFO  time: compiled root in 13s[0m
[0m2021.03.30 20:14:40 INFO  time: compiled root-test in 0.72s[0m
Mar 30, 2021 8:22:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13
[0m2021.03.30 20:23:00 INFO  compiling root-test (1 scala source)[0m
[0m2021.03.30 20:23:00 INFO  time: compiled root-test in 0.52s[0m
[0m2021.03.30 20:23:48 INFO  compiling root-test (1 scala source)[0m
[0m2021.03.30 20:23:48 INFO  time: compiled root-test in 0.44s[0m
[0m2021.03.30 20:23:48 INFO  compiling root (1 scala source)[0m
[0m2021.03.30 20:23:50 INFO  time: compiled root in 1.5s[0m
/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

// DO NOT EDIT, CHANGES WILL BE LOST
// This auto-generated code can be modified in "project/GenerateAnyVals.scala".
// Afterwards, running "sbt generateSources" regenerates this source file.

package scala


/** `Unit` is a subtype of [[scala.AnyVal]]. There is only one value of type
 *  `Unit`, `()`, and it is not represented by any object in the underlying
 *  runtime system. A method with return type `Unit` is analogous to a Java
 *  method which is declared `void`.
 */
final abstract class Unit private extends AnyVal {
  // Provide a more specific return type for Scaladoc
  override def getClass(): Class[Unit] = ???
}

object Unit extends AnyValCompanion {

  /** Transform a value type into a boxed reference type.
   *
   *  @param  x   the Unit to be boxed
   *  @return     a scala.runtime.BoxedUnit offering `x` as its underlying value.
   */
  def box(x: Unit): scala.runtime.BoxedUnit = scala.runtime.BoxedUnit.UNIT

  /** Transform a boxed type into a value type.  Note that this
   *  method is not typesafe: it accepts any Object, but will throw
   *  an exception if the argument is not a scala.runtime.BoxedUnit.
   *
   *  @param  x   the scala.runtime.BoxedUnit to be unboxed.
   *  @throws     ClassCastException  if the argument is not a scala.runtime.BoxedUnit
   *  @return     the Unit value ()
   */
  def unbox(x: java.lang.Object): Unit = x.asInstanceOf[scala.runtime.BoxedUnit]

  /** The String representation of the scala.Unit companion object. */
  override def toString = "object scala.Unit"
}


[0m2021.03.30 20:24:49 INFO  compiling root-test (1 scala source)[0m
[0m2021.03.30 20:24:49 INFO  time: compiled root-test in 0.38s[0m
[0m2021.03.30 20:25:04 INFO  compiling root (1 scala source)[0m
[0m2021.03.30 20:25:04 INFO  time: compiled root in 0.78s[0m
[0m2021.03.30 20:25:10 INFO  compiling root (1 scala source)[0m
[0m2021.03.30 20:25:10 INFO  time: compiled root in 0.93s[0m
/*
 * Copyright (C) 2009-2020 Lightbend Inc. <https://www.lightbend.com>
 */

package akka.actor

import java.io.Closeable
import java.util.Optional
import java.util.concurrent._
import java.util.concurrent.atomic.AtomicReference

import scala.annotation.tailrec
import scala.collection.immutable
import scala.compat.java8.FutureConverters
import scala.compat.java8.OptionConverters._
import scala.concurrent.{ ExecutionContext, ExecutionContextExecutor, Future, Promise }
import scala.concurrent.blocking
import scala.concurrent.duration.Duration
import scala.util.{ Failure, Success, Try }
import scala.util.control.{ ControlThrowable, NonFatal }

import com.typesafe.config.{ Config, ConfigFactory }

import akka.ConfigurationException
import akka.actor.dungeon.ChildrenContainer
import akka.actor.setup.{ ActorSystemSetup, Setup }
import akka.annotation.DoNotInherit
import akka.annotation.InternalApi
import akka.dispatch._
import akka.event._
import akka.event.Logging.DefaultLogger
import akka.japi.Util.immutableSeq
import akka.serialization.SerializationExtension
import akka.util._
import akka.util.Helpers.toRootLowerCase

object BootstrapSetup {

  /**
   * Scala API: Construct a bootstrap settings with default values. Note that passing that to the actor system is the
   * same as not passing any [[BootstrapSetup]] at all. You can use the returned instance to derive
   * one that has other values than defaults using the various `with`-methods.
   */
  def apply(): BootstrapSetup = {
    new BootstrapSetup()
  }

  /**
   * Scala API: Create bootstrap settings needed for starting the actor system
   *
   * @see [[BootstrapSetup]] for description of the properties
   */
  def apply(
      classLoader: Option[ClassLoader],
      config: Option[Config],
      defaultExecutionContext: Option[ExecutionContext]): BootstrapSetup =
    new BootstrapSetup(classLoader, config, defaultExecutionContext)

  /**
   * Scala API: Short for using custom config but keeping default classloader and default execution context
   */
  def apply(config: Config): BootstrapSetup = apply(None, Some(config), None)

  /**
   * Java API: Create bootstrap settings needed for starting the actor system
   *
   * @see [[BootstrapSetup]] for description of the properties
   */
  def create(
      classLoader: Optional[ClassLoader],
      config: Optional[Config],
      defaultExecutionContext: Optional[ExecutionContext]): BootstrapSetup =
    apply(classLoader.asScala, config.asScala, defaultExecutionContext.asScala)

  /**
   * Java  API: Short for using custom config but keeping default classloader and default execution context
   */
  def create(config: Config): BootstrapSetup = apply(config)

  /**
   * Java API: Construct a bootstrap settings with default values. Note that passing that to the actor system is the
   * same as not passing any [[BootstrapSetup]] at all. You can use the returned instance to derive
   * one that has other values than defaults using the various `with`-methods.
   */
  def create(): BootstrapSetup = {
    new BootstrapSetup()
  }

}

/**
 * @param identifier the simple name of the selected provider
 * @param fqcn the fully-qualified class name of the selected provider
 */
abstract class ProviderSelection private (
    private[akka] val identifier: String,
    private[akka] val fqcn: String,
    private[akka] val hasCluster: Boolean)
object ProviderSelection {
  private[akka] val RemoteActorRefProvider = "akka.remote.RemoteActorRefProvider"
  private[akka] val ClusterActorRefProvider = "akka.cluster.ClusterActorRefProvider"

  case object Local extends ProviderSelection("local", classOf[LocalActorRefProvider].getName, hasCluster = false)
  // these two cannot be referenced by class as they may not be on the classpath
  case object Remote extends ProviderSelection("remote", RemoteActorRefProvider, hasCluster = false)
  case object Cluster extends ProviderSelection("cluster", ClusterActorRefProvider, hasCluster = true)
  final case class Custom(override val fqcn: String) extends ProviderSelection("custom", fqcn, hasCluster = false)

  /**
   * JAVA API
   */
  def local(): ProviderSelection = Local

  /**
   * JAVA API
   */
  def remote(): ProviderSelection = Remote

  /**
   * JAVA API
   */
  def cluster(): ProviderSelection = Cluster

  /** INTERNAL API */
  @InternalApi private[akka] def apply(providerClass: String): ProviderSelection =
    providerClass match {
      case "local" => Local
      // additional fqcn for older configs not using 'remote' or 'cluster'
      case "remote" | RemoteActorRefProvider   => Remote
      case "cluster" | ClusterActorRefProvider => Cluster
      case fqcn                                => Custom(fqcn)
    }
}

/**
 * Core bootstrap settings of the actor system, create using one of the factories in [[BootstrapSetup]],
 * constructor is *Internal API*.
 *
 * @param classLoader If no ClassLoader is given, it obtains the current ClassLoader by first inspecting the current
 *                    threads' getContextClassLoader, then tries to walk the stack to find the callers class loader, then
 *                    falls back to the ClassLoader associated with the ActorSystem class.
 * @param config Configuration to use for the actor system. If no Config is given, the default reference config will be obtained from the ClassLoader.
 * @param defaultExecutionContext If defined the ExecutionContext will be used as the default executor inside this ActorSystem.
 *                                If no ExecutionContext is given, the system will fallback to the executor configured under
 *                                "akka.actor.default-dispatcher.default-executor.fallback".
 * @param actorRefProvider Overrides the `akka.actor.provider` setting in config, can be `local` (default), `remote` or
 *                         `cluster`. It can also be a fully qualified class name of a provider.
 */
final class BootstrapSetup private (
    val classLoader: Option[ClassLoader] = None,
    val config: Option[Config] = None,
    val defaultExecutionContext: Option[ExecutionContext] = None,
    val actorRefProvider: Option[ProviderSelection] = None)
    extends Setup {

  def withClassloader(classLoader: ClassLoader): BootstrapSetup =
    new BootstrapSetup(Some(classLoader), config, defaultExecutionContext, actorRefProvider)

  def withConfig(config: Config): BootstrapSetup =
    new BootstrapSetup(classLoader, Some(config), defaultExecutionContext, actorRefProvider)

  def withDefaultExecutionContext(executionContext: ExecutionContext): BootstrapSetup =
    new BootstrapSetup(classLoader, config, Some(executionContext), actorRefProvider)

  def withActorRefProvider(name: ProviderSelection): BootstrapSetup =
    new BootstrapSetup(classLoader, config, defaultExecutionContext, Some(name))

}

object ActorSystem {

  val Version: String = akka.Version.current // generated file

  /**
   * Creates a new ActorSystem with the name "default",
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def create(): ActorSystem = apply()

  /**
   * Creates a new ActorSystem with the specified name,
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def create(name: String): ActorSystem = apply(name)

  /**
   * Java API: Creates a new actor system with the specified name and settings
   * The core actor system settings are defined in [[BootstrapSetup]]
   */
  def create(name: String, setups: ActorSystemSetup): ActorSystem = apply(name, setups)

  /**
   * Java API: Shortcut for creating an actor system with custom bootstrap settings.
   * Same behavior as calling `ActorSystem.create(name, ActorSystemSetup.create(bootstrapSettings))`
   */
  def create(name: String, bootstrapSetup: BootstrapSetup): ActorSystem =
    create(name, ActorSystemSetup.create(bootstrapSetup))

  /**
   * Creates a new ActorSystem with the specified name, and the specified Config, then
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def create(name: String, config: Config): ActorSystem = apply(name, config)

  /**
   * Creates a new ActorSystem with the specified name, the specified Config, and specified ClassLoader
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def create(name: String, config: Config, classLoader: ClassLoader): ActorSystem = apply(name, config, classLoader)

  /**
   * Creates a new ActorSystem with the specified name, the specified Config, the specified ClassLoader,
   * and the specified ExecutionContext. The ExecutionContext will be used as the default executor inside this ActorSystem.
   * If `null` is passed in for the Config, ClassLoader and/or ExecutionContext parameters, the respective default value
   * will be used. If no Config is given, the default reference config will be obtained from the ClassLoader.
   * If no ClassLoader is given, it obtains the current ClassLoader by first inspecting the current
   * threads' getContextClassLoader, then tries to walk the stack to find the callers class loader, then
   * falls back to the ClassLoader associated with the ActorSystem class. If no ExecutionContext is given, the
   * system will fallback to the executor configured under "akka.actor.default-dispatcher.default-executor.fallback".
   * Note that the given ExecutionContext will be used by all dispatchers that have been configured with
   * executor = "default-executor", including those that have not defined the executor setting and thereby fallback
   * to the default of "default-dispatcher.executor".
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def create(
      name: String,
      config: Config,
      classLoader: ClassLoader,
      defaultExecutionContext: ExecutionContext): ActorSystem =
    apply(name, Option(config), Option(classLoader), Option(defaultExecutionContext))

  /**
   * Creates a new ActorSystem with the name "default",
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def apply(): ActorSystem = apply("default")

  /**
   * Creates a new ActorSystem with the specified name,
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def apply(name: String): ActorSystem = apply(name, None, None, None)

  /**
   * Scala API: Creates a new actor system with the specified name and settings
   * The core actor system settings are defined in [[BootstrapSetup]]
   */
  def apply(name: String, setup: ActorSystemSetup): ActorSystem = {
    val bootstrapSettings = setup.get[BootstrapSetup]
    val cl = bootstrapSettings.flatMap(_.classLoader).getOrElse(findClassLoader())
    val appConfig = bootstrapSettings.flatMap(_.config).getOrElse(ConfigFactory.load(cl))
    val defaultEC = bootstrapSettings.flatMap(_.defaultExecutionContext)

    new ActorSystemImpl(name, appConfig, cl, defaultEC, None, setup).start()
  }

  /**
   * Scala API: Shortcut for creating an actor system with custom bootstrap settings.
   * Same behavior as calling `ActorSystem(name, ActorSystemSetup(bootstrapSetup))`
   */
  def apply(name: String, bootstrapSetup: BootstrapSetup): ActorSystem =
    create(name, ActorSystemSetup.create(bootstrapSetup))

  /**
   * Creates a new ActorSystem with the specified name, and the specified Config, then
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def apply(name: String, config: Config): ActorSystem = apply(name, Option(config), None, None)

  /**
   * Creates a new ActorSystem with the specified name, the specified Config, and specified ClassLoader
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def apply(name: String, config: Config, classLoader: ClassLoader): ActorSystem =
    apply(name, Option(config), Option(classLoader), None)

  /**
   * Creates a new ActorSystem with the specified name,
   * the specified ClassLoader if given, otherwise obtains the current ClassLoader by first inspecting the current
   * threads' getContextClassLoader, then tries to walk the stack to find the callers class loader, then
   * falls back to the ClassLoader associated with the ActorSystem class.
   * If an ExecutionContext is given, it will be used as the default executor inside this ActorSystem.
   * If no ExecutionContext is given, the system will fallback to the executor configured under "akka.actor.default-dispatcher.default-executor.fallback".
   * The system will use the passed in config, or falls back to the default reference configuration using the ClassLoader.
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def apply(
      name: String,
      config: Option[Config] = None,
      classLoader: Option[ClassLoader] = None,
      defaultExecutionContext: Option[ExecutionContext] = None): ActorSystem =
    apply(name, ActorSystemSetup(BootstrapSetup(classLoader, config, defaultExecutionContext)))

  /**
   * INTERNAL API
   */
  @InternalApi private[akka] object Settings {

    /**
     * INTERNAL API
     *
     * When using Akka Typed the Slf4jLogger should be used by default.
     * Looking for config property `akka.use-slf4j` (defined in akka-actor-typed) and
     * that `Slf4jLogger` (akka-slf4j) is in  classpath.
     * Then adds `Slf4jLogger` to configured loggers and removes `DefaultLogger`.
     */
    @InternalApi private[akka] def amendSlf4jConfig(config: Config, dynamicAccess: DynamicAccess): Config = {
      val slf4jLoggerClassName = "akka.event.slf4j.Slf4jLogger"
      val slf4jLoggingFilterClassName = "akka.event.slf4j.Slf4jLoggingFilter"
      val loggersConfKey = "akka.loggers"
      val loggingFilterConfKey = "akka.logging-filter"
      val configuredLoggers = immutableSeq(config.getStringList(loggersConfKey))
      val configuredLoggingFilter = config.getString(loggingFilterConfKey)

      val loggingFilterAlreadyConfigured =
        configuredLoggingFilter == slf4jLoggingFilterClassName || configuredLoggingFilter != classOf[
            DefaultLoggingFilter].getName

      def newLoggingFilterConfStr = s"""$loggingFilterConfKey = "$slf4jLoggingFilterClassName""""

      if (configuredLoggers.contains(slf4jLoggerClassName)) {
        // already configured explicitly
        if (loggingFilterAlreadyConfigured)
          config
        else
          ConfigFactory.parseString(newLoggingFilterConfStr).withFallback(config)
      } else {
        val confKey = "akka.use-slf4j"
        if (config.hasPath(confKey) && config.getBoolean(confKey) && dynamicAccess.classIsOnClasspath(
              slf4jLoggerClassName)) {
          val newLoggers = slf4jLoggerClassName +: configuredLoggers.filterNot(_ == classOf[DefaultLogger].getName)
          val newLoggersConfStr = s"$loggersConfKey = [${newLoggers.mkString("\"", "\", \"", "\"")}]"
          val newConfStr =
            if (loggingFilterAlreadyConfigured) newLoggersConfStr
            else newLoggersConfStr + "\n" + newLoggingFilterConfStr
          ConfigFactory.parseString(newConfStr).withFallback(config)
        } else
          config
      }
    }
  }

  /**
   * Settings are the overall ActorSystem Settings which also provides a convenient access to the Config object.
   *
   * For more detailed information about the different possible configuration options, look in the Akka Documentation under "Configuration"
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  class Settings(classLoader: ClassLoader, cfg: Config, final val name: String, val setup: ActorSystemSetup) {

    def this(classLoader: ClassLoader, cfg: Config, name: String) = this(classLoader, cfg, name, ActorSystemSetup())

    /**
     * The backing Config of this ActorSystem's Settings
     *
     * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
     */
    final val config: Config = {
      cfg.checkValid(
        ConfigFactory
          .defaultReference(classLoader)
          .withoutPath(Dispatchers.InternalDispatcherId), // allow this to be both string and config object
        "akka")
      cfg
    }

    import config._

    import akka.util.Helpers.ConfigOps

    final val ConfigVersion: String = getString("akka.version")

    private final val providerSelectionSetup = setup
      .get[BootstrapSetup]
      .flatMap(_.actorRefProvider)
      .map(_.identifier)
      .getOrElse(getString("akka.actor.provider"))

    final val ProviderSelectionType: ProviderSelection = ProviderSelection(providerSelectionSetup)

    final val ProviderClass: String = ProviderSelectionType.fqcn

    final val HasCluster: Boolean = ProviderSelectionType.hasCluster

    final val SupervisorStrategyClass: String = getString("akka.actor.guardian-supervisor-strategy")
    final val CreationTimeout: Timeout = Timeout(config.getMillisDuration("akka.actor.creation-timeout"))
    final val UnstartedPushTimeout: Timeout = Timeout(config.getMillisDuration("akka.actor.unstarted-push-timeout"))

    final val AllowJavaSerialization: Boolean = getBoolean("akka.actor.allow-java-serialization")
    @deprecated("Always enabled from Akka 2.6.0", "2.6.0")
    final val EnableAdditionalSerializationBindings: Boolean = true
    final val SerializeAllMessages: Boolean = getBoolean("akka.actor.serialize-messages")
    final val SerializeAllCreators: Boolean = getBoolean("akka.actor.serialize-creators")
    final val NoSerializationVerificationNeededClassPrefix: Set[String] = {
      import akka.util.ccompat.JavaConverters._
      getStringList("akka.actor.no-serialization-verification-needed-class-prefix").asScala.toSet
    }

    final val LogLevel: String = getString("akka.loglevel")
    final val StdoutLogLevel: String = getString("akka.stdout-loglevel")
    final val Loggers: immutable.Seq[String] = immutableSeq(getStringList("akka.loggers"))
    final val LoggersDispatcher: String = getString("akka.loggers-dispatcher")
    final val LoggingFilter: String = getString("akka.logging-filter")
    final val LoggerStartTimeout: Timeout = Timeout(config.getMillisDuration("akka.logger-startup-timeout"))
    final val LogConfigOnStart: Boolean = config.getBoolean("akka.log-config-on-start")
    final val LogDeadLetters: Int = toRootLowerCase(config.getString("akka.log-dead-letters")) match {
      case "off" | "false" => 0
      case "on" | "true"   => Int.MaxValue
      case _               => config.getInt("akka.log-dead-letters")
    }
    final val LogDeadLettersDuringShutdown: Boolean = config.getBoolean("akka.log-dead-letters-during-shutdown")
    final val LogDeadLettersSuspendDuration: Duration = {
      val key = "akka.log-dead-letters-suspend-duration"
      toRootLowerCase(config.getString(key)) match {
        case "infinite" => Duration.Inf
        case _          => config.getMillisDuration(key)
      }
    }

    final val AddLoggingReceive: Boolean = getBoolean("akka.actor.debug.receive")
    final val DebugAutoReceive: Boolean = getBoolean("akka.actor.debug.autoreceive")
    final val DebugLifecycle: Boolean = getBoolean("akka.actor.debug.lifecycle")
    final val FsmDebugEvent: Boolean = getBoolean("akka.actor.debug.fsm")
    final val DebugEventStream: Boolean = getBoolean("akka.actor.debug.event-stream")
    final val DebugUnhandledMessage: Boolean = getBoolean("akka.actor.debug.unhandled")
    final val DebugRouterMisconfiguration: Boolean = getBoolean("akka.actor.debug.router-misconfiguration")

    final val Home: Option[String] = config.getString("akka.home") match {
      case "" => None
      case x  => Some(x)
    }

    final val SchedulerClass: String = getString("akka.scheduler.implementation")
    final val Daemonicity: Boolean = getBoolean("akka.daemonic")
    final val JvmExitOnFatalError: Boolean = getBoolean("akka.jvm-exit-on-fatal-error")
    final val JvmShutdownHooks: Boolean = getBoolean("akka.jvm-shutdown-hooks")
    final val FailMixedVersions: Boolean = getBoolean("akka.fail-mixed-versions")

    final val CoordinatedShutdownTerminateActorSystem: Boolean = getBoolean(
      "akka.coordinated-shutdown.terminate-actor-system")
    final val CoordinatedShutdownRunByActorSystemTerminate: Boolean = getBoolean(
      "akka.coordinated-shutdown.run-by-actor-system-terminate")
    if (CoordinatedShutdownRunByActorSystemTerminate && !CoordinatedShutdownTerminateActorSystem)
      throw new ConfigurationException(
        "akka.coordinated-shutdown.run-by-actor-system-terminate=on and " +
        "akka.coordinated-shutdown.terminate-actor-system=off is not a supported configuration combination.")

    final val DefaultVirtualNodesFactor: Int = getInt("akka.actor.deployment.default.virtual-nodes-factor")

    if (ConfigVersion != Version)
      throw new akka.ConfigurationException(
        "Akka JAR version [" + Version + "] does not match the provided config version [" + ConfigVersion + "]")

    /**
     * Returns the String representation of the Config that this Settings is backed by
     */
    override def toString: String = config.root.render

  }

  private[akka] def findClassLoader(): ClassLoader = Reflect.findClassLoader()
}

/**
 * An actor system is a hierarchical group of actors which share common
 * configuration, e.g. dispatchers, deployments, remote capabilities and
 * addresses. It is also the entry point for creating or looking up actors.
 *
 * There are several possibilities for creating actors (see [[akka.actor.Props]]
 * for details on `props`):
 *
 * {{{
 * // Java or Scala
 * system.actorOf(props, "name")
 * system.actorOf(props)
 *
 * // Scala
 * system.actorOf(Props[MyActor], "name")
 * system.actorOf(Props(classOf[MyActor], arg1, arg2), "name")
 *
 * // Java
 * system.actorOf(Props.create(MyActor.class), "name");
 * system.actorOf(Props.create(MyActor.class, arg1, arg2), "name");
 * }}}
 *
 * Where no name is given explicitly, one will be automatically generated.
 *
 * <b><i>Important Notice:</i></b>
 *
 * This class is not meant to be extended by user code. If you want to
 * actually roll your own Akka, it will probably be better to look into
 * extending [[akka.actor.ExtendedActorSystem]] instead, but beware that you
 * are completely on your own in that case!
 */
abstract class ActorSystem extends ActorRefFactory with ClassicActorSystemProvider {
  import ActorSystem._

  /**
   * The name of this actor system, used to distinguish multiple ones within
   * the same JVM & class loader.
   */
  def name: String

  /**
   * The core settings extracted from the supplied configuration.
   */
  def settings: Settings

  /**
   * Log the configuration.
   */
  def logConfiguration(): Unit

  /**
   * Construct a path below the application guardian to be used with [[ActorSystem#actorSelection]].
   */
  def /(name: String): ActorPath

  /**
   * Java API: Create a new child actor path.
   */
  def child(child: String): ActorPath = /(child)

  /**
   * Construct a path below the application guardian to be used with [[ActorSystem#actorSelection]].
   */
  def /(name: Iterable[String]): ActorPath

  /**
   * Java API: Recursively create a descendant’s path by appending all child names.
   */
  def descendant(names: java.lang.Iterable[String]): ActorPath = /(immutableSeq(names))

  /**
   * Start-up time in milliseconds since the epoch.
   */
  val startTime: Long = System.currentTimeMillis

  /**
   * Up-time of this actor system in seconds.
   */
  def uptime: Long = (System.currentTimeMillis - startTime) / 1000

  /**
   * Main event bus of this actor system, used for example for logging.
   */
  def eventStream: EventStream

  /**
   * Java API: Main event bus of this actor system, used for example for logging.
   */
  def getEventStream: EventStream = eventStream

  /**
   * Convenient logging adapter for logging to the [[ActorSystem#eventStream]].
   */
  def log: LoggingAdapter

  /**
   * Actor reference where messages are re-routed to which were addressed to
   * stopped or non-existing actors. Delivery to this actor is done on a best
   * effort basis and hence not strictly guaranteed.
   */
  def deadLetters: ActorRef

  /**
   * Light-weight scheduler for running asynchronous tasks after some deadline
   * in the future. Not terribly precise but cheap.
   */
  def scheduler: Scheduler

  /**
   * Java API: Light-weight scheduler for running asynchronous tasks after some deadline
   * in the future. Not terribly precise but cheap.
   */
  def getScheduler: Scheduler = scheduler

  /**
   * Helper object for looking up configured dispatchers.
   */
  def dispatchers: Dispatchers

  /**
   * Default dispatcher as configured. This dispatcher is used for all actors
   * in the actor system which do not have a different dispatcher configured
   * explicitly.
   * Importing this member will place the default MessageDispatcher in scope.
   */
  implicit def dispatcher: ExecutionContextExecutor

  /**
   * Java API: Default dispatcher as configured. This dispatcher is used for all actors
   * in the actor system which do not have a different dispatcher configured
   * explicitly.
   * Importing this member will place the default MessageDispatcher in scope.
   */
  def getDispatcher: ExecutionContextExecutor = dispatcher

  /**
   * Helper object for looking up configured mailbox types.
   */
  def mailboxes: Mailboxes

  /**
   * Register a block of code (callback) to run after [[ActorSystem.terminate]] has been issued and
   * all actors in this actor system have been stopped.
   * Multiple code blocks may be registered by calling this method multiple times.
   * The callbacks will be run sequentially in reverse order of registration, i.e.
   * last registration is run first.
   * Note that ActorSystem will not terminate until all the registered callbacks are finished.
   *
   * Throws a RejectedExecutionException if the System has already been terminated or if termination has been initiated.
   *
   * Scala API
   */
  def registerOnTermination[T](code: => T): Unit

  /**
   * Java API: Register a block of code (callback) to run after [[ActorSystem.terminate]] has been issued and
   * all actors in this actor system have been stopped.
   * Multiple code blocks may be registered by calling this method multiple times.
   * The callbacks will be run sequentially in reverse order of registration, i.e.
   * last registration is run first.
   * Note that ActorSystem will not terminate until all the registered callbacks are finished.
   *
   * Throws a RejectedExecutionException if the System has already been terminated or if termination has been initiated.
   */
  def registerOnTermination(code: Runnable): Unit

  /**
   * Terminates this actor system by running [[CoordinatedShutdown]] with reason
   * [[CoordinatedShutdown.ActorSystemTerminateReason]].
   *
   * If `akka.coordinated-shutdown.run-by-actor-system-terminate` is configured to `off`
   * it will not run `CoordinatedShutdown`, but the `ActorSystem` and its actors
   * will still be terminated.
   *
   * This will stop the guardian actor, which in turn
   * will recursively stop all its child actors, and finally the system guardian
   * (below which the logging actors reside) and then execute all registered
   * termination handlers (see [[ActorSystem#registerOnTermination]]).
   * Be careful to not schedule any operations on completion of the returned future
   * using the dispatcher of this actor system as it will have been shut down before the
   * future completes.
   */
  def terminate(): Future[Terminated]

  /**
   * Returns a Future which will be completed after the ActorSystem has been terminated
   * and termination hooks have been executed. If you registered any callback with
   * [[ActorSystem#registerOnTermination]], the returned Future from this method will not complete
   * until all the registered callbacks are finished. Be careful to not schedule any operations,
   * such as `onComplete`, on the dispatchers (`ExecutionContext`) of this actor system as they
   * will have been shut down before this future completes.
   */
  def whenTerminated: Future[Terminated]

  /**
   * Returns a CompletionStage which will be completed after the ActorSystem has been terminated
   * and termination hooks have been executed. If you registered any callback with
   * [[ActorSystem#registerOnTermination]], the returned CompletionStage from this method will not complete
   * until all the registered callbacks are finished. Be careful to not schedule any operations,
   * such as `thenRunAsync`, on the dispatchers (`Executor`) of this actor system as they
   * will have been shut down before this CompletionStage completes.
   */
  def getWhenTerminated: CompletionStage[Terminated]

  /**
   * Registers the provided extension and creates its payload, if this extension isn't already registered
   * This method has putIfAbsent-semantics, this method can potentially block, waiting for the initialization
   * of the payload, if is in the process of registration from another Thread of execution
   */
  def registerExtension[T <: Extension](ext: ExtensionId[T]): T

  /**
   * Returns the payload that is associated with the provided extension
   * throws an IllegalStateException if it is not registered.
   * This method can potentially block, waiting for the initialization
   * of the payload, if is in the process of registration from another Thread of execution
   */
  def extension[T <: Extension](ext: ExtensionId[T]): T

  /**
   * Returns whether the specified extension is already registered, this method can potentially block, waiting for the initialization
   * of the payload, if is in the process of registration from another Thread of execution
   */
  def hasExtension(ext: ExtensionId[_ <: Extension]): Boolean
}

/**
 * More powerful interface to the actor system’s implementation which is presented to extensions (see [[akka.actor.Extension]]).
 *
 * <b><i>Important Notice:</i></b>
 *
 * This class is not meant to be extended by user code. If you want to
 * actually roll your own Akka, beware that you are completely on your own in
 * that case!
 */
@DoNotInherit
abstract class ExtendedActorSystem extends ActorSystem {

  /**
   * The ActorRefProvider is the only entity which creates all actor references within this actor system.
   */
  def provider: ActorRefProvider

  /**
   * The top-level supervisor of all actors created using system.actorOf(...).
   */
  def guardian: InternalActorRef

  /**
   * The top-level supervisor of all system-internal services like logging.
   */
  def systemGuardian: InternalActorRef

  /**
   * Create an actor in the "/system" namespace. This actor will be shut down
   * during system.terminate only after all user actors have terminated.
   *
   * This is only intended to be used by libraries (and Akka itself).
   * Applications should use ordinary `actorOf`.
   */
  def systemActorOf(props: Props, name: String): ActorRef

  /**
   * A ThreadFactory that can be used if the transport needs to create any Threads
   */
  def threadFactory: ThreadFactory

  /**
   * ClassLoader wrapper which is used for reflective accesses internally. This is set
   * to use the context class loader, if one is set, or the class loader which
   * loaded the ActorSystem implementation. The context class loader is also
   * set on all threads created by the ActorSystem, if one was set during
   * creation.
   */
  def dynamicAccess: DynamicAccess

  /**
   * Filter of log events that is used by the LoggingAdapter before
   * publishing log events to the eventStream
   */
  def logFilter: LoggingFilter

  /**
   * For debugging: traverse actor hierarchy and make string representation.
   * Careful, this may OOM on large actor systems, and it is only meant for
   * helping debugging in case something already went terminally wrong.
   */
  private[akka] def printTree: String

  /**
   * INTERNAL API: final step of `terminate()`
   */
  @InternalApi private[akka] def finalTerminate(): Unit

  /**
   * INTERNAL API
   */
  @InternalApi private[akka] def isTerminating(): Boolean

}

/**
 * Internal API
 */
@InternalApi
private[akka] class ActorSystemImpl(
    val name: String,
    applicationConfig: Config,
    classLoader: ClassLoader,
    defaultExecutionContext: Option[ExecutionContext],
    val guardianProps: Option[Props],
    setup: ActorSystemSetup)
    extends ExtendedActorSystem {

  if (!name.matches("""^[a-zA-Z0-9][a-zA-Z0-9-_]*$"""))
    throw new IllegalArgumentException(
      "invalid ActorSystem name [" + name +
      "], must contain only word characters (i.e. [a-zA-Z0-9] plus non-leading '-' or '_')")

  import ActorSystem._

  @volatile private var logDeadLetterListener: Option[ActorRef] = None

  private val _dynamicAccess: DynamicAccess = createDynamicAccess()

  final val settings: Settings = {
    val config = Settings.amendSlf4jConfig(
      applicationConfig.withFallback(ConfigFactory.defaultReference(classLoader)),
      _dynamicAccess)
    new Settings(classLoader, config, name, setup)
  }

  protected def uncaughtExceptionHandler: Thread.UncaughtExceptionHandler =
    new Thread.UncaughtExceptionHandler() {
      def uncaughtException(thread: Thread, cause: Throwable): Unit = {
        cause match {
          case NonFatal(_) | _: InterruptedException | _: NotImplementedError | _: ControlThrowable =>
            log.error(cause, "Uncaught error from thread [{}]", thread.getName)
          case _ =>
            if (cause.isInstanceOf[IncompatibleClassChangeError] && cause.getMessage.startsWith("akka"))
              System.err.println(
                s"""Detected ${cause.getClass.getName} error, which MAY be caused by incompatible Akka versions on the classpath.
                  | Please note that a given Akka version MUST be the same across all modules of Akka that you are using,
                  | e.g. if you use akka-actor [${akka.Version.current} (resolved from current classpath)] all other core
                  | Akka modules MUST be of the same version. External projects like Alpakka, Persistence plugins or Akka
                  | HTTP etc. have their own version numbers - please make sure you're using a compatible set of libraries.
                 """.stripMargin.replaceAll("[\r\n]", ""))

            if (settings.JvmExitOnFatalError)
              try logFatalError("shutting down JVM since 'akka.jvm-exit-on-fatal-error' is enabled for", cause, thread)
              finally System.exit(-1)
            else
              try logFatalError("shutting down", cause, thread)
              finally terminate()
        }
      }

      @inline
      private def logFatalError(message: String, cause: Throwable, thread: Thread): Unit = {
        // First log to stderr as this has the best chance to get through in an 'emergency panic' situation:
        import System.err
        err.print("Uncaught error from thread [")
        err.print(thread.getName)
        err.print("]: ")
        err.print(cause.getMessage)
        err.print(", ")
        err.print(message)
        err.print(" ActorSystem[")
        err.print(name)
        err.println("]")
        System.err.flush()
        cause.printStackTrace(System.err)
        System.err.flush()

        // Also log using the normal infrastructure - hope for the best:
        markerLogging.error(
          LogMarker.Security,
          cause,
          "Uncaught error from thread [{}]: " + cause.getMessage + ", " + message + " ActorSystem[{}]",
          thread.getName,
          name)
      }
    }

  final val threadFactory: MonitorableThreadFactory =
    MonitorableThreadFactory(name, settings.Daemonicity, Option(classLoader), uncaughtExceptionHandler)

  /**
   * This is an extension point: by overriding this method, subclasses can
   * control all reflection activities of an actor system.
   */
  protected def createDynamicAccess(): DynamicAccess = new ReflectiveDynamicAccess(classLoader)

  def dynamicAccess: DynamicAccess = _dynamicAccess

  def logConfiguration(): Unit = log.info(settings.toString)

  protected def systemImpl: ActorSystemImpl = this

  def systemActorOf(props: Props, name: String): ActorRef =
    systemGuardian.underlying.attachChild(props, name, systemService = true)

  def actorOf(props: Props, name: String): ActorRef =
    if (guardianProps.isEmpty) guardian.underlying.attachChild(props, name, systemService = false)
    else
      throw new UnsupportedOperationException(
        s"cannot create top-level actor [$name] from the outside on ActorSystem with custom user guardian")

  def actorOf(props: Props): ActorRef =
    if (guardianProps.isEmpty) guardian.underlying.attachChild(props, systemService = false)
    else
      throw new UnsupportedOperationException(
        "cannot create top-level actor from the outside on ActorSystem with custom user guardian")

  def stop(actor: ActorRef): Unit = {
    val path = actor.path
    val guard = guardian.path
    val sys = systemGuardian.path
    path.parent match {
      case `guard` => guardian ! StopChild(actor)
      case `sys`   => systemGuardian ! StopChild(actor)
      case _       => actor.asInstanceOf[InternalActorRef].stop()
    }
  }

  import settings._

  // this provides basic logging (to stdout) until .start() is called below
  val eventStream = new EventStream(this, DebugEventStream)
  eventStream.startStdoutLogger(settings)

  val logFilter: LoggingFilter = {
    val arguments = Vector(classOf[Settings] -> settings, classOf[EventStream] -> eventStream)
    dynamicAccess.createInstanceFor[LoggingFilter](LoggingFilter, arguments).get
  }

  private[this] val markerLogging =
    new MarkerLoggingAdapter(eventStream, getClass.getName + "(" + name + ")", this.getClass, logFilter)
  val log: LoggingAdapter = markerLogging

  val scheduler: Scheduler = createScheduler()

  val provider: ActorRefProvider = try {
    val arguments = Vector(
      classOf[String] -> name,
      classOf[Settings] -> settings,
      classOf[EventStream] -> eventStream,
      classOf[DynamicAccess] -> dynamicAccess)

    dynamicAccess.createInstanceFor[ActorRefProvider](ProviderClass, arguments).get
  } catch {
    case NonFatal(e) =>
      Try(stopScheduler())
      throw e
  }

  def deadLetters: ActorRef = provider.deadLetters

  val mailboxes: Mailboxes = new Mailboxes(settings, eventStream, dynamicAccess, deadLetters)

  val dispatchers: Dispatchers = new Dispatchers(
    settings,
    DefaultDispatcherPrerequisites(
      threadFactory,
      eventStream,
      scheduler,
      dynamicAccess,
      settings,
      mailboxes,
      defaultExecutionContext),
    log)

  val dispatcher: ExecutionContextExecutor = dispatchers.defaultGlobalDispatcher

  private[this] final val terminationCallbacks = new TerminationCallbacks(provider.terminationFuture)(dispatcher)

  override def whenTerminated: Future[Terminated] = terminationCallbacks.terminationFuture
  override def getWhenTerminated: CompletionStage[Terminated] = FutureConverters.toJava(whenTerminated)
  def lookupRoot: InternalActorRef = provider.rootGuardian
  def guardian: LocalActorRef = provider.guardian
  def systemGuardian: LocalActorRef = provider.systemGuardian

  def /(actorName: String): ActorPath = guardian.path / actorName
  def /(path: Iterable[String]): ActorPath = guardian.path / path

  override def classicSystem: ActorSystem = this

  // Used for ManifestInfo.checkSameVersion
  private def allModules: List[String] =
    List(
      "akka-actor",
      "akka-actor-testkit-typed",
      "akka-actor-typed",
      "akka-cluster",
      "akka-cluster-metrics",
      "akka-cluster-sharding",
      "akka-cluster-sharding-typed",
      "akka-cluster-tools",
      "akka-cluster-typed",
      "akka-coordination",
      "akka-discovery",
      "akka-distributed-data",
      "akka-testkit",
      "akka-multi-node-testkit",
      "akka-osgi",
      "akka-persistence",
      "akka-persistence-query",
      "akka-persistence-shared",
      "akka-persistence-testkit",
      "akka-persistence-typed",
      "akka-pki",
      "akka-protobuf",
      "akka-protobuf-v3",
      "akka-remote",
      "akka-serialization-jackson",
      "akka-slf4j",
      "akka-stream",
      "akka-stream-testkit",
      "akka-stream-typed",
      "akka-stream-testkit")

  @volatile private var _initialized = false

  /**
   *  Asserts that the ActorSystem has been fully initialized. Can be used to guard code blocks that might accidentally
   *  be run during initialization but require a fully initialized ActorSystem before proceeding.
   */
  def assertInitialized(): Unit =
    if (!_initialized)
      throw new IllegalStateException(
        "The calling code expected that the ActorSystem was initialized but it wasn't yet. " +
        "This is probably a bug in the ActorSystem initialization sequence often related to initialization of extensions. " +
        "Please report at https://github.com/akka/akka/issues.")
  private lazy val _start: this.type = try {

    registerOnTermination(stopScheduler())
    // the provider is expected to start default loggers, LocalActorRefProvider does this
    provider.init(this)
    // at this point it should be initialized "enough" for most extensions that we might want to guard against otherwise
    _initialized = true

    if (settings.LogDeadLetters > 0)
      logDeadLetterListener = Some(systemActorOf(Props[DeadLetterListener](), "deadLetterListener"))
    eventStream.startUnsubscriber()
    ManifestInfo(this).checkSameVersion("Akka", allModules, logWarning = true)
    if (!terminating)
      loadExtensions()
    if (LogConfigOnStart) logConfiguration()
    this
  } catch {
    case NonFatal(e) =>
      try terminate()
      catch { case NonFatal(_) => Try(stopScheduler()) }
      throw e
  }

  def start(): this.type = _start
  def registerOnTermination[T](code: => T): Unit = { registerOnTermination(new Runnable { def run = code }) }
  def registerOnTermination(code: Runnable): Unit = { terminationCallbacks.add(code) }

  @volatile private var terminating = false

  override def terminate(): Future[Terminated] = {
    terminating = true
    if (settings.CoordinatedShutdownRunByActorSystemTerminate && !aborting) {
      // Note that the combination CoordinatedShutdownRunByActorSystemTerminate==true &&
      // CoordinatedShutdownTerminateActorSystem==false is disallowed, checked in Settings.
      // It's not a combination that is valuable to support and it would be complicated to
      // protect against concurrency race conditions between calls to ActorSystem.terminate()
      // and CoordinateShutdown.run()

      // it will call finalTerminate() at the end
      CoordinatedShutdown(this).run(CoordinatedShutdown.ActorSystemTerminateReason)
    } else {
      finalTerminate()
    }
    whenTerminated
  }

  override private[akka] def finalTerminate(): Unit = {
    terminating = true
    // these actions are idempotent
    if (!settings.LogDeadLettersDuringShutdown) logDeadLetterListener.foreach(stop)
    guardian.stop()
  }

  override private[akka] def isTerminating(): Boolean = {
    terminating || aborting || CoordinatedShutdown(this).shutdownReason().isDefined
  }

  @volatile var aborting = false

  /**
   * This kind of shutdown attempts to bring the system down and release its
   * resources more forcefully than plain shutdown. For example it will not
   * run CoordinatedShutdown and not wait for remote-deployed child actors to
   * terminate before terminating their parents.
   */
  def abort(): Unit = {
    aborting = true
    terminate()
  }

  //#create-scheduler
  /**
   * Create the scheduler service. This one needs one special behavior: if
   * Closeable, it MUST execute all outstanding tasks upon .close() in order
   * to properly shutdown all dispatchers.
   *
   * Furthermore, this timer service MUST throw IllegalStateException if it
   * cannot schedule a task. Once scheduled, the task MUST be executed. If
   * executed upon close(), the task may execute before its timeout.
   */
  protected def createScheduler(): Scheduler =
    dynamicAccess
      .createInstanceFor[Scheduler](
        settings.SchedulerClass,
        immutable.Seq(
          classOf[Config] -> settings.config,
          classOf[LoggingAdapter] -> log,
          classOf[ThreadFactory] -> threadFactory.withName(threadFactory.name + "-scheduler")))
      .get
  //#create-scheduler

  /*
   * This is called after the last actor has signaled its termination, i.e.
   * after the last dispatcher has had its chance to schedule its shutdown
   * action.
   */
  protected def stopScheduler(): Unit = scheduler match {
    case x: Closeable => x.close()
    case _            =>
  }

  // For each ExtensionId, either:
  // 1) a CountDownLatch (if it's still in the process of being registered),
  // 2) a Throwable (if it failed initializing), or
  // 3) the registered extension.
  private val extensions = new ConcurrentHashMap[ExtensionId[_], AnyRef]

  /**
   * Returns any extension registered to the specified Extension or returns null if not registered
   */
  @tailrec
  private def findExtension[T <: Extension](ext: ExtensionId[T]): T = extensions.get(ext) match {
    case c: CountDownLatch =>
      blocking {
        val awaitMillis = settings.CreationTimeout.duration.toMillis
        if (!c.await(awaitMillis, TimeUnit.MILLISECONDS))
          throw new IllegalStateException(
            s"Initialization of [$ext] took more than [$awaitMillis ms]. " +
            (if (ext == SerializationExtension)
               "A serializer must not access the SerializationExtension from its constructor. Use lazy init."
             else "Could be deadlock due to cyclic initialization of extensions."))
      }
      findExtension(ext) //Registration in process, await completion and retry
    case t: Throwable => throw t //Initialization failed, throw same again
    case other =>
      other.asInstanceOf[T] //could be a T or null, in which case we return the null as T
  }

  @tailrec
  final def registerExtension[T <: Extension](ext: ExtensionId[T]): T = {
    findExtension(ext) match {
      case null => //Doesn't already exist, commence registration
        val inProcessOfRegistration = new CountDownLatch(1)
        extensions.putIfAbsent(ext, inProcessOfRegistration) match { // Signal that registration is in process
          case null =>
            try { // Signal was successfully sent
              ext.createExtension(this) match { // Create and initialize the extension
                case null =>
                  throw new IllegalStateException(s"Extension instance created as 'null' for extension [$ext]")
                case instance =>
                  extensions.replace(ext, inProcessOfRegistration, instance) //Replace our in process signal with the initialized extension
                  instance //Profit!
              }
            } catch {
              case t: Throwable =>
                extensions.replace(ext, inProcessOfRegistration, t) //In case shit hits the fan, remove the inProcess signal
                throw t //Escalate to caller
            } finally {
              inProcessOfRegistration.countDown() //Always notify listeners of the inProcess signal
            }
          case _ =>
            registerExtension(ext) //Someone else is in process of registering an extension for this Extension, retry
        }
      case existing => existing.asInstanceOf[T]
    }
  }

  def extension[T <: Extension](ext: ExtensionId[T]): T = findExtension(ext) match {
    case null => throw new IllegalArgumentException(s"Trying to get non-registered extension [$ext]")
    case some => some.asInstanceOf[T]
  }

  def hasExtension(ext: ExtensionId[_ <: Extension]): Boolean = findExtension(ext) != null

  private def loadExtensions(): Unit = {

    /*
     * @param throwOnLoadFail
     *  Throw exception when an extension fails to load (needed for backwards compatibility.
     *    when the extension cannot be found at all we throw regardless of this setting)
     */
    def loadExtensions(key: String, throwOnLoadFail: Boolean): Unit = {

      immutableSeq(settings.config.getStringList(key)).foreach { fqcn =>
        dynamicAccess.getObjectFor[AnyRef](fqcn).recoverWith {
          case firstProblem =>
            dynamicAccess.createInstanceFor[AnyRef](fqcn, Nil).recoverWith { case _ => Failure(firstProblem) }
        } match {
          case Success(p: ExtensionIdProvider) =>
            registerExtension(p.lookup)
          case Success(p: ExtensionId[_]) =>
            registerExtension(p)
          case Success(_) =>
            if (!throwOnLoadFail) log.error("[{}] is not an 'ExtensionIdProvider' or 'ExtensionId', skipping...", fqcn)
            else throw new RuntimeException(s"[$fqcn] is not an 'ExtensionIdProvider' or 'ExtensionId'")
          case Failure(problem) =>
            if (!throwOnLoadFail) log.error(problem, "While trying to load extension [{}], skipping...", fqcn)
            else throw new RuntimeException(s"While trying to load extension [$fqcn]", problem)
        }
      }
    }

    loadExtensions("akka.library-extensions", throwOnLoadFail = true)
    loadExtensions("akka.extensions", throwOnLoadFail = false)
  }

  override def toString: String = lookupRoot.path.root.address.toString

  override def printTree: String = {
    def printNode(node: ActorRef, indent: String): String = {
      node match {
        case wc: ActorRefWithCell =>
          val cell = wc.underlying
          (if (indent.isEmpty) "-> " else indent.dropRight(1) + "⌊-> ") +
          node.path.name + " " + Logging.simpleName(node) + " " +
          (cell match {
            case real: ActorCell =>
              val realActor = real.actor
              if (realActor ne null) realActor.getClass else "null"
            case _ => Logging.simpleName(cell)
          }) +
          (cell match {
            case real: ActorCell => " status=" + real.mailbox.currentStatus
            case _               => ""
          }) +
          " " + (cell.childrenRefs match {
            case ChildrenContainer.TerminatingChildrenContainer(_, toDie, reason) =>
              "Terminating(" + reason + ")" +
              (toDie.toSeq.sorted.mkString("\n" + indent + "   |    toDie: ", "\n" + indent + "   |           ", ""))
            case x @ (ChildrenContainer.TerminatedChildrenContainer | ChildrenContainer.EmptyChildrenContainer) =>
              x.toString
            case n: ChildrenContainer.NormalChildrenContainer => n.c.size.toString + " children"
            case x                                            => Logging.simpleName(x)
          }) +
          (if (cell.childrenRefs.children.isEmpty) "" else "\n") +
          ({
            val children = cell.childrenRefs.children.toSeq.sorted
            val bulk = children.dropRight(1).map(printNode(_, indent + "   |"))
            bulk ++ (children.lastOption.map(printNode(_, indent + "    ")))
          }.mkString("\n"))
        case _ =>
          indent + node.path.name + " " + Logging.simpleName(node)
      }
    }
    printNode(lookupRoot, "")
  }

  final class TerminationCallbacks[T](upStreamTerminated: Future[T])(implicit ec: ExecutionContext) {
    private[this] final val done = Promise[T]()
    private[this] final val ref = new AtomicReference(done)

    // onComplete never fires twice so safe to avoid null check
    upStreamTerminated.onComplete { t =>
      ref.getAndSet(null).complete(t)
    }

    /**
     * Adds a Runnable that will be executed on ActorSystem termination.
     * Note that callbacks are executed in reverse order of insertion.
     *
     * @param r The callback to be executed on ActorSystem termination
     * Throws RejectedExecutionException if called after ActorSystem has been terminated.
     */
    final def add(r: Runnable): Unit = {
      @tailrec def addRec(r: Runnable, p: Promise[T]): Unit = ref.get match {
        case null                               => throw new RejectedExecutionException("ActorSystem already terminated.")
        case some if ref.compareAndSet(some, p) => some.completeWith(p.future.andThen { case _ => r.run() })
        case _                                  => addRec(r, p)
      }
      addRec(r, Promise[T]())
    }

    /**
     * Returns a Future which will be completed once all registered callbacks have been executed.
     */
    def terminationFuture: Future[T] = done.future
  }
}

Mar 30, 2021 9:06:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 299
Mar 30, 2021 9:06:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 307
[0m2021.03.30 21:13:02 INFO  compiling root (1 scala source)[0m
[0m2021.03.30 21:13:04 INFO  time: compiled root in 2.05s[0m
[0m2021.03.30 21:15:22 INFO  compiling root (1 scala source)[0m
[0m2021.03.30 21:15:22 INFO  time: compiled root in 1s[0m
Mar 30, 2021 9:16:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 823
Mar 30, 2021 9:17:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 828
Mar 30, 2021 9:17:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 838
import _root_.scala.xml.{TopScope=>$scope}
import _root_.sbt._
import _root_.sbt.Keys._
import _root_.sbt.nio.Keys._
import _root_.sbt.ScriptedPlugin.autoImport._, _root_.bloop.integrations.sbt.BloopPlugin.autoImport._
import _root_.sbt.plugins.IvyPlugin, _root_.sbt.plugins.JvmPlugin, _root_.sbt.plugins.CorePlugin, _root_.sbt.ScriptedPlugin, _root_.sbt.plugins.SbtPlugin, _root_.sbt.plugins.SemanticdbPlugin, _root_.sbt.plugins.JUnitXmlReportPlugin, _root_.sbt.plugins.Giter8TemplatePlugin, _root_.bloop.integrations.sbt.BloopPlugin
addSbtPlugin("com.typesafe.play" % "sbt-plugin" % "2.8.7")
addSbtPlugin("org.foundweekends.giter8" % "sbt-giter8-scaffold" % "0.11.0")

Mar 30, 2021 9:17:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 843
import _root_.scala.xml.{TopScope=>$scope}
import _root_.sbt._
import _root_.sbt.Keys._
import _root_.sbt.nio.Keys._
import _root_.sbt.ScriptedPlugin.autoImport._, _root_.bloop.integrations.sbt.BloopPlugin.autoImport._
import _root_.sbt.plugins.IvyPlugin, _root_.sbt.plugins.JvmPlugin, _root_.sbt.plugins.CorePlugin, _root_.sbt.ScriptedPlugin, _root_.sbt.plugins.SbtPlugin, _root_.sbt.plugins.SemanticdbPlugin, _root_.sbt.plugins.JUnitXmlReportPlugin, _root_.sbt.plugins.Giter8TemplatePlugin, _root_.bloop.integrations.sbt.BloopPlugin
// DO NOT EDIT! This file is auto-generated.
// This file enables sbt-bloop to create bloop config files.

addSbtPlugin("ch.epfl.scala" % "sbt-bloop" % "1.4.8")

[0m2021.03.30 21:17:11 INFO  time: code lens generation in 1.49s[0m
[0m2021.03.30 21:17:11 INFO  time: code lens generation in 4.14s[0m
import _root_.scala.xml.{TopScope=>$scope}
import _root_.sbt._
import _root_.sbt.Keys._
import _root_.sbt.nio.Keys._
import _root_.sbt.ScriptedPlugin.autoImport._, _root_.bloop.integrations.sbt.BloopPlugin.autoImport._, _root_.play.sbt.Play.autoImport._, _root_.play.sbt.PlayService.autoImport._, _root_.play.sbt.routes.RoutesCompiler.autoImport._, _root_.giter8.ScaffoldPlugin.autoImport._, _root_.play.twirl.sbt.SbtTwirl.autoImport._, _root_.com.typesafe.sbt.SbtNativePackager.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.JavaAppPackaging.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.JavaServerAppPackaging.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.jar.ClasspathJarPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.jar.LauncherJarPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.jlink.JlinkPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.scripts.BashStartScriptPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.scripts.BatStartScriptPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemdPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemloaderPlugin.autoImport._, _root_.com.typesafe.sbt.packager.debian.DebianPlugin.autoImport._, _root_.com.typesafe.sbt.packager.docker.DockerPlugin.autoImport._, _root_.com.typesafe.sbt.packager.graalvmnativeimage.GraalVMNativeImagePlugin.autoImport._, _root_.com.typesafe.sbt.packager.jdkpackager.JDKPackagerPlugin.autoImport._, _root_.com.typesafe.sbt.packager.linux.LinuxPlugin.autoImport._, _root_.com.typesafe.sbt.packager.rpm.RpmPlugin.autoImport._, _root_.com.typesafe.sbt.packager.universal.UniversalPlugin.autoImport._, _root_.com.typesafe.sbt.packager.windows.WindowsPlugin.autoImport._, _root_.com.lightbend.sbt.javaagent.JavaAgent.autoImport._, _root_.com.typesafe.sbt.web.SbtWeb.autoImport._, _root_.com.typesafe.sbt.jse.SbtJsEngine.autoImport._, _root_.com.typesafe.sbt.jse.SbtJsTask.autoImport._
import _root_.sbt.plugins.IvyPlugin, _root_.sbt.plugins.JvmPlugin, _root_.sbt.plugins.CorePlugin, _root_.sbt.ScriptedPlugin, _root_.sbt.plugins.SbtPlugin, _root_.sbt.plugins.SemanticdbPlugin, _root_.sbt.plugins.JUnitXmlReportPlugin, _root_.sbt.plugins.Giter8TemplatePlugin, _root_.bloop.integrations.sbt.BloopPlugin, _root_.play.sbt.Play, _root_.play.sbt.PlayAkkaHttp2Support, _root_.play.sbt.PlayAkkaHttpServer, _root_.play.sbt.PlayFilters, _root_.play.sbt.PlayJava, _root_.play.sbt.PlayLayoutPlugin, _root_.play.sbt.PlayLogback, _root_.play.sbt.PlayMinimalJava, _root_.play.sbt.PlayNettyServer, _root_.play.sbt.PlayScala, _root_.play.sbt.PlayService, _root_.play.sbt.PlayWeb, _root_.play.sbt.routes.RoutesCompiler, _root_.play.sbt.test.MediatorWorkaroundPlugin, _root_.giter8.ScaffoldPlugin, _root_.play.twirl.sbt.SbtTwirl, _root_.com.typesafe.sbt.SbtNativePackager, _root_.com.typesafe.sbt.packager.archetypes.JavaAppPackaging, _root_.com.typesafe.sbt.packager.archetypes.JavaServerAppPackaging, _root_.com.typesafe.sbt.packager.archetypes.jar.ClasspathJarPlugin, _root_.com.typesafe.sbt.packager.archetypes.jar.LauncherJarPlugin, _root_.com.typesafe.sbt.packager.archetypes.jlink.JlinkPlugin, _root_.com.typesafe.sbt.packager.archetypes.scripts.AshScriptPlugin, _root_.com.typesafe.sbt.packager.archetypes.scripts.BashStartScriptPlugin, _root_.com.typesafe.sbt.packager.archetypes.scripts.BatStartScriptPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemVPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemdPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemloaderPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.UpstartPlugin, _root_.com.typesafe.sbt.packager.debian.DebianDeployPlugin, _root_.com.typesafe.sbt.packager.debian.DebianPlugin, _root_.com.typesafe.sbt.packager.debian.JDebPackaging, _root_.com.typesafe.sbt.packager.docker.DockerPlugin, _root_.com.typesafe.sbt.packager.docker.DockerSpotifyClientPlugin, _root_.com.typesafe.sbt.packager.graalvmnativeimage.GraalVMNativeImagePlugin, _root_.com.typesafe.sbt.packager.jdkpackager.JDKPackagerDeployPlugin, _root_.com.typesafe.sbt.packager.jdkpackager.JDKPackagerPlugin, _root_.com.typesafe.sbt.packager.linux.LinuxPlugin, _root_.com.typesafe.sbt.packager.rpm.RpmDeployPlugin, _root_.com.typesafe.sbt.packager.rpm.RpmPlugin, _root_.com.typesafe.sbt.packager.universal.UniversalDeployPlugin, _root_.com.typesafe.sbt.packager.universal.UniversalPlugin, _root_.com.typesafe.sbt.packager.windows.WindowsDeployPlugin, _root_.com.typesafe.sbt.packager.windows.WindowsPlugin, _root_.com.lightbend.sbt.javaagent.JavaAgent, _root_.com.lightbend.sbt.javaagent.JavaAgentPackaging, _root_.com.typesafe.sbt.web.SbtWeb, _root_.com.typesafe.sbt.jse.SbtJsEngine, _root_.com.typesafe.sbt.jse.SbtJsTask
name := """scalabackend"""
organization := "com.example"

version := "1.0-SNAPSHOT"

lazy val root = (project in file(".")).enablePlugins(PlayScala)

scalaVersion := "2.13.3"

libraryDependencies += guice
libraryDependencies += "org.scalatestplus.play" %% "scalatestplus-play" % "5.0.0" % Test
libraryDependencies ++= Seq(
  jdbc
)
libraryDependencies ++= Seq(
  "mysql" % "mysql-connector-java" % "5.1.41"
)
// Adds additional packages into Twirl
//TwirlKeys.templateImports += "com.example.controllers._"

// Adds additional packages into conf/routes
// play.sbt.routes.RoutesKeys.routesImport += "com.example.binders._"

import _root_.scala.xml.{TopScope=>$scope}
import _root_.sbt._
import _root_.sbt.Keys._
import _root_.sbt.nio.Keys._
import _root_.sbt.ScriptedPlugin.autoImport._, _root_.bloop.integrations.sbt.BloopPlugin.autoImport._, _root_.play.sbt.Play.autoImport._, _root_.play.sbt.PlayService.autoImport._, _root_.play.sbt.routes.RoutesCompiler.autoImport._, _root_.giter8.ScaffoldPlugin.autoImport._, _root_.play.twirl.sbt.SbtTwirl.autoImport._, _root_.com.typesafe.sbt.SbtNativePackager.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.JavaAppPackaging.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.JavaServerAppPackaging.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.jar.ClasspathJarPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.jar.LauncherJarPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.jlink.JlinkPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.scripts.BashStartScriptPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.scripts.BatStartScriptPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemdPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemloaderPlugin.autoImport._, _root_.com.typesafe.sbt.packager.debian.DebianPlugin.autoImport._, _root_.com.typesafe.sbt.packager.docker.DockerPlugin.autoImport._, _root_.com.typesafe.sbt.packager.graalvmnativeimage.GraalVMNativeImagePlugin.autoImport._, _root_.com.typesafe.sbt.packager.jdkpackager.JDKPackagerPlugin.autoImport._, _root_.com.typesafe.sbt.packager.linux.LinuxPlugin.autoImport._, _root_.com.typesafe.sbt.packager.rpm.RpmPlugin.autoImport._, _root_.com.typesafe.sbt.packager.universal.UniversalPlugin.autoImport._, _root_.com.typesafe.sbt.packager.windows.WindowsPlugin.autoImport._, _root_.com.lightbend.sbt.javaagent.JavaAgent.autoImport._, _root_.com.typesafe.sbt.web.SbtWeb.autoImport._, _root_.com.typesafe.sbt.jse.SbtJsEngine.autoImport._, _root_.com.typesafe.sbt.jse.SbtJsTask.autoImport._
import _root_.sbt.plugins.IvyPlugin, _root_.sbt.plugins.JvmPlugin, _root_.sbt.plugins.CorePlugin, _root_.sbt.ScriptedPlugin, _root_.sbt.plugins.SbtPlugin, _root_.sbt.plugins.SemanticdbPlugin, _root_.sbt.plugins.JUnitXmlReportPlugin, _root_.sbt.plugins.Giter8TemplatePlugin, _root_.bloop.integrations.sbt.BloopPlugin, _root_.play.sbt.Play, _root_.play.sbt.PlayAkkaHttp2Support, _root_.play.sbt.PlayAkkaHttpServer, _root_.play.sbt.PlayFilters, _root_.play.sbt.PlayJava, _root_.play.sbt.PlayLayoutPlugin, _root_.play.sbt.PlayLogback, _root_.play.sbt.PlayMinimalJava, _root_.play.sbt.PlayNettyServer, _root_.play.sbt.PlayScala, _root_.play.sbt.PlayService, _root_.play.sbt.PlayWeb, _root_.play.sbt.routes.RoutesCompiler, _root_.play.sbt.test.MediatorWorkaroundPlugin, _root_.giter8.ScaffoldPlugin, _root_.play.twirl.sbt.SbtTwirl, _root_.com.typesafe.sbt.SbtNativePackager, _root_.com.typesafe.sbt.packager.archetypes.JavaAppPackaging, _root_.com.typesafe.sbt.packager.archetypes.JavaServerAppPackaging, _root_.com.typesafe.sbt.packager.archetypes.jar.ClasspathJarPlugin, _root_.com.typesafe.sbt.packager.archetypes.jar.LauncherJarPlugin, _root_.com.typesafe.sbt.packager.archetypes.jlink.JlinkPlugin, _root_.com.typesafe.sbt.packager.archetypes.scripts.AshScriptPlugin, _root_.com.typesafe.sbt.packager.archetypes.scripts.BashStartScriptPlugin, _root_.com.typesafe.sbt.packager.archetypes.scripts.BatStartScriptPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemVPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemdPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemloaderPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.UpstartPlugin, _root_.com.typesafe.sbt.packager.debian.DebianDeployPlugin, _root_.com.typesafe.sbt.packager.debian.DebianPlugin, _root_.com.typesafe.sbt.packager.debian.JDebPackaging, _root_.com.typesafe.sbt.packager.docker.DockerPlugin, _root_.com.typesafe.sbt.packager.docker.DockerSpotifyClientPlugin, _root_.com.typesafe.sbt.packager.graalvmnativeimage.GraalVMNativeImagePlugin, _root_.com.typesafe.sbt.packager.jdkpackager.JDKPackagerDeployPlugin, _root_.com.typesafe.sbt.packager.jdkpackager.JDKPackagerPlugin, _root_.com.typesafe.sbt.packager.linux.LinuxPlugin, _root_.com.typesafe.sbt.packager.rpm.RpmDeployPlugin, _root_.com.typesafe.sbt.packager.rpm.RpmPlugin, _root_.com.typesafe.sbt.packager.universal.UniversalDeployPlugin, _root_.com.typesafe.sbt.packager.universal.UniversalPlugin, _root_.com.typesafe.sbt.packager.windows.WindowsDeployPlugin, _root_.com.typesafe.sbt.packager.windows.WindowsPlugin, _root_.com.lightbend.sbt.javaagent.JavaAgent, _root_.com.lightbend.sbt.javaagent.JavaAgentPackaging, _root_.com.typesafe.sbt.web.SbtWeb, _root_.com.typesafe.sbt.jse.SbtJsEngine, _root_.com.typesafe.sbt.jse.SbtJsTask
name := """scalabackend"""
organization := "com.example"

version := "1.0-SNAPSHOT"

lazy val root = (project in file(".")).enablePlugins(PlayScala)

scalaVersion := "2.13.3"

libraryDependencies += guice
libraryDependencies += "org.scalatestplus.play" %% "scalatestplus-play" % "5.0.0" % Test
libraryDependencies ++= Seq(
  jdbc
)
libraryDependencies ++= Seq(
  "mysql" % "mysql-connector-java" % "8.0.20"
)
// Adds additional packages into Twirl
//TwirlKeys.templateImports += "com.example.controllers._"

// Adds additional packages into conf/routes
// play.sbt.routes.RoutesKeys.routesImport += "com.example.binders._"

[0m2021.03.30 21:22:06 INFO  running '/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home/bin/java -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/metals8692720102079081304/sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'[0m
[0m2021.03.30 21:22:09 INFO  [info] welcome to sbt 1.3.13 (Oracle Corporation Java 1.8.0_201)[0m
[0m2021.03.30 21:22:10 INFO  [info] loading settings for project scalabackend-build-build-build from metals.sbt ...[0m
[0m2021.03.30 21:22:10 INFO  [info] loading project definition from /Users/davidashley/Documents/Scala/scalabackend/scalabackend/project/project/project[0m
[0m2021.03.30 21:22:12 INFO  [info] loading settings for project scalabackend-build-build from metals.sbt ...[0m
[0m2021.03.30 21:22:12 INFO  [info] loading project definition from /Users/davidashley/Documents/Scala/scalabackend/scalabackend/project/project[0m
[0m2021.03.30 21:22:14 INFO  [success] Generated .bloop/scalabackend-build-build.json[0m
[0m2021.03.30 21:22:14 INFO  [success] Total time: 2 s, completed Mar 30, 2021 9:22:14 PM[0m
[0m2021.03.30 21:22:14 INFO  [info] loading settings for project scalabackend-build from plugins.sbt,metals.sbt ...[0m
[0m2021.03.30 21:22:14 INFO  [info] loading project definition from /Users/davidashley/Documents/Scala/scalabackend/scalabackend/project[0m
[0m2021.03.30 21:22:15 INFO  [success] Generated .bloop/scalabackend-build.json[0m
[0m2021.03.30 21:22:15 INFO  [success] Total time: 1 s, completed Mar 30, 2021 9:22:16 PM[0m
[0m2021.03.30 21:22:18 INFO  [info] loading settings for project root from build.sbt ...[0m
[0m2021.03.30 21:22:18 INFO  [info] set current project to scalabackend (in build file:/Users/davidashley/Documents/Scala/scalabackend/scalabackend/)[0m
[0m2021.03.30 21:22:21 INFO  [warn] There may be incompatibilities among your library dependencies; run 'evicted' to see detailed eviction warnings.[0m
[0m2021.03.30 21:22:21 INFO  [warn] There may be incompatibilities among your library dependencies; run 'evicted' to see detailed eviction warnings.[0m
[0m2021.03.30 21:22:21 INFO  [success] Generated .bloop/root.json[0m
[0m2021.03.30 21:22:21 INFO  [success] Generated .bloop/root-test.json[0m
[0m2021.03.30 21:22:21 INFO  [success] Total time: 2 s, completed Mar 30, 2021 9:22:22 PM[0m
[0m2021.03.30 21:22:21 INFO  sbt bloopInstall exit: 0[0m
[0m2021.03.30 21:22:22 INFO  time: ran 'sbt bloopInstall' in 15s[0m
[0m2021.03.30 21:22:22 INFO  Disconnecting from Bloop session...[0m
[0m2021.03.30 21:22:22 INFO  Shut down connection with build server.[0m
[0m2021.03.30 21:22:22 INFO  Shut down connection with build server.[0m
[0m2021.03.30 21:22:22 INFO  Shut down connection with build server.[0m
No more data in the client stdin, exiting...
No more data in the client stdin, exiting...
No more data in the client stdin, exiting...
[0m2021.03.30 21:22:22 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher834887322324526086/bsp.socket'...
No more data in the server stdin, exiting...
No more data in the server stdin, exiting...
No more data in the server stdin, exiting...
No more data in the server stdin, exiting...
Waiting for the bsp connection to come up...
No more data in the server stdin, exiting...
No more data in the server stdin, exiting...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Loading 2 projects from '/Users/davidashley/Documents/Scala/scalabackend/scalabackend/.bloop'...
[0m[32m[D][0m Loading project from '/Users/davidashley/Documents/Scala/scalabackend/scalabackend/.bloop/root.json'
[0m[32m[D][0m Loading project from '/Users/davidashley/Documents/Scala/scalabackend/scalabackend/.bloop/root-test.json'
[0m[32m[D][0m Configured SemanticDB in projects 'root', 'root-test'
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher834887322324526086/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher834887322324526086/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.30 21:22:22 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.03.30 21:22:22 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
[0m2021.03.30 21:22:22 INFO  Attempting to connect to the build server...[0m
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher6152622966880247249/bsp.socket'...
Waiting for the bsp connection to come up...
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher2817062656981194887/bsp.socket'...
Waiting for the bsp connection to come up...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher6152622966880247249/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher6152622966880247249/bsp.socket...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher2817062656981194887/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher2817062656981194887/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.30 21:22:22 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.03.30 21:22:22 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.03.30 21:22:22 INFO  time: Connected to build server in 91ms[0m
[0m2021.03.30 21:22:22 INFO  Connected to Build server: Bloop v1.4.8[0m
[0m2021.03.30 21:22:23 INFO  time: indexed workspace in 1.07s[0m
import _root_.scala.xml.{TopScope=>$scope}
import _root_.sbt._
import _root_.sbt.Keys._
import _root_.sbt.nio.Keys._
import _root_.sbt.ScriptedPlugin.autoImport._, _root_.bloop.integrations.sbt.BloopPlugin.autoImport._, _root_.play.sbt.Play.autoImport._, _root_.play.sbt.PlayService.autoImport._, _root_.play.sbt.routes.RoutesCompiler.autoImport._, _root_.giter8.ScaffoldPlugin.autoImport._, _root_.play.twirl.sbt.SbtTwirl.autoImport._, _root_.com.typesafe.sbt.SbtNativePackager.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.JavaAppPackaging.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.JavaServerAppPackaging.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.jar.ClasspathJarPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.jar.LauncherJarPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.jlink.JlinkPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.scripts.BashStartScriptPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.scripts.BatStartScriptPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemdPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemloaderPlugin.autoImport._, _root_.com.typesafe.sbt.packager.debian.DebianPlugin.autoImport._, _root_.com.typesafe.sbt.packager.docker.DockerPlugin.autoImport._, _root_.com.typesafe.sbt.packager.graalvmnativeimage.GraalVMNativeImagePlugin.autoImport._, _root_.com.typesafe.sbt.packager.jdkpackager.JDKPackagerPlugin.autoImport._, _root_.com.typesafe.sbt.packager.linux.LinuxPlugin.autoImport._, _root_.com.typesafe.sbt.packager.rpm.RpmPlugin.autoImport._, _root_.com.typesafe.sbt.packager.universal.UniversalPlugin.autoImport._, _root_.com.typesafe.sbt.packager.windows.WindowsPlugin.autoImport._, _root_.com.lightbend.sbt.javaagent.JavaAgent.autoImport._, _root_.com.typesafe.sbt.web.SbtWeb.autoImport._, _root_.com.typesafe.sbt.jse.SbtJsEngine.autoImport._, _root_.com.typesafe.sbt.jse.SbtJsTask.autoImport._
import _root_.sbt.plugins.IvyPlugin, _root_.sbt.plugins.JvmPlugin, _root_.sbt.plugins.CorePlugin, _root_.sbt.ScriptedPlugin, _root_.sbt.plugins.SbtPlugin, _root_.sbt.plugins.SemanticdbPlugin, _root_.sbt.plugins.JUnitXmlReportPlugin, _root_.sbt.plugins.Giter8TemplatePlugin, _root_.bloop.integrations.sbt.BloopPlugin, _root_.play.sbt.Play, _root_.play.sbt.PlayAkkaHttp2Support, _root_.play.sbt.PlayAkkaHttpServer, _root_.play.sbt.PlayFilters, _root_.play.sbt.PlayJava, _root_.play.sbt.PlayLayoutPlugin, _root_.play.sbt.PlayLogback, _root_.play.sbt.PlayMinimalJava, _root_.play.sbt.PlayNettyServer, _root_.play.sbt.PlayScala, _root_.play.sbt.PlayService, _root_.play.sbt.PlayWeb, _root_.play.sbt.routes.RoutesCompiler, _root_.play.sbt.test.MediatorWorkaroundPlugin, _root_.giter8.ScaffoldPlugin, _root_.play.twirl.sbt.SbtTwirl, _root_.com.typesafe.sbt.SbtNativePackager, _root_.com.typesafe.sbt.packager.archetypes.JavaAppPackaging, _root_.com.typesafe.sbt.packager.archetypes.JavaServerAppPackaging, _root_.com.typesafe.sbt.packager.archetypes.jar.ClasspathJarPlugin, _root_.com.typesafe.sbt.packager.archetypes.jar.LauncherJarPlugin, _root_.com.typesafe.sbt.packager.archetypes.jlink.JlinkPlugin, _root_.com.typesafe.sbt.packager.archetypes.scripts.AshScriptPlugin, _root_.com.typesafe.sbt.packager.archetypes.scripts.BashStartScriptPlugin, _root_.com.typesafe.sbt.packager.archetypes.scripts.BatStartScriptPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemVPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemdPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemloaderPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.UpstartPlugin, _root_.com.typesafe.sbt.packager.debian.DebianDeployPlugin, _root_.com.typesafe.sbt.packager.debian.DebianPlugin, _root_.com.typesafe.sbt.packager.debian.JDebPackaging, _root_.com.typesafe.sbt.packager.docker.DockerPlugin, _root_.com.typesafe.sbt.packager.docker.DockerSpotifyClientPlugin, _root_.com.typesafe.sbt.packager.graalvmnativeimage.GraalVMNativeImagePlugin, _root_.com.typesafe.sbt.packager.jdkpackager.JDKPackagerDeployPlugin, _root_.com.typesafe.sbt.packager.jdkpackager.JDKPackagerPlugin, _root_.com.typesafe.sbt.packager.linux.LinuxPlugin, _root_.com.typesafe.sbt.packager.rpm.RpmDeployPlugin, _root_.com.typesafe.sbt.packager.rpm.RpmPlugin, _root_.com.typesafe.sbt.packager.universal.UniversalDeployPlugin, _root_.com.typesafe.sbt.packager.universal.UniversalPlugin, _root_.com.typesafe.sbt.packager.windows.WindowsDeployPlugin, _root_.com.typesafe.sbt.packager.windows.WindowsPlugin, _root_.com.lightbend.sbt.javaagent.JavaAgent, _root_.com.lightbend.sbt.javaagent.JavaAgentPackaging, _root_.com.typesafe.sbt.web.SbtWeb, _root_.com.typesafe.sbt.jse.SbtJsEngine, _root_.com.typesafe.sbt.jse.SbtJsTask
name := """scalabackend"""
organization := "com.example"

version := "1.0-SNAPSHOT"

lazy val root = (project in file(".")).enablePlugins(PlayScala)

scalaVersion := "2.13.3"

libraryDependencies += guice
libraryDependencies += "org.scalatestplus.play" %% "scalatestplus-play" % "5.0.0" % Test
libraryDependencies ++= Seq(
  jdbc
)
libraryDependencies ++= Seq(
  "mysql" % "mysql-connector-java" % "8.0.20"
)
// Adds additional packages into Twirl
//TwirlKeys.templateImports += "com.example.controllers._"

// Adds additional packages into conf/routes
// play.sbt.routes.RoutesKeys.routesImport += "com.example.binders._"

[0m2021.03.30 21:22:24 INFO  compiling root (9 scala sources and 1 java source)[0m
[0m2021.03.30 21:22:26 INFO  time: compiled root in 2.14s[0m
[0m2021.03.30 21:22:26 INFO  compiling root-test (1 scala source)[0m
[0m2021.03.30 21:22:26 INFO  time: compiled root-test in 0.23s[0m
Mar 30, 2021 9:23:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 883
[0m2021.03.31 14:03:13 INFO  shutting down Metals[0m
No more data in the client stdin, exiting...
No more data in the client stdin, exiting...
No more data in the client stdin, exiting...
[0m2021.03.31 23:05:01 INFO  Started: Metals version 0.10.0 in workspace '/Users/davidashley/Documents/Scala/scalabackend/scalabackend' for client vscode 1.54.3.[0m
[0m2021.03.31 23:05:02 INFO  time: initialize in 0.41s[0m
[0m2021.03.31 23:05:01 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
[0m2021.03.31 23:05:02 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/db/ScalaApplicationDatabase.scala[0m
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher6033149827686060361/bsp.socket'...
Waiting for the bsp connection to come up...
[0m2021.03.31 23:05:02 INFO  skipping build import with status 'Installed'[0m
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher6033149827686060361/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher6033149827686060361/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.31 23:05:03 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.03.31 23:05:03 INFO  Attempting to connect to the build server...[0m
[0m2021.03.31 23:05:03 Starting the bsp launcher for bloop...INFO  
Attempting to connect to the build server...[0m
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher816585847395897122/bsp.socket'...
Waiting for the bsp connection to come up...
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher3267946896600113873/bsp.socket'...
Waiting for the bsp connection to come up...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher816585847395897122/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher816585847395897122/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.31 23:05:03 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher3267946896600113873/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher3267946896600113873/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.31 23:05:03 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.03.31 23:05:03 INFO  time: Connected to build server in 0.68s[0m
[0m2021.03.31 23:05:03 INFO  Connected to Build server: Bloop v1.4.8[0m
[0m2021.03.31 23:05:05 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m
[0m2021.03.31 23:05:05 INFO  time: Imported build in 0.13s[0m
package db

import javax.inject.Inject
import play.api.db.Database
import akka.actor.ActorSystem
import scala.concurrent.{Future}
import models.DatabaseExecutionContext

class ScalaApplicationDatabase @Inject() (
    db: Database,
    implicit val databaseExecutionContext: DatabaseExecutionContext
) {
  def updateSomething(): Unit = {
    println("hit function")
    Future {
      db.withConnection { conn =>
        // do whatever you need with the db connection
        println("connected to database")
        val stmt = conn.createStatement()
        val insertQuery =
          "INSERT INTO `scalabackend`.`users` (`name`) VALUES ('Sarah');"
        stmt.executeUpdate(insertQuery, Array("id", "name"))
        val resultSet = stmt.getGeneratedKeys()
        println(resultSet)
      }
    }(databaseExecutionContext)
  }

}

[0m2021.03.31 23:05:07 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m
package db

import javax.inject.Inject
import play.api.db.Database
import akka.actor.ActorSystem
import scala.concurrent.{Future}
import models.DatabaseExecutionContext

class ScalaApplicationDatabase @Inject() (
    db: Database,
    implicit val databaseExecutionContext: DatabaseExecutionContext
) {
  def updateSomething(): Unit = {
    println("hit function")
    Future {
      db.withConnection { conn =>
        // do whatever you need with the db connection
        println("connected to database")
        val stmt = conn.createStatement()
        val insertQuery =
          "INSERT INTO `scalabackend`.`users` (`name`) VALUES ('Sarah');"
        stmt.executeUpdate(insertQuery, Array("id", "name"))
        val resultSet = stmt.getGeneratedKeys()
        println(resultSet)
      }
    }(databaseExecutionContext)
  }

}

[0m2021.03.31 23:05:07 INFO  time: code lens generation in 5.21s[0m
[0m2021.03.31 23:05:09 INFO  time: indexed workspace in 3.8s[0m
[0m2021.03.31 23:05:10 INFO  compiling root-test (1 scala source)[0m
[0m2021.03.31 23:05:10 INFO  time: compiled root-test in 0.35s[0m
/*
 * Copyright (C) Lightbend Inc. <https://www.lightbend.com>
 */

package play.api.db

import java.sql.Connection

import javax.sql.DataSource

/**
 * Database API.
 */
trait Database {

  /**
   * The configuration name for this database.
   */
  def name: String

  /**
   * The underlying JDBC data source for this database.
   */
  def dataSource: DataSource

  /**
   * The JDBC connection URL this database, i.e. `jdbc:...`
   * Normally retrieved via a connection.
   */
  def url: String

  /**
   * Get a JDBC connection from the underlying data source.
   * Autocommit is enabled by default.
   *
   * Don't forget to release the connection at some point by calling close().
   *
   * @return a JDBC connection
   */
  def getConnection(): Connection

  /**
   * Get a JDBC connection from the underlying data source.
   *
   * Don't forget to release the connection at some point by calling close().
   *
   * @param autocommit determines whether to autocommit the connection
   * @return a JDBC connection
   */
  def getConnection(autocommit: Boolean): Connection

  /**
   * Execute a block of code, providing a JDBC connection.
   * The connection and all created statements are automatically released.
   *
   * @param block code to execute
   * @return the result of the code block
   */
  def withConnection[A](block: Connection => A): A

  /**
   * Execute a block of code, providing a JDBC connection.
   * The connection and all created statements are automatically released.
   *
   * @param autocommit determines whether to autocommit the connection
   * @param block code to execute
   * @return the result of the code block
   */
  def withConnection[A](autocommit: Boolean)(block: Connection => A): A

  /**
   * Execute a block of code in the scope of a JDBC transaction.
   * The connection and all created statements are automatically released.
   * The transaction is automatically committed, unless an exception occurs.
   *
   * @param block code to execute
   * @return the result of the code block
   */
  def withTransaction[A](block: Connection => A): A

  /**
   * Execute a block of code in the scope of a JDBC transaction.
   * The connection and all created statements are automatically released.
   * The transaction is automatically committed, unless an exception occurs.
   *
   * @param isolationLevel determines transaction isolation level
   * @param block code to execute
   * @return the result of the code block
   */
  def withTransaction[A](isolationLevel: TransactionIsolationLevel)(block: Connection => A): A

  /**
   * Shutdown this database, closing the underlying data source.
   */
  def shutdown(): Unit
}

Mar 31, 2021 11:05:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14
/*
 * Copyright (C) 2009-2020 Lightbend Inc. <https://www.lightbend.com>
 */

package akka.actor

import java.io.Closeable
import java.util.Optional
import java.util.concurrent._
import java.util.concurrent.atomic.AtomicReference

import scala.annotation.tailrec
import scala.collection.immutable
import scala.compat.java8.FutureConverters
import scala.compat.java8.OptionConverters._
import scala.concurrent.{ ExecutionContext, ExecutionContextExecutor, Future, Promise }
import scala.concurrent.blocking
import scala.concurrent.duration.Duration
import scala.util.{ Failure, Success, Try }
import scala.util.control.{ ControlThrowable, NonFatal }

import com.typesafe.config.{ Config, ConfigFactory }

import akka.ConfigurationException
import akka.actor.dungeon.ChildrenContainer
import akka.actor.setup.{ ActorSystemSetup, Setup }
import akka.annotation.DoNotInherit
import akka.annotation.InternalApi
import akka.dispatch._
import akka.event._
import akka.event.Logging.DefaultLogger
import akka.japi.Util.immutableSeq
import akka.serialization.SerializationExtension
import akka.util._
import akka.util.Helpers.toRootLowerCase

object BootstrapSetup {

  /**
   * Scala API: Construct a bootstrap settings with default values. Note that passing that to the actor system is the
   * same as not passing any [[BootstrapSetup]] at all. You can use the returned instance to derive
   * one that has other values than defaults using the various `with`-methods.
   */
  def apply(): BootstrapSetup = {
    new BootstrapSetup()
  }

  /**
   * Scala API: Create bootstrap settings needed for starting the actor system
   *
   * @see [[BootstrapSetup]] for description of the properties
   */
  def apply(
      classLoader: Option[ClassLoader],
      config: Option[Config],
      defaultExecutionContext: Option[ExecutionContext]): BootstrapSetup =
    new BootstrapSetup(classLoader, config, defaultExecutionContext)

  /**
   * Scala API: Short for using custom config but keeping default classloader and default execution context
   */
  def apply(config: Config): BootstrapSetup = apply(None, Some(config), None)

  /**
   * Java API: Create bootstrap settings needed for starting the actor system
   *
   * @see [[BootstrapSetup]] for description of the properties
   */
  def create(
      classLoader: Optional[ClassLoader],
      config: Optional[Config],
      defaultExecutionContext: Optional[ExecutionContext]): BootstrapSetup =
    apply(classLoader.asScala, config.asScala, defaultExecutionContext.asScala)

  /**
   * Java  API: Short for using custom config but keeping default classloader and default execution context
   */
  def create(config: Config): BootstrapSetup = apply(config)

  /**
   * Java API: Construct a bootstrap settings with default values. Note that passing that to the actor system is the
   * same as not passing any [[BootstrapSetup]] at all. You can use the returned instance to derive
   * one that has other values than defaults using the various `with`-methods.
   */
  def create(): BootstrapSetup = {
    new BootstrapSetup()
  }

}

/**
 * @param identifier the simple name of the selected provider
 * @param fqcn the fully-qualified class name of the selected provider
 */
abstract class ProviderSelection private (
    private[akka] val identifier: String,
    private[akka] val fqcn: String,
    private[akka] val hasCluster: Boolean)
object ProviderSelection {
  private[akka] val RemoteActorRefProvider = "akka.remote.RemoteActorRefProvider"
  private[akka] val ClusterActorRefProvider = "akka.cluster.ClusterActorRefProvider"

  case object Local extends ProviderSelection("local", classOf[LocalActorRefProvider].getName, hasCluster = false)
  // these two cannot be referenced by class as they may not be on the classpath
  case object Remote extends ProviderSelection("remote", RemoteActorRefProvider, hasCluster = false)
  case object Cluster extends ProviderSelection("cluster", ClusterActorRefProvider, hasCluster = true)
  final case class Custom(override val fqcn: String) extends ProviderSelection("custom", fqcn, hasCluster = false)

  /**
   * JAVA API
   */
  def local(): ProviderSelection = Local

  /**
   * JAVA API
   */
  def remote(): ProviderSelection = Remote

  /**
   * JAVA API
   */
  def cluster(): ProviderSelection = Cluster

  /** INTERNAL API */
  @InternalApi private[akka] def apply(providerClass: String): ProviderSelection =
    providerClass match {
      case "local" => Local
      // additional fqcn for older configs not using 'remote' or 'cluster'
      case "remote" | RemoteActorRefProvider   => Remote
      case "cluster" | ClusterActorRefProvider => Cluster
      case fqcn                                => Custom(fqcn)
    }
}

/**
 * Core bootstrap settings of the actor system, create using one of the factories in [[BootstrapSetup]],
 * constructor is *Internal API*.
 *
 * @param classLoader If no ClassLoader is given, it obtains the current ClassLoader by first inspecting the current
 *                    threads' getContextClassLoader, then tries to walk the stack to find the callers class loader, then
 *                    falls back to the ClassLoader associated with the ActorSystem class.
 * @param config Configuration to use for the actor system. If no Config is given, the default reference config will be obtained from the ClassLoader.
 * @param defaultExecutionContext If defined the ExecutionContext will be used as the default executor inside this ActorSystem.
 *                                If no ExecutionContext is given, the system will fallback to the executor configured under
 *                                "akka.actor.default-dispatcher.default-executor.fallback".
 * @param actorRefProvider Overrides the `akka.actor.provider` setting in config, can be `local` (default), `remote` or
 *                         `cluster`. It can also be a fully qualified class name of a provider.
 */
final class BootstrapSetup private (
    val classLoader: Option[ClassLoader] = None,
    val config: Option[Config] = None,
    val defaultExecutionContext: Option[ExecutionContext] = None,
    val actorRefProvider: Option[ProviderSelection] = None)
    extends Setup {

  def withClassloader(classLoader: ClassLoader): BootstrapSetup =
    new BootstrapSetup(Some(classLoader), config, defaultExecutionContext, actorRefProvider)

  def withConfig(config: Config): BootstrapSetup =
    new BootstrapSetup(classLoader, Some(config), defaultExecutionContext, actorRefProvider)

  def withDefaultExecutionContext(executionContext: ExecutionContext): BootstrapSetup =
    new BootstrapSetup(classLoader, config, Some(executionContext), actorRefProvider)

  def withActorRefProvider(name: ProviderSelection): BootstrapSetup =
    new BootstrapSetup(classLoader, config, defaultExecutionContext, Some(name))

}

object ActorSystem {

  val Version: String = akka.Version.current // generated file

  /**
   * Creates a new ActorSystem with the name "default",
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def create(): ActorSystem = apply()

  /**
   * Creates a new ActorSystem with the specified name,
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def create(name: String): ActorSystem = apply(name)

  /**
   * Java API: Creates a new actor system with the specified name and settings
   * The core actor system settings are defined in [[BootstrapSetup]]
   */
  def create(name: String, setups: ActorSystemSetup): ActorSystem = apply(name, setups)

  /**
   * Java API: Shortcut for creating an actor system with custom bootstrap settings.
   * Same behavior as calling `ActorSystem.create(name, ActorSystemSetup.create(bootstrapSettings))`
   */
  def create(name: String, bootstrapSetup: BootstrapSetup): ActorSystem =
    create(name, ActorSystemSetup.create(bootstrapSetup))

  /**
   * Creates a new ActorSystem with the specified name, and the specified Config, then
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def create(name: String, config: Config): ActorSystem = apply(name, config)

  /**
   * Creates a new ActorSystem with the specified name, the specified Config, and specified ClassLoader
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def create(name: String, config: Config, classLoader: ClassLoader): ActorSystem = apply(name, config, classLoader)

  /**
   * Creates a new ActorSystem with the specified name, the specified Config, the specified ClassLoader,
   * and the specified ExecutionContext. The ExecutionContext will be used as the default executor inside this ActorSystem.
   * If `null` is passed in for the Config, ClassLoader and/or ExecutionContext parameters, the respective default value
   * will be used. If no Config is given, the default reference config will be obtained from the ClassLoader.
   * If no ClassLoader is given, it obtains the current ClassLoader by first inspecting the current
   * threads' getContextClassLoader, then tries to walk the stack to find the callers class loader, then
   * falls back to the ClassLoader associated with the ActorSystem class. If no ExecutionContext is given, the
   * system will fallback to the executor configured under "akka.actor.default-dispatcher.default-executor.fallback".
   * Note that the given ExecutionContext will be used by all dispatchers that have been configured with
   * executor = "default-executor", including those that have not defined the executor setting and thereby fallback
   * to the default of "default-dispatcher.executor".
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def create(
      name: String,
      config: Config,
      classLoader: ClassLoader,
      defaultExecutionContext: ExecutionContext): ActorSystem =
    apply(name, Option(config), Option(classLoader), Option(defaultExecutionContext))

  /**
   * Creates a new ActorSystem with the name "default",
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def apply(): ActorSystem = apply("default")

  /**
   * Creates a new ActorSystem with the specified name,
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   * Then it loads the default reference configuration using the ClassLoader.
   */
  def apply(name: String): ActorSystem = apply(name, None, None, None)

  /**
   * Scala API: Creates a new actor system with the specified name and settings
   * The core actor system settings are defined in [[BootstrapSetup]]
   */
  def apply(name: String, setup: ActorSystemSetup): ActorSystem = {
    val bootstrapSettings = setup.get[BootstrapSetup]
    val cl = bootstrapSettings.flatMap(_.classLoader).getOrElse(findClassLoader())
    val appConfig = bootstrapSettings.flatMap(_.config).getOrElse(ConfigFactory.load(cl))
    val defaultEC = bootstrapSettings.flatMap(_.defaultExecutionContext)

    new ActorSystemImpl(name, appConfig, cl, defaultEC, None, setup).start()
  }

  /**
   * Scala API: Shortcut for creating an actor system with custom bootstrap settings.
   * Same behavior as calling `ActorSystem(name, ActorSystemSetup(bootstrapSetup))`
   */
  def apply(name: String, bootstrapSetup: BootstrapSetup): ActorSystem =
    create(name, ActorSystemSetup.create(bootstrapSetup))

  /**
   * Creates a new ActorSystem with the specified name, and the specified Config, then
   * obtains the current ClassLoader by first inspecting the current threads' getContextClassLoader,
   * then tries to walk the stack to find the callers class loader, then falls back to the ClassLoader
   * associated with the ActorSystem class.
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def apply(name: String, config: Config): ActorSystem = apply(name, Option(config), None, None)

  /**
   * Creates a new ActorSystem with the specified name, the specified Config, and specified ClassLoader
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def apply(name: String, config: Config, classLoader: ClassLoader): ActorSystem =
    apply(name, Option(config), Option(classLoader), None)

  /**
   * Creates a new ActorSystem with the specified name,
   * the specified ClassLoader if given, otherwise obtains the current ClassLoader by first inspecting the current
   * threads' getContextClassLoader, then tries to walk the stack to find the callers class loader, then
   * falls back to the ClassLoader associated with the ActorSystem class.
   * If an ExecutionContext is given, it will be used as the default executor inside this ActorSystem.
   * If no ExecutionContext is given, the system will fallback to the executor configured under "akka.actor.default-dispatcher.default-executor.fallback".
   * The system will use the passed in config, or falls back to the default reference configuration using the ClassLoader.
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  def apply(
      name: String,
      config: Option[Config] = None,
      classLoader: Option[ClassLoader] = None,
      defaultExecutionContext: Option[ExecutionContext] = None): ActorSystem =
    apply(name, ActorSystemSetup(BootstrapSetup(classLoader, config, defaultExecutionContext)))

  /**
   * INTERNAL API
   */
  @InternalApi private[akka] object Settings {

    /**
     * INTERNAL API
     *
     * When using Akka Typed the Slf4jLogger should be used by default.
     * Looking for config property `akka.use-slf4j` (defined in akka-actor-typed) and
     * that `Slf4jLogger` (akka-slf4j) is in  classpath.
     * Then adds `Slf4jLogger` to configured loggers and removes `DefaultLogger`.
     */
    @InternalApi private[akka] def amendSlf4jConfig(config: Config, dynamicAccess: DynamicAccess): Config = {
      val slf4jLoggerClassName = "akka.event.slf4j.Slf4jLogger"
      val slf4jLoggingFilterClassName = "akka.event.slf4j.Slf4jLoggingFilter"
      val loggersConfKey = "akka.loggers"
      val loggingFilterConfKey = "akka.logging-filter"
      val configuredLoggers = immutableSeq(config.getStringList(loggersConfKey))
      val configuredLoggingFilter = config.getString(loggingFilterConfKey)

      val loggingFilterAlreadyConfigured =
        configuredLoggingFilter == slf4jLoggingFilterClassName || configuredLoggingFilter != classOf[
            DefaultLoggingFilter].getName

      def newLoggingFilterConfStr = s"""$loggingFilterConfKey = "$slf4jLoggingFilterClassName""""

      if (configuredLoggers.contains(slf4jLoggerClassName)) {
        // already configured explicitly
        if (loggingFilterAlreadyConfigured)
          config
        else
          ConfigFactory.parseString(newLoggingFilterConfStr).withFallback(config)
      } else {
        val confKey = "akka.use-slf4j"
        if (config.hasPath(confKey) && config.getBoolean(confKey) && dynamicAccess.classIsOnClasspath(
              slf4jLoggerClassName)) {
          val newLoggers = slf4jLoggerClassName +: configuredLoggers.filterNot(_ == classOf[DefaultLogger].getName)
          val newLoggersConfStr = s"$loggersConfKey = [${newLoggers.mkString("\"", "\", \"", "\"")}]"
          val newConfStr =
            if (loggingFilterAlreadyConfigured) newLoggersConfStr
            else newLoggersConfStr + "\n" + newLoggingFilterConfStr
          ConfigFactory.parseString(newConfStr).withFallback(config)
        } else
          config
      }
    }
  }

  /**
   * Settings are the overall ActorSystem Settings which also provides a convenient access to the Config object.
   *
   * For more detailed information about the different possible configuration options, look in the Akka Documentation under "Configuration"
   *
   * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
   */
  class Settings(classLoader: ClassLoader, cfg: Config, final val name: String, val setup: ActorSystemSetup) {

    def this(classLoader: ClassLoader, cfg: Config, name: String) = this(classLoader, cfg, name, ActorSystemSetup())

    /**
     * The backing Config of this ActorSystem's Settings
     *
     * @see <a href="https://lightbend.github.io/config/latest/api/index.html" target="_blank">The Typesafe Config Library API Documentation</a>
     */
    final val config: Config = {
      cfg.checkValid(
        ConfigFactory
          .defaultReference(classLoader)
          .withoutPath(Dispatchers.InternalDispatcherId), // allow this to be both string and config object
        "akka")
      cfg
    }

    import config._

    import akka.util.Helpers.ConfigOps

    final val ConfigVersion: String = getString("akka.version")

    private final val providerSelectionSetup = setup
      .get[BootstrapSetup]
      .flatMap(_.actorRefProvider)
      .map(_.identifier)
      .getOrElse(getString("akka.actor.provider"))

    final val ProviderSelectionType: ProviderSelection = ProviderSelection(providerSelectionSetup)

    final val ProviderClass: String = ProviderSelectionType.fqcn

    final val HasCluster: Boolean = ProviderSelectionType.hasCluster

    final val SupervisorStrategyClass: String = getString("akka.actor.guardian-supervisor-strategy")
    final val CreationTimeout: Timeout = Timeout(config.getMillisDuration("akka.actor.creation-timeout"))
    final val UnstartedPushTimeout: Timeout = Timeout(config.getMillisDuration("akka.actor.unstarted-push-timeout"))

    final val AllowJavaSerialization: Boolean = getBoolean("akka.actor.allow-java-serialization")
    @deprecated("Always enabled from Akka 2.6.0", "2.6.0")
    final val EnableAdditionalSerializationBindings: Boolean = true
    final val SerializeAllMessages: Boolean = getBoolean("akka.actor.serialize-messages")
    final val SerializeAllCreators: Boolean = getBoolean("akka.actor.serialize-creators")
    final val NoSerializationVerificationNeededClassPrefix: Set[String] = {
      import akka.util.ccompat.JavaConverters._
      getStringList("akka.actor.no-serialization-verification-needed-class-prefix").asScala.toSet
    }

    final val LogLevel: String = getString("akka.loglevel")
    final val StdoutLogLevel: String = getString("akka.stdout-loglevel")
    final val Loggers: immutable.Seq[String] = immutableSeq(getStringList("akka.loggers"))
    final val LoggersDispatcher: String = getString("akka.loggers-dispatcher")
    final val LoggingFilter: String = getString("akka.logging-filter")
    final val LoggerStartTimeout: Timeout = Timeout(config.getMillisDuration("akka.logger-startup-timeout"))
    final val LogConfigOnStart: Boolean = config.getBoolean("akka.log-config-on-start")
    final val LogDeadLetters: Int = toRootLowerCase(config.getString("akka.log-dead-letters")) match {
      case "off" | "false" => 0
      case "on" | "true"   => Int.MaxValue
      case _               => config.getInt("akka.log-dead-letters")
    }
    final val LogDeadLettersDuringShutdown: Boolean = config.getBoolean("akka.log-dead-letters-during-shutdown")
    final val LogDeadLettersSuspendDuration: Duration = {
      val key = "akka.log-dead-letters-suspend-duration"
      toRootLowerCase(config.getString(key)) match {
        case "infinite" => Duration.Inf
        case _          => config.getMillisDuration(key)
      }
    }

    final val AddLoggingReceive: Boolean = getBoolean("akka.actor.debug.receive")
    final val DebugAutoReceive: Boolean = getBoolean("akka.actor.debug.autoreceive")
    final val DebugLifecycle: Boolean = getBoolean("akka.actor.debug.lifecycle")
    final val FsmDebugEvent: Boolean = getBoolean("akka.actor.debug.fsm")
    final val DebugEventStream: Boolean = getBoolean("akka.actor.debug.event-stream")
    final val DebugUnhandledMessage: Boolean = getBoolean("akka.actor.debug.unhandled")
    final val DebugRouterMisconfiguration: Boolean = getBoolean("akka.actor.debug.router-misconfiguration")

    final val Home: Option[String] = config.getString("akka.home") match {
      case "" => None
      case x  => Some(x)
    }

    final val SchedulerClass: String = getString("akka.scheduler.implementation")
    final val Daemonicity: Boolean = getBoolean("akka.daemonic")
    final val JvmExitOnFatalError: Boolean = getBoolean("akka.jvm-exit-on-fatal-error")
    final val JvmShutdownHooks: Boolean = getBoolean("akka.jvm-shutdown-hooks")
    final val FailMixedVersions: Boolean = getBoolean("akka.fail-mixed-versions")

    final val CoordinatedShutdownTerminateActorSystem: Boolean = getBoolean(
      "akka.coordinated-shutdown.terminate-actor-system")
    final val CoordinatedShutdownRunByActorSystemTerminate: Boolean = getBoolean(
      "akka.coordinated-shutdown.run-by-actor-system-terminate")
    if (CoordinatedShutdownRunByActorSystemTerminate && !CoordinatedShutdownTerminateActorSystem)
      throw new ConfigurationException(
        "akka.coordinated-shutdown.run-by-actor-system-terminate=on and " +
        "akka.coordinated-shutdown.terminate-actor-system=off is not a supported configuration combination.")

    final val DefaultVirtualNodesFactor: Int = getInt("akka.actor.deployment.default.virtual-nodes-factor")

    if (ConfigVersion != Version)
      throw new akka.ConfigurationException(
        "Akka JAR version [" + Version + "] does not match the provided config version [" + ConfigVersion + "]")

    /**
     * Returns the String representation of the Config that this Settings is backed by
     */
    override def toString: String = config.root.render

  }

  private[akka] def findClassLoader(): ClassLoader = Reflect.findClassLoader()
}

/**
 * An actor system is a hierarchical group of actors which share common
 * configuration, e.g. dispatchers, deployments, remote capabilities and
 * addresses. It is also the entry point for creating or looking up actors.
 *
 * There are several possibilities for creating actors (see [[akka.actor.Props]]
 * for details on `props`):
 *
 * {{{
 * // Java or Scala
 * system.actorOf(props, "name")
 * system.actorOf(props)
 *
 * // Scala
 * system.actorOf(Props[MyActor], "name")
 * system.actorOf(Props(classOf[MyActor], arg1, arg2), "name")
 *
 * // Java
 * system.actorOf(Props.create(MyActor.class), "name");
 * system.actorOf(Props.create(MyActor.class, arg1, arg2), "name");
 * }}}
 *
 * Where no name is given explicitly, one will be automatically generated.
 *
 * <b><i>Important Notice:</i></b>
 *
 * This class is not meant to be extended by user code. If you want to
 * actually roll your own Akka, it will probably be better to look into
 * extending [[akka.actor.ExtendedActorSystem]] instead, but beware that you
 * are completely on your own in that case!
 */
abstract class ActorSystem extends ActorRefFactory with ClassicActorSystemProvider {
  import ActorSystem._

  /**
   * The name of this actor system, used to distinguish multiple ones within
   * the same JVM & class loader.
   */
  def name: String

  /**
   * The core settings extracted from the supplied configuration.
   */
  def settings: Settings

  /**
   * Log the configuration.
   */
  def logConfiguration(): Unit

  /**
   * Construct a path below the application guardian to be used with [[ActorSystem#actorSelection]].
   */
  def /(name: String): ActorPath

  /**
   * Java API: Create a new child actor path.
   */
  def child(child: String): ActorPath = /(child)

  /**
   * Construct a path below the application guardian to be used with [[ActorSystem#actorSelection]].
   */
  def /(name: Iterable[String]): ActorPath

  /**
   * Java API: Recursively create a descendant’s path by appending all child names.
   */
  def descendant(names: java.lang.Iterable[String]): ActorPath = /(immutableSeq(names))

  /**
   * Start-up time in milliseconds since the epoch.
   */
  val startTime: Long = System.currentTimeMillis

  /**
   * Up-time of this actor system in seconds.
   */
  def uptime: Long = (System.currentTimeMillis - startTime) / 1000

  /**
   * Main event bus of this actor system, used for example for logging.
   */
  def eventStream: EventStream

  /**
   * Java API: Main event bus of this actor system, used for example for logging.
   */
  def getEventStream: EventStream = eventStream

  /**
   * Convenient logging adapter for logging to the [[ActorSystem#eventStream]].
   */
  def log: LoggingAdapter

  /**
   * Actor reference where messages are re-routed to which were addressed to
   * stopped or non-existing actors. Delivery to this actor is done on a best
   * effort basis and hence not strictly guaranteed.
   */
  def deadLetters: ActorRef

  /**
   * Light-weight scheduler for running asynchronous tasks after some deadline
   * in the future. Not terribly precise but cheap.
   */
  def scheduler: Scheduler

  /**
   * Java API: Light-weight scheduler for running asynchronous tasks after some deadline
   * in the future. Not terribly precise but cheap.
   */
  def getScheduler: Scheduler = scheduler

  /**
   * Helper object for looking up configured dispatchers.
   */
  def dispatchers: Dispatchers

  /**
   * Default dispatcher as configured. This dispatcher is used for all actors
   * in the actor system which do not have a different dispatcher configured
   * explicitly.
   * Importing this member will place the default MessageDispatcher in scope.
   */
  implicit def dispatcher: ExecutionContextExecutor

  /**
   * Java API: Default dispatcher as configured. This dispatcher is used for all actors
   * in the actor system which do not have a different dispatcher configured
   * explicitly.
   * Importing this member will place the default MessageDispatcher in scope.
   */
  def getDispatcher: ExecutionContextExecutor = dispatcher

  /**
   * Helper object for looking up configured mailbox types.
   */
  def mailboxes: Mailboxes

  /**
   * Register a block of code (callback) to run after [[ActorSystem.terminate]] has been issued and
   * all actors in this actor system have been stopped.
   * Multiple code blocks may be registered by calling this method multiple times.
   * The callbacks will be run sequentially in reverse order of registration, i.e.
   * last registration is run first.
   * Note that ActorSystem will not terminate until all the registered callbacks are finished.
   *
   * Throws a RejectedExecutionException if the System has already been terminated or if termination has been initiated.
   *
   * Scala API
   */
  def registerOnTermination[T](code: => T): Unit

  /**
   * Java API: Register a block of code (callback) to run after [[ActorSystem.terminate]] has been issued and
   * all actors in this actor system have been stopped.
   * Multiple code blocks may be registered by calling this method multiple times.
   * The callbacks will be run sequentially in reverse order of registration, i.e.
   * last registration is run first.
   * Note that ActorSystem will not terminate until all the registered callbacks are finished.
   *
   * Throws a RejectedExecutionException if the System has already been terminated or if termination has been initiated.
   */
  def registerOnTermination(code: Runnable): Unit

  /**
   * Terminates this actor system by running [[CoordinatedShutdown]] with reason
   * [[CoordinatedShutdown.ActorSystemTerminateReason]].
   *
   * If `akka.coordinated-shutdown.run-by-actor-system-terminate` is configured to `off`
   * it will not run `CoordinatedShutdown`, but the `ActorSystem` and its actors
   * will still be terminated.
   *
   * This will stop the guardian actor, which in turn
   * will recursively stop all its child actors, and finally the system guardian
   * (below which the logging actors reside) and then execute all registered
   * termination handlers (see [[ActorSystem#registerOnTermination]]).
   * Be careful to not schedule any operations on completion of the returned future
   * using the dispatcher of this actor system as it will have been shut down before the
   * future completes.
   */
  def terminate(): Future[Terminated]

  /**
   * Returns a Future which will be completed after the ActorSystem has been terminated
   * and termination hooks have been executed. If you registered any callback with
   * [[ActorSystem#registerOnTermination]], the returned Future from this method will not complete
   * until all the registered callbacks are finished. Be careful to not schedule any operations,
   * such as `onComplete`, on the dispatchers (`ExecutionContext`) of this actor system as they
   * will have been shut down before this future completes.
   */
  def whenTerminated: Future[Terminated]

  /**
   * Returns a CompletionStage which will be completed after the ActorSystem has been terminated
   * and termination hooks have been executed. If you registered any callback with
   * [[ActorSystem#registerOnTermination]], the returned CompletionStage from this method will not complete
   * until all the registered callbacks are finished. Be careful to not schedule any operations,
   * such as `thenRunAsync`, on the dispatchers (`Executor`) of this actor system as they
   * will have been shut down before this CompletionStage completes.
   */
  def getWhenTerminated: CompletionStage[Terminated]

  /**
   * Registers the provided extension and creates its payload, if this extension isn't already registered
   * This method has putIfAbsent-semantics, this method can potentially block, waiting for the initialization
   * of the payload, if is in the process of registration from another Thread of execution
   */
  def registerExtension[T <: Extension](ext: ExtensionId[T]): T

  /**
   * Returns the payload that is associated with the provided extension
   * throws an IllegalStateException if it is not registered.
   * This method can potentially block, waiting for the initialization
   * of the payload, if is in the process of registration from another Thread of execution
   */
  def extension[T <: Extension](ext: ExtensionId[T]): T

  /**
   * Returns whether the specified extension is already registered, this method can potentially block, waiting for the initialization
   * of the payload, if is in the process of registration from another Thread of execution
   */
  def hasExtension(ext: ExtensionId[_ <: Extension]): Boolean
}

/**
 * More powerful interface to the actor system’s implementation which is presented to extensions (see [[akka.actor.Extension]]).
 *
 * <b><i>Important Notice:</i></b>
 *
 * This class is not meant to be extended by user code. If you want to
 * actually roll your own Akka, beware that you are completely on your own in
 * that case!
 */
@DoNotInherit
abstract class ExtendedActorSystem extends ActorSystem {

  /**
   * The ActorRefProvider is the only entity which creates all actor references within this actor system.
   */
  def provider: ActorRefProvider

  /**
   * The top-level supervisor of all actors created using system.actorOf(...).
   */
  def guardian: InternalActorRef

  /**
   * The top-level supervisor of all system-internal services like logging.
   */
  def systemGuardian: InternalActorRef

  /**
   * Create an actor in the "/system" namespace. This actor will be shut down
   * during system.terminate only after all user actors have terminated.
   *
   * This is only intended to be used by libraries (and Akka itself).
   * Applications should use ordinary `actorOf`.
   */
  def systemActorOf(props: Props, name: String): ActorRef

  /**
   * A ThreadFactory that can be used if the transport needs to create any Threads
   */
  def threadFactory: ThreadFactory

  /**
   * ClassLoader wrapper which is used for reflective accesses internally. This is set
   * to use the context class loader, if one is set, or the class loader which
   * loaded the ActorSystem implementation. The context class loader is also
   * set on all threads created by the ActorSystem, if one was set during
   * creation.
   */
  def dynamicAccess: DynamicAccess

  /**
   * Filter of log events that is used by the LoggingAdapter before
   * publishing log events to the eventStream
   */
  def logFilter: LoggingFilter

  /**
   * For debugging: traverse actor hierarchy and make string representation.
   * Careful, this may OOM on large actor systems, and it is only meant for
   * helping debugging in case something already went terminally wrong.
   */
  private[akka] def printTree: String

  /**
   * INTERNAL API: final step of `terminate()`
   */
  @InternalApi private[akka] def finalTerminate(): Unit

  /**
   * INTERNAL API
   */
  @InternalApi private[akka] def isTerminating(): Boolean

}

/**
 * Internal API
 */
@InternalApi
private[akka] class ActorSystemImpl(
    val name: String,
    applicationConfig: Config,
    classLoader: ClassLoader,
    defaultExecutionContext: Option[ExecutionContext],
    val guardianProps: Option[Props],
    setup: ActorSystemSetup)
    extends ExtendedActorSystem {

  if (!name.matches("""^[a-zA-Z0-9][a-zA-Z0-9-_]*$"""))
    throw new IllegalArgumentException(
      "invalid ActorSystem name [" + name +
      "], must contain only word characters (i.e. [a-zA-Z0-9] plus non-leading '-' or '_')")

  import ActorSystem._

  @volatile private var logDeadLetterListener: Option[ActorRef] = None

  private val _dynamicAccess: DynamicAccess = createDynamicAccess()

  final val settings: Settings = {
    val config = Settings.amendSlf4jConfig(
      applicationConfig.withFallback(ConfigFactory.defaultReference(classLoader)),
      _dynamicAccess)
    new Settings(classLoader, config, name, setup)
  }

  protected def uncaughtExceptionHandler: Thread.UncaughtExceptionHandler =
    new Thread.UncaughtExceptionHandler() {
      def uncaughtException(thread: Thread, cause: Throwable): Unit = {
        cause match {
          case NonFatal(_) | _: InterruptedException | _: NotImplementedError | _: ControlThrowable =>
            log.error(cause, "Uncaught error from thread [{}]", thread.getName)
          case _ =>
            if (cause.isInstanceOf[IncompatibleClassChangeError] && cause.getMessage.startsWith("akka"))
              System.err.println(
                s"""Detected ${cause.getClass.getName} error, which MAY be caused by incompatible Akka versions on the classpath.
                  | Please note that a given Akka version MUST be the same across all modules of Akka that you are using,
                  | e.g. if you use akka-actor [${akka.Version.current} (resolved from current classpath)] all other core
                  | Akka modules MUST be of the same version. External projects like Alpakka, Persistence plugins or Akka
                  | HTTP etc. have their own version numbers - please make sure you're using a compatible set of libraries.
                 """.stripMargin.replaceAll("[\r\n]", ""))

            if (settings.JvmExitOnFatalError)
              try logFatalError("shutting down JVM since 'akka.jvm-exit-on-fatal-error' is enabled for", cause, thread)
              finally System.exit(-1)
            else
              try logFatalError("shutting down", cause, thread)
              finally terminate()
        }
      }

      @inline
      private def logFatalError(message: String, cause: Throwable, thread: Thread): Unit = {
        // First log to stderr as this has the best chance to get through in an 'emergency panic' situation:
        import System.err
        err.print("Uncaught error from thread [")
        err.print(thread.getName)
        err.print("]: ")
        err.print(cause.getMessage)
        err.print(", ")
        err.print(message)
        err.print(" ActorSystem[")
        err.print(name)
        err.println("]")
        System.err.flush()
        cause.printStackTrace(System.err)
        System.err.flush()

        // Also log using the normal infrastructure - hope for the best:
        markerLogging.error(
          LogMarker.Security,
          cause,
          "Uncaught error from thread [{}]: " + cause.getMessage + ", " + message + " ActorSystem[{}]",
          thread.getName,
          name)
      }
    }

  final val threadFactory: MonitorableThreadFactory =
    MonitorableThreadFactory(name, settings.Daemonicity, Option(classLoader), uncaughtExceptionHandler)

  /**
   * This is an extension point: by overriding this method, subclasses can
   * control all reflection activities of an actor system.
   */
  protected def createDynamicAccess(): DynamicAccess = new ReflectiveDynamicAccess(classLoader)

  def dynamicAccess: DynamicAccess = _dynamicAccess

  def logConfiguration(): Unit = log.info(settings.toString)

  protected def systemImpl: ActorSystemImpl = this

  def systemActorOf(props: Props, name: String): ActorRef =
    systemGuardian.underlying.attachChild(props, name, systemService = true)

  def actorOf(props: Props, name: String): ActorRef =
    if (guardianProps.isEmpty) guardian.underlying.attachChild(props, name, systemService = false)
    else
      throw new UnsupportedOperationException(
        s"cannot create top-level actor [$name] from the outside on ActorSystem with custom user guardian")

  def actorOf(props: Props): ActorRef =
    if (guardianProps.isEmpty) guardian.underlying.attachChild(props, systemService = false)
    else
      throw new UnsupportedOperationException(
        "cannot create top-level actor from the outside on ActorSystem with custom user guardian")

  def stop(actor: ActorRef): Unit = {
    val path = actor.path
    val guard = guardian.path
    val sys = systemGuardian.path
    path.parent match {
      case `guard` => guardian ! StopChild(actor)
      case `sys`   => systemGuardian ! StopChild(actor)
      case _       => actor.asInstanceOf[InternalActorRef].stop()
    }
  }

  import settings._

  // this provides basic logging (to stdout) until .start() is called below
  val eventStream = new EventStream(this, DebugEventStream)
  eventStream.startStdoutLogger(settings)

  val logFilter: LoggingFilter = {
    val arguments = Vector(classOf[Settings] -> settings, classOf[EventStream] -> eventStream)
    dynamicAccess.createInstanceFor[LoggingFilter](LoggingFilter, arguments).get
  }

  private[this] val markerLogging =
    new MarkerLoggingAdapter(eventStream, getClass.getName + "(" + name + ")", this.getClass, logFilter)
  val log: LoggingAdapter = markerLogging

  val scheduler: Scheduler = createScheduler()

  val provider: ActorRefProvider = try {
    val arguments = Vector(
      classOf[String] -> name,
      classOf[Settings] -> settings,
      classOf[EventStream] -> eventStream,
      classOf[DynamicAccess] -> dynamicAccess)

    dynamicAccess.createInstanceFor[ActorRefProvider](ProviderClass, arguments).get
  } catch {
    case NonFatal(e) =>
      Try(stopScheduler())
      throw e
  }

  def deadLetters: ActorRef = provider.deadLetters

  val mailboxes: Mailboxes = new Mailboxes(settings, eventStream, dynamicAccess, deadLetters)

  val dispatchers: Dispatchers = new Dispatchers(
    settings,
    DefaultDispatcherPrerequisites(
      threadFactory,
      eventStream,
      scheduler,
      dynamicAccess,
      settings,
      mailboxes,
      defaultExecutionContext),
    log)

  val dispatcher: ExecutionContextExecutor = dispatchers.defaultGlobalDispatcher

  private[this] final val terminationCallbacks = new TerminationCallbacks(provider.terminationFuture)(dispatcher)

  override def whenTerminated: Future[Terminated] = terminationCallbacks.terminationFuture
  override def getWhenTerminated: CompletionStage[Terminated] = FutureConverters.toJava(whenTerminated)
  def lookupRoot: InternalActorRef = provider.rootGuardian
  def guardian: LocalActorRef = provider.guardian
  def systemGuardian: LocalActorRef = provider.systemGuardian

  def /(actorName: String): ActorPath = guardian.path / actorName
  def /(path: Iterable[String]): ActorPath = guardian.path / path

  override def classicSystem: ActorSystem = this

  // Used for ManifestInfo.checkSameVersion
  private def allModules: List[String] =
    List(
      "akka-actor",
      "akka-actor-testkit-typed",
      "akka-actor-typed",
      "akka-cluster",
      "akka-cluster-metrics",
      "akka-cluster-sharding",
      "akka-cluster-sharding-typed",
      "akka-cluster-tools",
      "akka-cluster-typed",
      "akka-coordination",
      "akka-discovery",
      "akka-distributed-data",
      "akka-testkit",
      "akka-multi-node-testkit",
      "akka-osgi",
      "akka-persistence",
      "akka-persistence-query",
      "akka-persistence-shared",
      "akka-persistence-testkit",
      "akka-persistence-typed",
      "akka-pki",
      "akka-protobuf",
      "akka-protobuf-v3",
      "akka-remote",
      "akka-serialization-jackson",
      "akka-slf4j",
      "akka-stream",
      "akka-stream-testkit",
      "akka-stream-typed",
      "akka-stream-testkit")

  @volatile private var _initialized = false

  /**
   *  Asserts that the ActorSystem has been fully initialized. Can be used to guard code blocks that might accidentally
   *  be run during initialization but require a fully initialized ActorSystem before proceeding.
   */
  def assertInitialized(): Unit =
    if (!_initialized)
      throw new IllegalStateException(
        "The calling code expected that the ActorSystem was initialized but it wasn't yet. " +
        "This is probably a bug in the ActorSystem initialization sequence often related to initialization of extensions. " +
        "Please report at https://github.com/akka/akka/issues.")
  private lazy val _start: this.type = try {

    registerOnTermination(stopScheduler())
    // the provider is expected to start default loggers, LocalActorRefProvider does this
    provider.init(this)
    // at this point it should be initialized "enough" for most extensions that we might want to guard against otherwise
    _initialized = true

    if (settings.LogDeadLetters > 0)
      logDeadLetterListener = Some(systemActorOf(Props[DeadLetterListener](), "deadLetterListener"))
    eventStream.startUnsubscriber()
    ManifestInfo(this).checkSameVersion("Akka", allModules, logWarning = true)
    if (!terminating)
      loadExtensions()
    if (LogConfigOnStart) logConfiguration()
    this
  } catch {
    case NonFatal(e) =>
      try terminate()
      catch { case NonFatal(_) => Try(stopScheduler()) }
      throw e
  }

  def start(): this.type = _start
  def registerOnTermination[T](code: => T): Unit = { registerOnTermination(new Runnable { def run = code }) }
  def registerOnTermination(code: Runnable): Unit = { terminationCallbacks.add(code) }

  @volatile private var terminating = false

  override def terminate(): Future[Terminated] = {
    terminating = true
    if (settings.CoordinatedShutdownRunByActorSystemTerminate && !aborting) {
      // Note that the combination CoordinatedShutdownRunByActorSystemTerminate==true &&
      // CoordinatedShutdownTerminateActorSystem==false is disallowed, checked in Settings.
      // It's not a combination that is valuable to support and it would be complicated to
      // protect against concurrency race conditions between calls to ActorSystem.terminate()
      // and CoordinateShutdown.run()

      // it will call finalTerminate() at the end
      CoordinatedShutdown(this).run(CoordinatedShutdown.ActorSystemTerminateReason)
    } else {
      finalTerminate()
    }
    whenTerminated
  }

  override private[akka] def finalTerminate(): Unit = {
    terminating = true
    // these actions are idempotent
    if (!settings.LogDeadLettersDuringShutdown) logDeadLetterListener.foreach(stop)
    guardian.stop()
  }

  override private[akka] def isTerminating(): Boolean = {
    terminating || aborting || CoordinatedShutdown(this).shutdownReason().isDefined
  }

  @volatile var aborting = false

  /**
   * This kind of shutdown attempts to bring the system down and release its
   * resources more forcefully than plain shutdown. For example it will not
   * run CoordinatedShutdown and not wait for remote-deployed child actors to
   * terminate before terminating their parents.
   */
  def abort(): Unit = {
    aborting = true
    terminate()
  }

  //#create-scheduler
  /**
   * Create the scheduler service. This one needs one special behavior: if
   * Closeable, it MUST execute all outstanding tasks upon .close() in order
   * to properly shutdown all dispatchers.
   *
   * Furthermore, this timer service MUST throw IllegalStateException if it
   * cannot schedule a task. Once scheduled, the task MUST be executed. If
   * executed upon close(), the task may execute before its timeout.
   */
  protected def createScheduler(): Scheduler =
    dynamicAccess
      .createInstanceFor[Scheduler](
        settings.SchedulerClass,
        immutable.Seq(
          classOf[Config] -> settings.config,
          classOf[LoggingAdapter] -> log,
          classOf[ThreadFactory] -> threadFactory.withName(threadFactory.name + "-scheduler")))
      .get
  //#create-scheduler

  /*
   * This is called after the last actor has signaled its termination, i.e.
   * after the last dispatcher has had its chance to schedule its shutdown
   * action.
   */
  protected def stopScheduler(): Unit = scheduler match {
    case x: Closeable => x.close()
    case _            =>
  }

  // For each ExtensionId, either:
  // 1) a CountDownLatch (if it's still in the process of being registered),
  // 2) a Throwable (if it failed initializing), or
  // 3) the registered extension.
  private val extensions = new ConcurrentHashMap[ExtensionId[_], AnyRef]

  /**
   * Returns any extension registered to the specified Extension or returns null if not registered
   */
  @tailrec
  private def findExtension[T <: Extension](ext: ExtensionId[T]): T = extensions.get(ext) match {
    case c: CountDownLatch =>
      blocking {
        val awaitMillis = settings.CreationTimeout.duration.toMillis
        if (!c.await(awaitMillis, TimeUnit.MILLISECONDS))
          throw new IllegalStateException(
            s"Initialization of [$ext] took more than [$awaitMillis ms]. " +
            (if (ext == SerializationExtension)
               "A serializer must not access the SerializationExtension from its constructor. Use lazy init."
             else "Could be deadlock due to cyclic initialization of extensions."))
      }
      findExtension(ext) //Registration in process, await completion and retry
    case t: Throwable => throw t //Initialization failed, throw same again
    case other =>
      other.asInstanceOf[T] //could be a T or null, in which case we return the null as T
  }

  @tailrec
  final def registerExtension[T <: Extension](ext: ExtensionId[T]): T = {
    findExtension(ext) match {
      case null => //Doesn't already exist, commence registration
        val inProcessOfRegistration = new CountDownLatch(1)
        extensions.putIfAbsent(ext, inProcessOfRegistration) match { // Signal that registration is in process
          case null =>
            try { // Signal was successfully sent
              ext.createExtension(this) match { // Create and initialize the extension
                case null =>
                  throw new IllegalStateException(s"Extension instance created as 'null' for extension [$ext]")
                case instance =>
                  extensions.replace(ext, inProcessOfRegistration, instance) //Replace our in process signal with the initialized extension
                  instance //Profit!
              }
            } catch {
              case t: Throwable =>
                extensions.replace(ext, inProcessOfRegistration, t) //In case shit hits the fan, remove the inProcess signal
                throw t //Escalate to caller
            } finally {
              inProcessOfRegistration.countDown() //Always notify listeners of the inProcess signal
            }
          case _ =>
            registerExtension(ext) //Someone else is in process of registering an extension for this Extension, retry
        }
      case existing => existing.asInstanceOf[T]
    }
  }

  def extension[T <: Extension](ext: ExtensionId[T]): T = findExtension(ext) match {
    case null => throw new IllegalArgumentException(s"Trying to get non-registered extension [$ext]")
    case some => some.asInstanceOf[T]
  }

  def hasExtension(ext: ExtensionId[_ <: Extension]): Boolean = findExtension(ext) != null

  private def loadExtensions(): Unit = {

    /*
     * @param throwOnLoadFail
     *  Throw exception when an extension fails to load (needed for backwards compatibility.
     *    when the extension cannot be found at all we throw regardless of this setting)
     */
    def loadExtensions(key: String, throwOnLoadFail: Boolean): Unit = {

      immutableSeq(settings.config.getStringList(key)).foreach { fqcn =>
        dynamicAccess.getObjectFor[AnyRef](fqcn).recoverWith {
          case firstProblem =>
            dynamicAccess.createInstanceFor[AnyRef](fqcn, Nil).recoverWith { case _ => Failure(firstProblem) }
        } match {
          case Success(p: ExtensionIdProvider) =>
            registerExtension(p.lookup)
          case Success(p: ExtensionId[_]) =>
            registerExtension(p)
          case Success(_) =>
            if (!throwOnLoadFail) log.error("[{}] is not an 'ExtensionIdProvider' or 'ExtensionId', skipping...", fqcn)
            else throw new RuntimeException(s"[$fqcn] is not an 'ExtensionIdProvider' or 'ExtensionId'")
          case Failure(problem) =>
            if (!throwOnLoadFail) log.error(problem, "While trying to load extension [{}], skipping...", fqcn)
            else throw new RuntimeException(s"While trying to load extension [$fqcn]", problem)
        }
      }
    }

    loadExtensions("akka.library-extensions", throwOnLoadFail = true)
    loadExtensions("akka.extensions", throwOnLoadFail = false)
  }

  override def toString: String = lookupRoot.path.root.address.toString

  override def printTree: String = {
    def printNode(node: ActorRef, indent: String): String = {
      node match {
        case wc: ActorRefWithCell =>
          val cell = wc.underlying
          (if (indent.isEmpty) "-> " else indent.dropRight(1) + "⌊-> ") +
          node.path.name + " " + Logging.simpleName(node) + " " +
          (cell match {
            case real: ActorCell =>
              val realActor = real.actor
              if (realActor ne null) realActor.getClass else "null"
            case _ => Logging.simpleName(cell)
          }) +
          (cell match {
            case real: ActorCell => " status=" + real.mailbox.currentStatus
            case _               => ""
          }) +
          " " + (cell.childrenRefs match {
            case ChildrenContainer.TerminatingChildrenContainer(_, toDie, reason) =>
              "Terminating(" + reason + ")" +
              (toDie.toSeq.sorted.mkString("\n" + indent + "   |    toDie: ", "\n" + indent + "   |           ", ""))
            case x @ (ChildrenContainer.TerminatedChildrenContainer | ChildrenContainer.EmptyChildrenContainer) =>
              x.toString
            case n: ChildrenContainer.NormalChildrenContainer => n.c.size.toString + " children"
            case x                                            => Logging.simpleName(x)
          }) +
          (if (cell.childrenRefs.children.isEmpty) "" else "\n") +
          ({
            val children = cell.childrenRefs.children.toSeq.sorted
            val bulk = children.dropRight(1).map(printNode(_, indent + "   |"))
            bulk ++ (children.lastOption.map(printNode(_, indent + "    ")))
          }.mkString("\n"))
        case _ =>
          indent + node.path.name + " " + Logging.simpleName(node)
      }
    }
    printNode(lookupRoot, "")
  }

  final class TerminationCallbacks[T](upStreamTerminated: Future[T])(implicit ec: ExecutionContext) {
    private[this] final val done = Promise[T]()
    private[this] final val ref = new AtomicReference(done)

    // onComplete never fires twice so safe to avoid null check
    upStreamTerminated.onComplete { t =>
      ref.getAndSet(null).complete(t)
    }

    /**
     * Adds a Runnable that will be executed on ActorSystem termination.
     * Note that callbacks are executed in reverse order of insertion.
     *
     * @param r The callback to be executed on ActorSystem termination
     * Throws RejectedExecutionException if called after ActorSystem has been terminated.
     */
    final def add(r: Runnable): Unit = {
      @tailrec def addRec(r: Runnable, p: Promise[T]): Unit = ref.get match {
        case null                               => throw new RejectedExecutionException("ActorSystem already terminated.")
        case some if ref.compareAndSet(some, p) => some.completeWith(p.future.andThen { case _ => r.run() })
        case _                                  => addRec(r, p)
      }
      addRec(r, Promise[T]())
    }

    /**
     * Returns a Future which will be completed once all registered callbacks have been executed.
     */
    def terminationFuture: Future[T] = done.future
  }
}

/*
 * Copyright (C) Lightbend Inc. <https://www.lightbend.com>
 */

package play.api.mvc

import javax.inject.Inject
import play.api.data.FormBinding
import play.api.http._
import play.api.i18n.Langs
import play.api.i18n.MessagesApi
import play.twirl.api.Html

import scala.concurrent.ExecutionContext

/**
 * Useful mixins for controller classes.
 *
 * If you wish to write a controller with minimal dependencies, you can mix in this trait, which includes helpers and
 * useful constants.
 *
 * {{{
 *   class MyController @Inject() (action: DefaultActionBuilder, parse: PlayBodyParsers) extends ControllerHelpers {
 *     def index = action(parse.text) {
 *       Ok
 *     }
 *   }
 * }}}
 */
trait ControllerHelpers
    extends Results
    with HttpProtocol
    with Status
    with HeaderNames
    with ContentTypes
    with RequestExtractors
    with Rendering
    with RequestImplicits {

  /**
   * Used to mark an action that is still not implemented, e.g.:
   *
   * {{{
   *   def action(query: String) = TODO
   * }}}
   */
  lazy val TODO: Action[AnyContent] = ActionBuilder.ignoringBody { implicit request =>
    NotImplemented[Html](views.html.defaultpages.todo())
  }
}

object ControllerHelpers extends ControllerHelpers

/**
 * Useful prewired mixins for controller components, assuming an available [[ControllerComponents]].
 *
 * If you want to extend your own [[AbstractController]] but want to use a different base "Action",
 * you can mix in this trait.
 */
trait BaseControllerHelpers extends ControllerHelpers {

  /**
   * The components needed to use the controller methods
   */
  protected def controllerComponents: ControllerComponents

  /**
   * The default body parsers provided by Play. This can be used along with the Action helper to customize the body
   * parser, for example:
   *
   * {{{
   *   def foo(query: String) = Action(parse.tolerantJson) { request =>
   *     Ok(request.body)
   *   }
   * }}}
   */
  def parse: PlayBodyParsers = controllerComponents.parsers

  implicit lazy val defaultFormBinding: FormBinding = parse.formBinding(parse.DefaultMaxTextLength)

  /**
   * The default execution context provided by Play. You should use this for non-blocking code only. You can do so by
   * passing it explicitly, or by defining an implicit in your controller like so:
   *
   * {{{
   *   implicit lazy val executionContext = defaultExecutionContext
   * }}}
   */
  def defaultExecutionContext: ExecutionContext = controllerComponents.executionContext

  /**
   * The MessagesApi provided by Play. This can be used to provide the MessagesApi needed by play.api.i18n.I18nSupport.
   */
  implicit def messagesApi: MessagesApi = controllerComponents.messagesApi

  /**
   * The default Langs provided by Play. Can be used to determine the application's supported languages.
   */
  implicit def supportedLangs: Langs = controllerComponents.langs

  /**
   * The default FileMimeTypes provided by Play. Used to map between file name extensions and mime types.
   */
  implicit def fileMimeTypes: FileMimeTypes = controllerComponents.fileMimeTypes
}

/**
 * Useful mixin for methods that do implicit transformations of a request
 */
trait RequestImplicits {

  /**
   * Retrieves the session implicitly from the request.
   *
   * For example:
   * {{{
   * def index(name:String) = Action { implicit request =>
   *   val username = request2session("username")
   *   Ok("Hello " + username)
   * }
   * }}}
   */
  implicit def request2session(implicit request: RequestHeader): Session = request.session

  /**
   * Retrieve the flash scope implicitly from the request.
   *
   * For example:
   * {{{
   * def index(name:String) = Action { implicit request =>
   *   val message = request2flash("message")
   *   Ok("Got " + message)
   * }
   * }}}
   */
  implicit def request2flash(implicit request: RequestHeader): Flash = request.flash
}

/**
 * Defines utility methods to generate `Action` and `Results` types.
 *
 * For example:
 * {{{
 * class HomeController @Inject() (val controllerComponents: ControllerComponents) extends BaseController {
 *
 *   def hello(name:String) = Action { request =>
 *     Ok("Hello " + name)
 *   }
 *
 * }
 * }}}
 *
 *
 * This is intended to provide the idiomatic Play API for actions, allowing you to use "Action" for the default
 * action builder and "parse" to access Play's default body parsers. You may want to extend this to provide your own
 * base controller class, or write your own version with similar code.
 */
trait BaseController extends BaseControllerHelpers {

  /**
   * The default ActionBuilder. Used to construct an action, for example:
   *
   * {{{
   *   def foo(query: String) = Action {
   *     Ok
   *   }
   * }}}
   *
   * This is meant to be a replacement for the now-deprecated Action object, and can be used in the same way.
   */
  def Action: ActionBuilder[Request, AnyContent] = controllerComponents.actionBuilder
}

/**
 * An abstract implementation of [[BaseController]] to make it slightly easier to use.
 */
abstract class AbstractController(protected val controllerComponents: ControllerComponents) extends BaseController

/**
 * A variation of [[BaseController]] that gets its components via method injection.
 */
trait InjectedController extends BaseController {
  private[this] var _components: ControllerComponents = _

  protected override def controllerComponents: ControllerComponents = {
    if (_components == null) fallbackControllerComponents else _components
  }

  /**
   * Call this method to set the [[ControllerComponents]] instance.
   */
  @Inject
  def setControllerComponents(components: ControllerComponents): Unit = {
    _components = components
  }

  /**
   * Defines fallback components to use in case setControllerComponents has not been called.
   */
  protected def fallbackControllerComponents: ControllerComponents = {
    throw new NoSuchElementException(
      "ControllerComponents not set! Call setControllerComponents or create the instance with dependency injection."
    )
  }
}

/**
 * A variation of [[MessagesAbstractController]] that gets its components via method injection.
 */
trait MessagesInjectedController extends MessagesBaseController {
  private[this] var _components: MessagesControllerComponents = _

  protected override def controllerComponents: MessagesControllerComponents = {
    if (_components == null) fallbackControllerComponents else _components
  }

  /**
   * Call this method to set the [[ControllerComponents]] instance.
   */
  @Inject
  def setControllerComponents(components: MessagesControllerComponents): Unit = {
    _components = components
  }

  /**
   * Defines fallback components to use in case setControllerComponents has not been called.
   */
  protected def fallbackControllerComponents: MessagesControllerComponents = {
    throw new NoSuchElementException(
      "ControllerComponents not set! Call setControllerComponents or create the instance with dependency injection."
    )
  }
}

/**
 * The base controller components dependencies that most controllers rely on.
 */
trait ControllerComponents {
  def actionBuilder: ActionBuilder[Request, AnyContent]
  def parsers: PlayBodyParsers
  def messagesApi: MessagesApi
  def langs: Langs
  def fileMimeTypes: FileMimeTypes
  def executionContext: scala.concurrent.ExecutionContext
}

case class DefaultControllerComponents @Inject() (
    actionBuilder: DefaultActionBuilder,
    parsers: PlayBodyParsers,
    messagesApi: MessagesApi,
    langs: Langs,
    fileMimeTypes: FileMimeTypes,
    executionContext: scala.concurrent.ExecutionContext
) extends ControllerComponents

/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

// DO NOT EDIT, CHANGES WILL BE LOST
// This auto-generated code can be modified in "project/GenerateAnyVals.scala".
// Afterwards, running "sbt generateSources" regenerates this source file.

package scala


/** `Unit` is a subtype of [[scala.AnyVal]]. There is only one value of type
 *  `Unit`, `()`, and it is not represented by any object in the underlying
 *  runtime system. A method with return type `Unit` is analogous to a Java
 *  method which is declared `void`.
 */
final abstract class Unit private extends AnyVal {
  // Provide a more specific return type for Scaladoc
  override def getClass(): Class[Unit] = ???
}

object Unit extends AnyValCompanion {

  /** Transform a value type into a boxed reference type.
   *
   *  @param  x   the Unit to be boxed
   *  @return     a scala.runtime.BoxedUnit offering `x` as its underlying value.
   */
  def box(x: Unit): scala.runtime.BoxedUnit = scala.runtime.BoxedUnit.UNIT

  /** Transform a boxed type into a value type.  Note that this
   *  method is not typesafe: it accepts any Object, but will throw
   *  an exception if the argument is not a scala.runtime.BoxedUnit.
   *
   *  @param  x   the scala.runtime.BoxedUnit to be unboxed.
   *  @throws     ClassCastException  if the argument is not a scala.runtime.BoxedUnit
   *  @return     the Unit value ()
   */
  def unbox(x: java.lang.Object): Unit = x.asInstanceOf[scala.runtime.BoxedUnit]

  /** The String representation of the scala.Unit companion object. */
  override def toString = "object scala.Unit"
}


/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package scala.concurrent


import java.util.concurrent.{ ExecutorService, Executor }
import scala.annotation.implicitNotFound

/**
 * An `ExecutionContext` can execute program logic asynchronously,
 * typically but not necessarily on a thread pool.
 *
 * A general purpose `ExecutionContext` must be asynchronous in executing
 * any `Runnable` that is passed into its `execute`-method. A special purpose
 * `ExecutionContext` may be synchronous but must only be passed to code that
 * is explicitly safe to be run using a synchronously executing `ExecutionContext`.
 *
 * APIs such as `Future.onComplete` require you to provide a callback
 * and an implicit `ExecutionContext`. The implicit `ExecutionContext`
 * will be used to execute the callback.
 *
 * While it is possible to simply import
 * `scala.concurrent.ExecutionContext.Implicits.global` to obtain an
 * implicit `ExecutionContext`, application developers should carefully
 * consider where they want to set execution policy;
 * ideally, one place per application—or per logically related section of code—
 * will make a decision about which `ExecutionContext` to use.
 * That is, you will mostly want to avoid hardcoding, especially via an import,
 * `scala.concurrent.ExecutionContext.Implicits.global`.
 * The recommended approach is to add `(implicit ec: ExecutionContext)` to methods,
 * or class constructor parameters, which need an `ExecutionContext`.
 * 
 * Then locally import a specific `ExecutionContext` in one place for the entire
 * application or module, passing it implicitly to individual methods.
 * Alternatively define a local implicit val with the required `ExecutionContext`.
 *
 * A custom `ExecutionContext` may be appropriate to execute code
 * which blocks on IO or performs long-running computations.
 * `ExecutionContext.fromExecutorService` and `ExecutionContext.fromExecutor`
 * are good ways to create a custom `ExecutionContext`.
 *
 * The intent of `ExecutionContext` is to lexically scope code execution.
 * That is, each method, class, file, package, or application determines
 * how to run its own code. This avoids issues such as running
 * application callbacks on a thread pool belonging to a networking library.
 * The size of a networking library's thread pool can be safely configured,
 * knowing that only that library's network operations will be affected.
 * Application callback execution can be configured separately.
 */
@implicitNotFound("""Cannot find an implicit ExecutionContext. You might pass
an (implicit ec: ExecutionContext) parameter to your method.

The ExecutionContext is used to configure how and on which
thread pools Futures will run, so the specific ExecutionContext
that is selected is important.

If your application does not define an ExecutionContext elsewhere,
consider using Scala's global ExecutionContext by defining
the following:

implicit val ec: scala.concurrent.ExecutionContext = scala.concurrent.ExecutionContext.global""")
trait ExecutionContext {

  /** Runs a block of code on this execution context.
   *
   *  @param runnable  the task to execute
   */
  def execute(runnable: Runnable): Unit

  /** Reports that an asynchronous computation failed.
   *
   *  @param cause  the cause of the failure
   */
  def reportFailure(@deprecatedName('t) cause: Throwable): Unit

  /** Prepares for the execution of a task. Returns the prepared
     *  execution context. The recommended implementation of
     *  `prepare` is to return `this`.
     *
     *  This method should no longer be overridden or called. It was
     *  originally expected that `prepare` would be called by
     *  all libraries that consume ExecutionContexts, in order to
     *  capture thread local context. However, this usage has proven
     *  difficult to implement in practice and instead it is
     *  now better to avoid using `prepare` entirely.
     *
     *  Instead, if an `ExecutionContext` needs to capture thread
     *  local context, it should capture that context when it is
     *  constructed, so that it doesn't need any additional
     *  preparation later.
     */
  @deprecated("preparation of ExecutionContexts will be removed", "2.12.0")
  def prepare(): ExecutionContext = this
}

/**
 * An [[ExecutionContext]] that is also a
 * Java [[http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html Executor]].
 */
trait ExecutionContextExecutor extends ExecutionContext with Executor

/**
 * An [[ExecutionContext]] that is also a
 * Java [[http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html ExecutorService]].
 */
trait ExecutionContextExecutorService extends ExecutionContextExecutor with ExecutorService


/** Contains factory methods for creating execution contexts.
 */
object ExecutionContext {
  /**
   * The explicit global `ExecutionContext`. Invoke `global` when you want to provide the global
   * `ExecutionContext` explicitly.
   *
   * The default `ExecutionContext` implementation is backed by a work-stealing thread pool.
   * It can be configured via the following [[scala.sys.SystemProperties]]:
   *
   * `scala.concurrent.context.minThreads` = defaults to "1"
   * `scala.concurrent.context.numThreads` = defaults to "x1" (i.e. the current number of available processors * 1)
   * `scala.concurrent.context.maxThreads` = defaults to "x1" (i.e. the current number of available processors * 1)
   * `scala.concurrent.context.maxExtraThreads` = defaults to "256"
   *
   * The pool size of threads is then `numThreads` bounded by `minThreads` on the lower end and `maxThreads` on the high end.
   *
   * The `maxExtraThreads` is the maximum number of extra threads to have at any given time to evade deadlock,
   * see [[scala.concurrent.BlockContext]].
   *
   * @return the global `ExecutionContext`
   */
  def global: ExecutionContextExecutor = Implicits.global.asInstanceOf[ExecutionContextExecutor]

  object Implicits {
    /**
     * The implicit global `ExecutionContext`. Import `global` when you want to provide the global
     * `ExecutionContext` implicitly.
     *
     * The default `ExecutionContext` implementation is backed by a work-stealing thread pool. By default,
     * the thread pool uses a target number of worker threads equal to the number of
     * [[https://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#availableProcessors-- available processors]].
     */
    implicit lazy val global: ExecutionContext = impl.ExecutionContextImpl.fromExecutor(null: Executor)
  }

  /** Creates an `ExecutionContext` from the given `ExecutorService`.
   *
   *  @param e         the `ExecutorService` to use. If `null`, a new `ExecutorService` is created with [[scala.concurrent.ExecutionContext$.global default configuration]].
   *  @param reporter  a function for error reporting
   *  @return          the `ExecutionContext` using the given `ExecutorService`
   */
  def fromExecutorService(e: ExecutorService, reporter: Throwable => Unit): ExecutionContextExecutorService =
    impl.ExecutionContextImpl.fromExecutorService(e, reporter)

  /** Creates an `ExecutionContext` from the given `ExecutorService` with the [[scala.concurrent.ExecutionContext$.defaultReporter default reporter]].
   *
   *  If it is guaranteed that none of the executed tasks are blocking, a single-threaded `ExecutorService`
   *  can be used to create an `ExecutionContext` as follows:
   *
   *  {{{
   *  import java.util.concurrent.Executors
   *  val ec = ExecutionContext.fromExecutorService(Executors.newSingleThreadExecutor())
   *  }}}
   *
   *  @param e the `ExecutorService` to use. If `null`, a new `ExecutorService` is created with [[scala.concurrent.ExecutionContext$.global default configuration]].
   *  @return  the `ExecutionContext` using the given `ExecutorService`
   */
  def fromExecutorService(e: ExecutorService): ExecutionContextExecutorService = fromExecutorService(e, defaultReporter)

  /** Creates an `ExecutionContext` from the given `Executor`.
   *
   *  @param e         the `Executor` to use. If `null`, a new `Executor` is created with [[scala.concurrent.ExecutionContext$.global default configuration]].
   *  @param reporter  a function for error reporting
   *  @return          the `ExecutionContext` using the given `Executor`
   */
  def fromExecutor(e: Executor, reporter: Throwable => Unit): ExecutionContextExecutor =
    impl.ExecutionContextImpl.fromExecutor(e, reporter)

  /** Creates an `ExecutionContext` from the given `Executor` with the [[scala.concurrent.ExecutionContext$.defaultReporter default reporter]].
   *
   *  @param e the `Executor` to use. If `null`, a new `Executor` is created with [[scala.concurrent.ExecutionContext$.global default configuration]].
   *  @return  the `ExecutionContext` using the given `Executor`
   */
  def fromExecutor(e: Executor): ExecutionContextExecutor = fromExecutor(e, defaultReporter)

  /** The default reporter simply prints the stack trace of the `Throwable` to [[http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#err System.err]].
   *
   *  @return the function for error reporting
   */
  def defaultReporter: Throwable => Unit = _.printStackTrace()
}



Mar 31, 2021 11:17:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 58
[0m2021.03.31 23:19:58 INFO  compiling root (1 scala source)[0m
[0m2021.03.31 23:19:59 INFO  time: compiled root in 1.41s[0m
[0m2021.03.31 23:21:33 INFO  compiling root (1 scala source)[0m
[0m2021.03.31 23:21:33 INFO  time: compiled root in 0.82s[0m
Mar 31, 2021 11:39:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 254
[0m2021.04.01 11:13:13 INFO  shutting down Metals[0m
[0m2021.04.01 11:13:13 INFO  Shut down connection with build server.[0m
No more data in the client stdin, exiting...
No more data in the client stdin, exiting...
No more data in the client stdin, exiting...
[0m2021.04.01 13:55:34 INFO  Started: Metals version 0.10.0 in workspace '/Users/davidashley/Documents/Scala/scalabackend/scalabackend' for client vscode 1.54.3.[0m
[0m2021.04.01 13:55:34 INFO  time: initialize in 0.44s[0m
[0m2021.04.01 13:55:35 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher8719405159426410403/bsp.socket'...
Waiting for the bsp connection to come up...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher8719405159426410403/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher8719405159426410403/bsp.socket...
[0m2021.04.01 13:55:35 INFO  skipping build import with status 'Installed'[0m
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.04.01 13:55:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.04.01 13:55:35 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
[0m2021.04.01 13:55:35 INFO  Attempting to connect to the build server...[0m
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher62076741161128473/bsp.socket'...
Waiting for the bsp connection to come up...
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher5596981541940424674/bsp.socket'...
Waiting for the bsp connection to come up...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher62076741161128473/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher62076741161128473/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.04.01 13:55:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher5596981541940424674/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher5596981541940424674/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.04.01 13:55:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.04.01 13:55:35 INFO  time: Connected to build server in 0.56s[0m
[0m2021.04.01 13:55:35 INFO  Connected to Build server: Bloop v1.4.8[0m
[0m2021.04.01 13:55:36 INFO  time: Imported build in 0.12s[0m
[0m2021.04.01 13:55:40 INFO  time: indexed workspace in 4.04s[0m
import _root_.scala.xml.{TopScope=>$scope}
import _root_.sbt._
import _root_.sbt.Keys._
import _root_.sbt.nio.Keys._
import _root_.sbt.ScriptedPlugin.autoImport._, _root_.bloop.integrations.sbt.BloopPlugin.autoImport._
import _root_.sbt.plugins.IvyPlugin, _root_.sbt.plugins.JvmPlugin, _root_.sbt.plugins.CorePlugin, _root_.sbt.ScriptedPlugin, _root_.sbt.plugins.SbtPlugin, _root_.sbt.plugins.SemanticdbPlugin, _root_.sbt.plugins.JUnitXmlReportPlugin, _root_.sbt.plugins.Giter8TemplatePlugin, _root_.bloop.integrations.sbt.BloopPlugin
addSbtPlugin("com.typesafe.play" % "sbt-plugin" % "2.8.7")
addSbtPlugin("org.foundweekends.giter8" % "sbt-giter8-scaffold" % "0.11.0")

import _root_.scala.xml.{TopScope=>$scope}
import _root_.sbt._
import _root_.sbt.Keys._
import _root_.sbt.nio.Keys._
import _root_.sbt.ScriptedPlugin.autoImport._, _root_.bloop.integrations.sbt.BloopPlugin.autoImport._, _root_.play.sbt.Play.autoImport._, _root_.play.sbt.PlayService.autoImport._, _root_.play.sbt.routes.RoutesCompiler.autoImport._, _root_.giter8.ScaffoldPlugin.autoImport._, _root_.play.twirl.sbt.SbtTwirl.autoImport._, _root_.com.typesafe.sbt.SbtNativePackager.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.JavaAppPackaging.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.JavaServerAppPackaging.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.jar.ClasspathJarPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.jar.LauncherJarPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.jlink.JlinkPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.scripts.BashStartScriptPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.scripts.BatStartScriptPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemdPlugin.autoImport._, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemloaderPlugin.autoImport._, _root_.com.typesafe.sbt.packager.debian.DebianPlugin.autoImport._, _root_.com.typesafe.sbt.packager.docker.DockerPlugin.autoImport._, _root_.com.typesafe.sbt.packager.graalvmnativeimage.GraalVMNativeImagePlugin.autoImport._, _root_.com.typesafe.sbt.packager.jdkpackager.JDKPackagerPlugin.autoImport._, _root_.com.typesafe.sbt.packager.linux.LinuxPlugin.autoImport._, _root_.com.typesafe.sbt.packager.rpm.RpmPlugin.autoImport._, _root_.com.typesafe.sbt.packager.universal.UniversalPlugin.autoImport._, _root_.com.typesafe.sbt.packager.windows.WindowsPlugin.autoImport._, _root_.com.lightbend.sbt.javaagent.JavaAgent.autoImport._, _root_.com.typesafe.sbt.web.SbtWeb.autoImport._, _root_.com.typesafe.sbt.jse.SbtJsEngine.autoImport._, _root_.com.typesafe.sbt.jse.SbtJsTask.autoImport._
import _root_.sbt.plugins.IvyPlugin, _root_.sbt.plugins.JvmPlugin, _root_.sbt.plugins.CorePlugin, _root_.sbt.ScriptedPlugin, _root_.sbt.plugins.SbtPlugin, _root_.sbt.plugins.SemanticdbPlugin, _root_.sbt.plugins.JUnitXmlReportPlugin, _root_.sbt.plugins.Giter8TemplatePlugin, _root_.bloop.integrations.sbt.BloopPlugin, _root_.play.sbt.Play, _root_.play.sbt.PlayAkkaHttp2Support, _root_.play.sbt.PlayAkkaHttpServer, _root_.play.sbt.PlayFilters, _root_.play.sbt.PlayJava, _root_.play.sbt.PlayLayoutPlugin, _root_.play.sbt.PlayLogback, _root_.play.sbt.PlayMinimalJava, _root_.play.sbt.PlayNettyServer, _root_.play.sbt.PlayScala, _root_.play.sbt.PlayService, _root_.play.sbt.PlayWeb, _root_.play.sbt.routes.RoutesCompiler, _root_.play.sbt.test.MediatorWorkaroundPlugin, _root_.giter8.ScaffoldPlugin, _root_.play.twirl.sbt.SbtTwirl, _root_.com.typesafe.sbt.SbtNativePackager, _root_.com.typesafe.sbt.packager.archetypes.JavaAppPackaging, _root_.com.typesafe.sbt.packager.archetypes.JavaServerAppPackaging, _root_.com.typesafe.sbt.packager.archetypes.jar.ClasspathJarPlugin, _root_.com.typesafe.sbt.packager.archetypes.jar.LauncherJarPlugin, _root_.com.typesafe.sbt.packager.archetypes.jlink.JlinkPlugin, _root_.com.typesafe.sbt.packager.archetypes.scripts.AshScriptPlugin, _root_.com.typesafe.sbt.packager.archetypes.scripts.BashStartScriptPlugin, _root_.com.typesafe.sbt.packager.archetypes.scripts.BatStartScriptPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemVPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemdPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.SystemloaderPlugin, _root_.com.typesafe.sbt.packager.archetypes.systemloader.UpstartPlugin, _root_.com.typesafe.sbt.packager.debian.DebianDeployPlugin, _root_.com.typesafe.sbt.packager.debian.DebianPlugin, _root_.com.typesafe.sbt.packager.debian.JDebPackaging, _root_.com.typesafe.sbt.packager.docker.DockerPlugin, _root_.com.typesafe.sbt.packager.docker.DockerSpotifyClientPlugin, _root_.com.typesafe.sbt.packager.graalvmnativeimage.GraalVMNativeImagePlugin, _root_.com.typesafe.sbt.packager.jdkpackager.JDKPackagerDeployPlugin, _root_.com.typesafe.sbt.packager.jdkpackager.JDKPackagerPlugin, _root_.com.typesafe.sbt.packager.linux.LinuxPlugin, _root_.com.typesafe.sbt.packager.rpm.RpmDeployPlugin, _root_.com.typesafe.sbt.packager.rpm.RpmPlugin, _root_.com.typesafe.sbt.packager.universal.UniversalDeployPlugin, _root_.com.typesafe.sbt.packager.universal.UniversalPlugin, _root_.com.typesafe.sbt.packager.windows.WindowsDeployPlugin, _root_.com.typesafe.sbt.packager.windows.WindowsPlugin, _root_.com.lightbend.sbt.javaagent.JavaAgent, _root_.com.lightbend.sbt.javaagent.JavaAgentPackaging, _root_.com.typesafe.sbt.web.SbtWeb, _root_.com.typesafe.sbt.jse.SbtJsEngine, _root_.com.typesafe.sbt.jse.SbtJsTask
name := """scalabackend"""
organization := "com.example"

version := "1.0-SNAPSHOT"

lazy val root = (project in file(".")).enablePlugins(PlayScala)

scalaVersion := "2.13.3"

libraryDependencies += guice
libraryDependencies += "org.scalatestplus.play" %% "scalatestplus-play" % "5.0.0" % Test
libraryDependencies ++= Seq(
  jdbc
)
libraryDependencies ++= Seq(
  "mysql" % "mysql-connector-java" % "8.0.20"
)
// Adds additional packages into Twirl
//TwirlKeys.templateImports += "com.example.controllers._"

// Adds additional packages into conf/routes
// play.sbt.routes.RoutesKeys.routesImport += "com.example.binders._"

[0m2021.04.01 14:06:26 INFO  time: code lens generation in 1.15s[0m
[0m2021.04.01 14:06:26 INFO  time: code lens generation in 4.4s[0m
Apr 01, 2021 2:13:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 38
[0m2021.04.01 14:51:13 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 14:51:14 INFO  time: compiled root in 1.1s[0m
Apr 01, 2021 2:51:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 67
Apr 01, 2021 2:51:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 79
Apr 01, 2021 2:51:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 85
[0m2021.04.01 14:51:46 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 14:51:48 INFO  time: compiled root in 1.41s[0m
[0m2021.04.01 14:52:45 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 14:52:47 INFO  time: compiled root in 1.47s[0m
/*
 * Copyright (C) Lightbend Inc. <https://www.lightbend.com>
 */

package play.api.mvc

import java.lang.{ StringBuilder => JStringBuilder }
import java.net.URLEncoder
import java.nio.file.Files
import java.nio.file.Path
import java.time.format.DateTimeFormatter
import java.time.ZoneOffset
import java.time.ZonedDateTime

import akka.stream.scaladsl.FileIO
import akka.stream.scaladsl.Source
import akka.stream.scaladsl.StreamConverters
import akka.util.ByteString
import play.api.http.HeaderNames._
import play.api.http.FileMimeTypes
import play.api.http._
import play.api.i18n.Lang
import play.api.i18n.MessagesApi
import play.api.Logger
import play.api.Mode
import play.core.utils.CaseInsensitiveOrdered
import play.core.utils.HttpHeaderParameterEncoding

import scala.collection.JavaConverters._
import scala.collection.immutable.TreeMap
import scala.concurrent.ExecutionContext

/**
 * A simple HTTP response header, used for standard responses.
 *
 * @param status the response status, e.g. 200
 * @param _headers the HTTP headers
 * @param reasonPhrase the human-readable description of status, e.g. "Ok";
 *   if None, the default phrase for the status will be used
 */
final class ResponseHeader(
    val status: Int,
    _headers: Map[String, String] = Map.empty,
    val reasonPhrase: Option[String] = None
) {
  private[play] def this(status: Int, _headers: java.util.Map[String, String], reasonPhrase: Option[String]) =
    this(status, _headers.asScala.toMap, reasonPhrase)

  val headers: Map[String, String] = TreeMap[String, String]()(CaseInsensitiveOrdered) ++ _headers

  // validate headers so we know this response header is well formed
  for ((name, value) <- headers) {
    if (name eq null) throw new NullPointerException("Response header names cannot be null!")
    if (value eq null) throw new NullPointerException(s"Response header '$name' has null value!")
  }

  def copy(
      status: Int = status,
      headers: Map[String, String] = headers,
      reasonPhrase: Option[String] = reasonPhrase
  ): ResponseHeader =
    new ResponseHeader(status, headers, reasonPhrase)

  override def toString = s"$status, $headers"
  override def hashCode = (status, headers).hashCode
  override def equals(o: Any) = o match {
    case ResponseHeader(s, h, r) => (s, h, r).equals((status, headers, reasonPhrase))
    case _                       => false
  }

  def asJava: play.mvc.ResponseHeader = {
    new play.mvc.ResponseHeader(status, headers.asJava, reasonPhrase.orNull)
  }

  /**
   * INTERNAL API
   *
   * Appends to the comma-separated `Vary` header of this request
   */
  private[play] def varyWith(headerValues: String*): (String, String) = {
    val newValue = headers.get(VARY) match {
      case Some(existing) if existing.nonEmpty =>
        val existingSet: Set[String] = existing.split(",").iterator.map(_.trim.toLowerCase).toSet
        val newValuesToAdd           = headerValues.filterNot(v => existingSet.contains(v.trim.toLowerCase))
        s"$existing${newValuesToAdd.map(v => s",$v").mkString}"
      case _ =>
        headerValues.mkString(",")
    }
    VARY -> newValue
  }
}

object ResponseHeader {
  val basicDateFormatPattern = "EEE, dd MMM yyyy HH:mm:ss"
  val httpDateFormat: DateTimeFormatter =
    DateTimeFormatter
      .ofPattern(basicDateFormatPattern + " 'GMT'")
      .withLocale(java.util.Locale.ENGLISH)
      .withZone(ZoneOffset.UTC)

  def apply(
      status: Int,
      headers: Map[String, String] = Map.empty,
      reasonPhrase: Option[String] = None
  ): ResponseHeader =
    new ResponseHeader(status, headers)
  def unapply(rh: ResponseHeader): Option[(Int, Map[String, String], Option[String])] =
    if (rh eq null) None else Some((rh.status, rh.headers, rh.reasonPhrase))
}

object Result {

  /**
   * Logs a redirect warning for flashing (in dev mode) if the status code is not 3xx
   */
  @inline def warnFlashingIfNotRedirect(flash: Flash, header: ResponseHeader): Unit = {
    if (!flash.isEmpty && !Status.isRedirect(header.status)) {
      Logger("play")
        .forMode(Mode.Dev)
        .warn(
          s"You are using status code '${header.status}' with flashing, which should only be used with a redirect status!"
        )
    }
  }
}

/**
 * A simple result, which defines the response header and a body ready to send to the client.
 *
 * @param header the response header, which contains status code and HTTP headers
 * @param body the response body
 */
case class Result(
    header: ResponseHeader,
    body: HttpEntity,
    newSession: Option[Session] = None,
    newFlash: Option[Flash] = None,
    newCookies: Seq[Cookie] = Seq.empty
) {

  /**
   * Adds headers to this result.
   *
   * For example:
   * {{{
   * Ok("Hello world").withHeaders(ETAG -> "0")
   * }}}
   *
   * @param headers the headers to add to this result.
   * @return the new result
   */
  def withHeaders(headers: (String, String)*): Result = {
    copy(header = header.copy(headers = header.headers ++ headers))
  }

  /**
   * Add a header with a DateTime formatted using the default http date format
   *
   * @param headers the headers with a DateTime to add to this result.
   * @return the new result.
   */
  def withDateHeaders(headers: (String, ZonedDateTime)*): Result = {
    copy(header = header.copy(headers = header.headers ++ headers.map {
      case (name, dateTime) => (name, dateTime.format(ResponseHeader.httpDateFormat))
    }))
  }

  /**
   * Discards headers to this result.
   *
   * For example:
   * {{{
   * Ok("Hello world").discardingHeader(ETAG)
   * }}}
   *
   * @param name the header to discard from this result.
   * @return the new result
   */
  def discardingHeader(name: String): Result = {
    copy(header = header.copy(headers = header.headers - name))
  }

  /**
   * Adds cookies to this result. If the result already contains cookies then cookies with the same name in the new
   * list will override existing ones.
   *
   * For example:
   * {{{
   * Redirect(routes.Application.index()).withCookies(Cookie("theme", "blue"))
   * }}}
   *
   * @param cookies the cookies to add to this result
   * @return the new result
   */
  def withCookies(cookies: Cookie*): Result = {
    val filteredCookies = newCookies.filter(cookie => !cookies.exists(_.name == cookie.name))
    if (cookies.isEmpty) this else copy(newCookies = filteredCookies ++ cookies)
  }

  /**
   * Discards cookies along this result.
   *
   * For example:
   * {{{
   * Redirect(routes.Application.index()).discardingCookies("theme")
   * }}}
   *
   * @param cookies the cookies to discard along to this result
   * @return the new result
   */
  def discardingCookies(cookies: DiscardingCookie*): Result = {
    withCookies(cookies.map(_.toCookie): _*)
  }

  /**
   * Sets a new session for this result.
   *
   * For example:
   * {{{
   * Redirect(routes.Application.index()).withSession(session + ("saidHello" -> "true"))
   * }}}
   *
   * @param session the session to set with this result
   * @return the new result
   */
  def withSession(session: Session): Result = copy(newSession = Some(session))

  /**
   * Sets a new session for this result, discarding the existing session.
   *
   * For example:
   * {{{
   * Redirect(routes.Application.index()).withSession("saidHello" -> "yes")
   * }}}
   *
   * @param session the session to set with this result
   * @return the new result
   */
  def withSession(session: (String, String)*): Result = withSession(Session(session.toMap))

  /**
   * Discards the existing session for this result.
   *
   * For example:
   * {{{
   * Redirect(routes.Application.index()).withNewSession
   * }}}
   *
   * @return the new result
   */
  def withNewSession: Result = withSession(Session())

  /**
   * Adds values to the flash scope for this result.
   *
   * For example:
   * {{{
   * Redirect(routes.Application.index()).flashing(flash + ("success" -> "Done!"))
   * }}}
   *
   * @param flash the flash scope to set with this result
   * @return the new result
   */
  def flashing(flash: Flash): Result = {
    Result.warnFlashingIfNotRedirect(flash, header)
    copy(newFlash = Some(flash))
  }

  /**
   * Adds values to the flash scope for this result.
   *
   * For example:
   * {{{
   * Redirect(routes.Application.index()).flashing("success" -> "Done!")
   * }}}
   *
   * @param values the flash values to set with this result
   * @return the new result
   */
  def flashing(values: (String, String)*): Result = flashing(Flash(values.toMap))

  /**
   * Changes the result content type.
   *
   * For example:
   * {{{
   * Ok("<text>Hello world</text>").as("application/xml")
   * }}}
   *
   * @param contentType the new content type.
   * @return the new result
   */
  def as(contentType: String): Result = copy(body = body.as(contentType))

  /**
   * @param request Current request
   * @return The session carried by this result. Reads the request’s session if this result does not modify the session.
   */
  def session(implicit request: RequestHeader): Session = newSession.getOrElse(request.session)

  /**
   * Example:
   * {{{
   *   Ok.addingToSession("foo" -> "bar").addingToSession("baz" -> "bah")
   * }}}
   *
   * @param values (key -> value) pairs to add to this result’s session
   * @param request Current request
   * @return A copy of this result with `values` added to its session scope.
   */
  def addingToSession(values: (String, String)*)(implicit request: RequestHeader): Result =
    withSession(new Session(session.data ++ values.toMap))

  /**
   * Example:
   * {{{
   *   Ok.removingFromSession("foo")
   * }}}
   *
   * @param keys Keys to remove from session
   * @param request Current request
   * @return A copy of this result with `keys` removed from its session scope.
   */
  def removingFromSession(keys: String*)(implicit request: RequestHeader): Result =
    withSession(new Session(session.data -- keys))

  override def toString = s"Result(${header})"

  /**
   * Convert this result to a Java result.
   */
  def asJava: play.mvc.Result =
    new play.mvc.Result(
      header.asJava,
      body.asJava,
      newSession.map(_.asJava).orNull,
      newFlash.map(_.asJava).orNull,
      newCookies.map(_.asJava).asJava
    )

  /**
   * Encode the cookies into the Set-Cookie header. The session is always baked first, followed by the flash cookie,
   * followed by all the other cookies in order.
   */
  def bakeCookies(
      cookieHeaderEncoding: CookieHeaderEncoding = new DefaultCookieHeaderEncoding(),
      sessionBaker: CookieBaker[Session] = new DefaultSessionCookieBaker(),
      flashBaker: CookieBaker[Flash] = new DefaultFlashCookieBaker(),
      requestHasFlash: Boolean = false
  ): Result = {
    val allCookies = {
      val setCookieCookies = cookieHeaderEncoding.decodeSetCookieHeader(header.headers.getOrElse(SET_COOKIE, ""))
      val session = newSession.map { data =>
        if (data.isEmpty) sessionBaker.discard.toCookie else sessionBaker.encodeAsCookie(data)
      }
      val flash = newFlash
        .map { data =>
          if (data.isEmpty) flashBaker.discard.toCookie else flashBaker.encodeAsCookie(data)
        }
        .orElse {
          if (requestHasFlash) Some(flashBaker.discard.toCookie) else None
        }
      setCookieCookies ++ session ++ flash ++ newCookies
    }

    if (allCookies.isEmpty) {
      this
    } else {
      withHeaders(SET_COOKIE -> cookieHeaderEncoding.encodeSetCookieHeader(allCookies))
    }
  }
}

/**
 * A Codec handle the conversion of String to Byte arrays.
 *
 * @param charset The charset to be sent to the client.
 * @param encode The transformation function.
 */
case class Codec(charset: String)(val encode: String => ByteString, val decode: ByteString => String)

/**
 * Default Codec support.
 */
object Codec {

  /**
   * Create a Codec from an encoding already supported by the JVM.
   */
  def javaSupported(charset: String) =
    Codec(charset)(str => ByteString.apply(str, charset), bytes => bytes.decodeString(charset))

  /**
   * Codec for UTF-8
   */
  implicit val utf_8 = javaSupported("utf-8")

  /**
   * Codec for ISO-8859-1
   */
  val iso_8859_1 = javaSupported("iso-8859-1")
}

trait LegacyI18nSupport {

  /**
   * Adds convenient methods to handle the client-side language.
   *
   * This class exists only for backward compatibility.
   */
  implicit class ResultWithLang(result: Result)(implicit messagesApi: MessagesApi) {

    /**
     * Sets the user's language permanently for future requests by storing it in a cookie.
     *
     * For example:
     * {{{
     * implicit val lang = Lang("fr-FR")
     * Ok(Messages("hello.world")).withLang(lang)
     * }}}
     *
     * @param lang the language to store for the user
     * @return the new result
     */
    def withLang(lang: Lang): Result =
      messagesApi.setLang(result, lang)

    /**
     * Clears the user's language by discarding the language cookie set by withLang
     *
     * For example:
     * {{{
     * Ok(Messages("hello.world")).withoutLang
     * }}}
     *
     * @return the new result
     */
    def clearingLang: Result =
      messagesApi.clearLang(result)
  }
}

/** Helper utilities to generate results. */
object Results extends Results with LegacyI18nSupport {
  private[mvc] final val logger = Logger(getClass)

  /** Empty result, i.e. nothing to send. */
  case class EmptyContent()

  /**
   * Encodes and adds the query params to the given url
   *
   * @param url
   * @param queryStringParams
   * @return
   */
  private[play] def addQueryStringParams(url: String, queryStringParams: Map[String, Seq[String]]): String = {
    if (queryStringParams.isEmpty) {
      url
    } else {
      val queryString: String = queryStringParams
        .flatMap {
          case (key, values) =>
            val encodedKey = URLEncoder.encode(key, "utf-8")
            values.map(value => s"$encodedKey=${URLEncoder.encode(value, "utf-8")}")
        }
        .mkString("&")

      url + (if (url.contains("?")) "&" else "?") + queryString
    }
  }

  /**
   * Creates a {@code Content-Disposition} header.<br>
   * According to RFC 6266 (Section 4.2) there is no need to send the header {@code "Content-Disposition: inline"}.
   * Therefore if the header generated by this method ends up being exactly that header (when passing {@code inline = true}
   * and {@code None} as {@code name}), an empty Map ist returned.
   *
   * @param inline If the content should be rendered inline or as attachment.
   * @param name The name of the resource, usually displayed in a file download dialog.
   * @return a map with a {@code Content-Disposition} header entry or an empty map if explained conditions apply.
   * @see [[https://tools.ietf.org/html/rfc6266#section-4.2]]
   */
  def contentDispositionHeader(inline: Boolean, name: Option[String]): Map[String, String] =
    if (!inline || name.exists(_.nonEmpty))
      Map(
        CONTENT_DISPOSITION -> {
          val builder = new JStringBuilder
          builder.append(if (inline) "inline" else "attachment")
          name.foreach(filename => {
            builder.append("; ")
            HttpHeaderParameterEncoding.encodeToBuilder("filename", filename, builder)
          })
          builder.toString
        }
      )
    else Map.empty
}

/** Helper utilities to generate results. */
trait Results {
  import play.api.http.Status._

  /**
   * Generates default `Result` from a content type, headers and content.
   *
   * @param status the HTTP response status, e.g ‘200 OK’
   */
  class Status(status: Int) extends Result(header = ResponseHeader(status), body = HttpEntity.NoEntity) {

    /**
     * Set the result's content.
     *
     * @param content The content to send.
     */
    def apply[C](content: C)(implicit writeable: Writeable[C]): Result = {
      Result(
        header,
        writeable.toEntity(content)
      )
    }

    private def streamFile(file: Source[ByteString, _], name: Option[String], length: Option[Long], inline: Boolean)(
        implicit fileMimeTypes: FileMimeTypes
    ): Result = {
      Result(
        ResponseHeader(
          status,
          Results.contentDispositionHeader(inline, name)
        ),
        HttpEntity.Streamed(
          file,
          length,
          name.flatMap(fileMimeTypes.forFileName).orElse(Some(play.api.http.ContentTypes.BINARY))
        )
      )
    }

    /**
     * Send a file.
     *
     * @param content The file to send.
     * @param inline Use Content-Disposition inline or attachment.
     * @param fileName Function to retrieve the file name rendered in the {@code Content-Disposition} header. By default the name
     *      of the file is used. The response will also automatically include the MIME type in the {@code Content-Type} header
     *      deducing it from this file name if the {@code implicit fileMimeTypes} includes it or fallback to {@code application/octet-stream}
     *      if unknown.
     * @param onClose Useful in order to perform cleanup operations (e.g. deleting a temporary file generated for a download).
     */
    def sendFile(
        content: java.io.File,
        inline: Boolean = true,
        fileName: java.io.File => Option[String] = Option(_).map(_.getName),
        onClose: () => Unit = () => ()
    )(implicit ec: ExecutionContext, fileMimeTypes: FileMimeTypes): Result = {
      sendPath(content.toPath, inline, (p: Path) => fileName(p.toFile), onClose)
    }

    /**
     * Send a path.
     *
     * @param content The path to send.
     * @param inline Use Content-Disposition inline or attachment.
     * @param fileName Function to retrieve the file name rendered in the {@code Content-Disposition} header. By default the name
     *      of the file is used. The response will also automatically include the MIME type in the {@code Content-Type} header
     *      deducing it from this file name if the {@code implicit fileMimeTypes} includes it or fallback to {@code application/octet-stream}
     *      if unknown.
     * @param onClose Useful in order to perform cleanup operations (e.g. deleting a temporary file generated for a download).
     */
    def sendPath(
        content: Path,
        inline: Boolean = true,
        fileName: Path => Option[String] = Option(_).map(_.getFileName.toString),
        onClose: () => Unit = () => ()
    )(implicit ec: ExecutionContext, fileMimeTypes: FileMimeTypes): Result = {
      val io = FileIO
        .fromPath(content)
        .mapMaterializedValue(_.onComplete { _ =>
          onClose()
        })
      streamFile(io, fileName(content), Some(Files.size(content)), inline)
    }

    /**
     * Send the given resource from the given classloader.
     *
     * @param resource The path of the resource to load.
     * @param classLoader The classloader to load it from, defaults to the classloader for this class.
     * @param inline Whether it should be served as an inline file, or as an attachment.
     * @param fileName Function to retrieve the file name rendered in the {@code Content-Disposition} header. By default the name
     *      of the file is used. The response will also automatically include the MIME type in the {@code Content-Type} header
     *      deducing it from this file name if the {@code implicit fileMimeTypes} includes it or fallback to {@code application/octet-stream}
     *      if unknown.
     * @param onClose Useful in order to perform cleanup operations (e.g. deleting a temporary file generated for a download).
     */
    def sendResource(
        resource: String,
        classLoader: ClassLoader = Results.getClass.getClassLoader,
        inline: Boolean = true,
        fileName: String => Option[String] = Option(_).map(_.split('/').last),
        onClose: () => Unit = () => ()
    )(implicit ec: ExecutionContext, fileMimeTypes: FileMimeTypes): Result = {
      val stream = classLoader.getResourceAsStream(resource)
      val io = StreamConverters
        .fromInputStream(() => stream)
        .mapMaterializedValue(_.onComplete { _ =>
          onClose()
        })
      streamFile(io, fileName(resource), Some(stream.available()), inline)
    }

    /**
     * Feed the content as the response, using chunked transfer encoding.
     *
     * Chunked transfer encoding is only supported for HTTP 1.1 clients.  If the client is an HTTP 1.0 client, Play will
     * instead return a 505 error code.
     *
     * Chunked encoding allows the server to send a response where the content length is not known, or for potentially
     * infinite streams, while still allowing the connection to be kept alive and reused for the next request.
     *
     * @param content Source providing the content to stream.
     * @param contentType an optional content type.
     */
    def chunked[C](content: Source[C, _], contentType: Option[String] = None)(
        implicit writeable: Writeable[C]
    ): Result = {
      Result(
        header = header,
        body = HttpEntity
          .Chunked(content.map(c => HttpChunk.Chunk(writeable.transform(c))), contentType.orElse(writeable.contentType))
      )
    }

    /**
     * Feed the content as the response, using chunked transfer encoding.
     *
     * Chunked transfer encoding is only supported for HTTP 1.1 clients.  If the client is an HTTP 1.0 client, Play will
     * instead return a 505 error code.
     *
     * Chunked encoding allows the server to send a response where the content length is not known, or for potentially
     * infinite streams, while still allowing the connection to be kept alive and reused for the next request.
     *
     * @param content Source providing the content to stream.
     * @param inline If the content should be rendered inline or as attachment.
     * @param fileName Function to retrieve the file name rendered in the {@code Content-Disposition} header. By default the name
     *      of the file is used. The response will also automatically include the MIME type in the {@code Content-Type} header
     *      deducing it from this file name if the {@code implicit fileMimeTypes} includes it or fallback to the content-type of the
     *      {@code implicit writeable} if unknown.
     */
    def chunked[C](content: Source[C, _], inline: Boolean, fileName: Option[String])(
        implicit writeable: Writeable[C],
        fileMimeTypes: FileMimeTypes
    ): Result = {
      Result(
        header = header.copy(headers = header.headers ++ Results.contentDispositionHeader(inline, fileName)),
        body = HttpEntity.Chunked(
          content.map(c => HttpChunk.Chunk(writeable.transform(c))),
          fileName.flatMap(fileMimeTypes.forFileName).orElse(writeable.contentType)
        )
      )
    }

    /**
     * Feed the content as the response, using a streamed entity.
     *
     * It will use the given Content-Type, but if is not present, then it fallsback
     * to use the [[Writeable]] contentType.
     *
     * @param content Source providing the content to stream.
     * @param contentLength an optional content length.
     * @param contentType an optional content type.
     */
    def streamed[C](content: Source[C, _], contentLength: Option[Long], contentType: Option[String] = None)(
        implicit writeable: Writeable[C]
    ): Result = {
      Result(
        header = header,
        body = HttpEntity
          .Streamed(content.map(c => writeable.transform(c)), contentLength, contentType.orElse(writeable.contentType))
      )
    }

    /**
     * Feed the content as the response, using a streamed entity.
     *
     * It will use the given Content-Type, but if is not present, then it fallsback
     * to use the [[Writeable]] contentType.
     *
     * @param content Source providing the content to stream.
     * @param contentLength an optional content length.
     * @param inline If the content should be rendered inline or as attachment.
     * @param fileName Function to retrieve the file name rendered in the {@code Content-Disposition} header. By default the name
     *      of the file is used. The response will also automatically include the MIME type in the {@code Content-Type} header
     *      deducing it from this file name if the {@code implicit fileMimeTypes} includes it or fallback to the content-type of the
     *      {@code implicit writeable} if unknown.
     */
    def streamed[C](content: Source[C, _], contentLength: Option[Long], inline: Boolean, fileName: Option[String])(
        implicit writeable: Writeable[C],
        fileMimeTypes: FileMimeTypes
    ): Result = {
      Result(
        header = header.copy(headers = header.headers ++ Results.contentDispositionHeader(inline, fileName)),
        body = HttpEntity.Streamed(
          content.map(c => writeable.transform(c)),
          contentLength,
          fileName.flatMap(fileMimeTypes.forFileName).orElse(writeable.contentType)
        )
      )
    }

    /**
     * Send an HTTP entity with this status.
     *
     * @param entity The entity to send.
     */
    def sendEntity(entity: HttpEntity): Result = {
      Result(
        header = header,
        body = entity
      )
    }

    /**
     * Send an HTTP entity with this status.
     *
     * @param entity The entity to send.
     * @param inline If the content should be rendered inline or as attachment.
     * @param fileName Function to retrieve the file name rendered in the {@code Content-Disposition} header. By default the name
     *      of the file is used. The response will also automatically include the MIME type in the {@code Content-Type} header
     *      deducing it from this file name if the {@code implicit fileMimeTypes} includes it or fallback to {@code application/octet-stream}
     *      if unknown.
     */
    def sendEntity(entity: HttpEntity, inline: Boolean, fileName: Option[String])(
        implicit fileMimeTypes: FileMimeTypes
    ): Result = {
      Result(
        header = header.copy(headers = header.headers ++ Results.contentDispositionHeader(inline, fileName)),
        body = entity
      ).as(fileName.flatMap(fileMimeTypes.forFileName).getOrElse(play.api.http.ContentTypes.BINARY))
    }
  }

  /** Generates a ‘100 Continue’ result. */
  val Continue = Result(header = ResponseHeader(CONTINUE), body = HttpEntity.NoEntity)

  /** Generates a ‘101 Switching Protocols’ result. */
  val SwitchingProtocols = Result(header = ResponseHeader(SWITCHING_PROTOCOLS), body = HttpEntity.NoEntity)

  /** Generates a ‘200 OK’ result. */
  val Ok = new Status(OK)

  /** Generates a ‘201 CREATED’ result. */
  val Created = new Status(CREATED)

  /** Generates a ‘202 ACCEPTED’ result. */
  val Accepted = new Status(ACCEPTED)

  /** Generates a ‘203 NON_AUTHORITATIVE_INFORMATION’ result. */
  val NonAuthoritativeInformation = new Status(NON_AUTHORITATIVE_INFORMATION)

  /** Generates a ‘204 NO_CONTENT’ result. */
  val NoContent = Result(header = ResponseHeader(NO_CONTENT), body = HttpEntity.NoEntity)

  /** Generates a ‘205 RESET_CONTENT’ result. */
  val ResetContent = Result(header = ResponseHeader(RESET_CONTENT), body = HttpEntity.NoEntity)

  /** Generates a ‘206 PARTIAL_CONTENT’ result. */
  val PartialContent = new Status(PARTIAL_CONTENT)

  /** Generates a ‘207 MULTI_STATUS’ result. */
  val MultiStatus = new Status(MULTI_STATUS)

  /**
   * Generates a ‘301 MOVED_PERMANENTLY’ simple result.
   *
   * @param url the URL to redirect to
   */
  def MovedPermanently(url: String): Result = Redirect(url, MOVED_PERMANENTLY)

  /**
   * Generates a ‘302 FOUND’ simple result.
   *
   * @param url the URL to redirect to
   */
  def Found(url: String): Result = Redirect(url, FOUND)

  /**
   * Generates a ‘303 SEE_OTHER’ simple result.
   *
   * @param url the URL to redirect to
   */
  def SeeOther(url: String): Result = Redirect(url, SEE_OTHER)

  /** Generates a ‘304 NOT_MODIFIED’ result. */
  val NotModified = Result(header = ResponseHeader(NOT_MODIFIED), body = HttpEntity.NoEntity)

  /**
   * Generates a ‘307 TEMPORARY_REDIRECT’ simple result.
   *
   * @param url the URL to redirect to
   */
  def TemporaryRedirect(url: String): Result = Redirect(url, TEMPORARY_REDIRECT)

  /**
   * Generates a ‘308 PERMANENT_REDIRECT’ simple result.
   *
   * @param url the URL to redirect to
   */
  def PermanentRedirect(url: String): Result = Redirect(url, PERMANENT_REDIRECT)

  /** Generates a ‘400 BAD_REQUEST’ result. */
  val BadRequest = new Status(BAD_REQUEST)

  /** Generates a ‘401 UNAUTHORIZED’ result. */
  val Unauthorized = new Status(UNAUTHORIZED)

  /** Generates a ‘402 PAYMENT_REQUIRED’ result. */
  val PaymentRequired = new Status(PAYMENT_REQUIRED)

  /** Generates a ‘403 FORBIDDEN’ result. */
  val Forbidden = new Status(FORBIDDEN)

  /** Generates a ‘404 NOT_FOUND’ result. */
  val NotFound = new Status(NOT_FOUND)

  /** Generates a ‘405 METHOD_NOT_ALLOWED’ result. */
  val MethodNotAllowed = new Status(METHOD_NOT_ALLOWED)

  /** Generates a ‘406 NOT_ACCEPTABLE’ result. */
  val NotAcceptable = new Status(NOT_ACCEPTABLE)

  /** Generates a ‘408 REQUEST_TIMEOUT’ result. */
  val RequestTimeout = new Status(REQUEST_TIMEOUT)

  /** Generates a ‘409 CONFLICT’ result. */
  val Conflict = new Status(CONFLICT)

  /** Generates a ‘410 GONE’ result. */
  val Gone = new Status(GONE)

  /** Generates a ‘412 PRECONDITION_FAILED’ result. */
  val PreconditionFailed = new Status(PRECONDITION_FAILED)

  /** Generates a ‘413 REQUEST_ENTITY_TOO_LARGE’ result. */
  val EntityTooLarge = new Status(REQUEST_ENTITY_TOO_LARGE)

  /** Generates a ‘414 REQUEST_URI_TOO_LONG’ result. */
  val UriTooLong = new Status(REQUEST_URI_TOO_LONG)

  /** Generates a ‘415 UNSUPPORTED_MEDIA_TYPE’ result. */
  val UnsupportedMediaType = new Status(UNSUPPORTED_MEDIA_TYPE)

  /** Generates a ‘417 EXPECTATION_FAILED’ result. */
  val ExpectationFailed = new Status(EXPECTATION_FAILED)

  /** Generates a ‘418 IM_A_TEAPOT’ result. */
  val ImATeapot = new Status(IM_A_TEAPOT)

  /** Generates a ‘422 UNPROCESSABLE_ENTITY’ result. */
  val UnprocessableEntity = new Status(UNPROCESSABLE_ENTITY)

  /** Generates a ‘423 LOCKED’ result. */
  val Locked = new Status(LOCKED)

  /** Generates a ‘424 FAILED_DEPENDENCY’ result. */
  val FailedDependency = new Status(FAILED_DEPENDENCY)

  /** Generates a ‘428 PRECONDITION_REQUIRED’ result. */
  val PreconditionRequired = new Status(PRECONDITION_REQUIRED)

  /** Generates a ‘429 TOO_MANY_REQUESTS’ result. */
  val TooManyRequests = new Status(TOO_MANY_REQUESTS)

  /** Generates a ‘431 REQUEST_HEADER_FIELDS_TOO_LARGE’ result. */
  val RequestHeaderFieldsTooLarge = new Status(REQUEST_HEADER_FIELDS_TOO_LARGE)

  /** Generates a ‘500 INTERNAL_SERVER_ERROR’ result. */
  val InternalServerError = new Status(INTERNAL_SERVER_ERROR)

  /** Generates a ‘501 NOT_IMPLEMENTED’ result. */
  val NotImplemented = new Status(NOT_IMPLEMENTED)

  /** Generates a ‘502 BAD_GATEWAY’ result. */
  val BadGateway = new Status(BAD_GATEWAY)

  /** Generates a ‘503 SERVICE_UNAVAILABLE’ result. */
  val ServiceUnavailable = new Status(SERVICE_UNAVAILABLE)

  /** Generates a ‘504 GATEWAY_TIMEOUT’ result. */
  val GatewayTimeout = new Status(GATEWAY_TIMEOUT)

  /** Generates a ‘505 HTTP_VERSION_NOT_SUPPORTED’ result. */
  val HttpVersionNotSupported = new Status(HTTP_VERSION_NOT_SUPPORTED)

  /** Generates a ‘507 INSUFFICIENT_STORAGE’ result. */
  val InsufficientStorage = new Status(INSUFFICIENT_STORAGE)

  /** Generates a ‘511 NETWORK_AUTHENTICATION_REQUIRED’ result. */
  val NetworkAuthenticationRequired = new Status(NETWORK_AUTHENTICATION_REQUIRED)

  /**
   * Generates a simple result.
   *
   * @param code the status code
   */
  def Status(code: Int) = new Status(code)

  /**
   * Generates a redirect simple result.
   *
   * @param url the URL to redirect to
   * @param statusCode HTTP status
   */
  def Redirect(url: String, statusCode: Int): Result = Redirect(url, Map.empty, statusCode)

  /**
   * Generates a redirect simple result.
   *
   * @param url the URL to redirect to
   * @param queryStringParams queryString parameters to add to the queryString
   * @param status HTTP status for redirect, such as SEE_OTHER, MOVED_TEMPORARILY or MOVED_PERMANENTLY
   */
  def Redirect(url: String, queryStringParams: Map[String, Seq[String]] = Map.empty, status: Int = SEE_OTHER) = {
    if (!play.api.http.Status.isRedirect(status)) {
      Results.logger
        .forMode(Mode.Dev)
        .warn(s"You are using status code $status which is not a redirect code!")
    }
    val fullUrl: String = Results.addQueryStringParams(url, queryStringParams)
    Status(status).withHeaders(LOCATION -> fullUrl)
  }

  /**
   * Generates a redirect simple result.
   *
   * @param call Call defining the URL to redirect to, which typically comes from the reverse router
   */
  def Redirect(call: Call): Result = Redirect(call.path)

  /**
   * Generates a redirect simple result.
   *
   * @param call Call defining the URL to redirect to, which typically comes from the reverse router
   * @param status HTTP status for redirect, such as SEE_OTHER, MOVED_TEMPORARILY or MOVED_PERMANENTLY
   */
  def Redirect(call: Call, status: Int): Result = Redirect(call.path, Map.empty, status)
}

/*
 * Copyright (C) Lightbend Inc. <https://www.lightbend.com>
 */

package play.api.http

/**
 * Defines common HTTP Content-Type header values, according to the current available Codec.
 */
object ContentTypes extends ContentTypes

/** Defines common HTTP Content-Type header values, according to the current available Codec. */
trait ContentTypes {
  import play.api.mvc.Codec

  /**
   * Content-Type of text.
   */
  def TEXT(implicit codec: Codec) = withCharset(MimeTypes.TEXT)

  /**
   * Content-Type of html.
   */
  def HTML(implicit codec: Codec) = withCharset(MimeTypes.HTML)

  /**
   * Content-Type of xhtml.
   */
  def XHTML(implicit codec: Codec) = withCharset(MimeTypes.XHTML)

  /**
   * Content-Type of xml.
   */
  def XML(implicit codec: Codec) = withCharset(MimeTypes.XML)

  /**
   * Content-Type of css.
   */
  def CSS(implicit codec: Codec) = withCharset(MimeTypes.CSS)

  /**
   * Content-Type of javascript.
   */
  def JAVASCRIPT(implicit codec: Codec) = withCharset(MimeTypes.JAVASCRIPT)

  /**
   * Content-Type of server sent events.
   */
  def EVENT_STREAM(implicit codec: Codec) = withCharset(MimeTypes.EVENT_STREAM)

  /**
   * Content-Type of application cache.
   */
  val CACHE_MANIFEST = withCharset(MimeTypes.CACHE_MANIFEST)(Codec.utf_8)

  /**
   * Content-Type of json. This content type does not define a charset parameter.
   */
  val JSON = MimeTypes.JSON

  /**
   * Content-Type of form-urlencoded. This content type does not define a charset parameter.
   */
  val FORM = MimeTypes.FORM

  /**
   * Content-Type of binary data.
   */
  val BINARY = MimeTypes.BINARY

  /**
   * @return the `codec` charset appended to `mimeType`
   */
  def withCharset(mimeType: String)(implicit codec: Codec) = s"$mimeType; charset=${codec.charset}"
}

/**
 * Standard HTTP Verbs
 */
object HttpVerbs extends HttpVerbs

/**
 * Standard HTTP Verbs
 */
trait HttpVerbs {
  val GET     = "GET"
  val POST    = "POST"
  val PUT     = "PUT"
  val PATCH   = "PATCH"
  val DELETE  = "DELETE"
  val HEAD    = "HEAD"
  val OPTIONS = "OPTIONS"
}

/** Common HTTP MIME types */
object MimeTypes extends MimeTypes

/** Common HTTP MIME types */
trait MimeTypes {

  /**
   * Content-Type of text.
   */
  val TEXT = "text/plain"

  /**
   * Content-Type of html.
   */
  val HTML = "text/html"

  /**
   * Content-Type of json.
   */
  val JSON = "application/json"

  /**
   * Content-Type of xml.
   */
  val XML = "application/xml"

  /**
   * Content-Type of xhtml.
   */
  val XHTML = "application/xhtml+xml"

  /**
   * Content-Type of css.
   */
  val CSS = "text/css"

  /**
   * Content-Type of javascript.
   */
  val JAVASCRIPT = "application/javascript"

  /**
   * Content-Type of form-urlencoded.
   */
  val FORM = "application/x-www-form-urlencoded"

  /**
   * Content-Type of server sent events.
   */
  val EVENT_STREAM = "text/event-stream"

  /**
   * Content-Type of binary data.
   */
  val BINARY = "application/octet-stream"

  /**
   * Content-Type of application cache.
   */
  val CACHE_MANIFEST = "text/cache-manifest"
}

/**
 * Defines all standard HTTP status codes, with additional helpers for determining the type of status.
 */
object Status extends Status {
  def isInformational(status: Int): Boolean = status / 100 == 1
  def isSuccessful(status: Int): Boolean    = status / 100 == 2
  def isRedirect(status: Int): Boolean      = status / 100 == 3
  def isClientError(status: Int): Boolean   = status / 100 == 4
  def isServerError(status: Int): Boolean   = status / 100 == 5
}

/**
 * Defines all standard HTTP status codes.
 *
 * See <a href="https://tools.ietf.org/html/rfc7231">RFC 7231</a> and <a href="https://tools.ietf.org/html/rfc6585">RFC 6585</a>.
 */
trait Status {
  val CONTINUE            = 100
  val SWITCHING_PROTOCOLS = 101

  val OK                            = 200
  val CREATED                       = 201
  val ACCEPTED                      = 202
  val NON_AUTHORITATIVE_INFORMATION = 203
  val NO_CONTENT                    = 204
  val RESET_CONTENT                 = 205
  val PARTIAL_CONTENT               = 206
  val MULTI_STATUS                  = 207

  val MULTIPLE_CHOICES   = 300
  val MOVED_PERMANENTLY  = 301
  val FOUND              = 302
  val SEE_OTHER          = 303
  val NOT_MODIFIED       = 304
  val USE_PROXY          = 305
  val TEMPORARY_REDIRECT = 307
  val PERMANENT_REDIRECT = 308

  val BAD_REQUEST                     = 400
  val UNAUTHORIZED                    = 401
  val PAYMENT_REQUIRED                = 402
  val FORBIDDEN                       = 403
  val NOT_FOUND                       = 404
  val METHOD_NOT_ALLOWED              = 405
  val NOT_ACCEPTABLE                  = 406
  val PROXY_AUTHENTICATION_REQUIRED   = 407
  val REQUEST_TIMEOUT                 = 408
  val CONFLICT                        = 409
  val GONE                            = 410
  val LENGTH_REQUIRED                 = 411
  val PRECONDITION_FAILED             = 412
  val REQUEST_ENTITY_TOO_LARGE        = 413
  val REQUEST_URI_TOO_LONG            = 414
  val UNSUPPORTED_MEDIA_TYPE          = 415
  val REQUESTED_RANGE_NOT_SATISFIABLE = 416
  val EXPECTATION_FAILED              = 417
  val IM_A_TEAPOT                     = 418
  val UNPROCESSABLE_ENTITY            = 422
  val LOCKED                          = 423
  val FAILED_DEPENDENCY               = 424
  val UPGRADE_REQUIRED                = 426
  val PRECONDITION_REQUIRED           = 428
  val TOO_MANY_REQUESTS               = 429
  val REQUEST_HEADER_FIELDS_TOO_LARGE = 431

  val INTERNAL_SERVER_ERROR           = 500
  val NOT_IMPLEMENTED                 = 501
  val BAD_GATEWAY                     = 502
  val SERVICE_UNAVAILABLE             = 503
  val GATEWAY_TIMEOUT                 = 504
  val HTTP_VERSION_NOT_SUPPORTED      = 505
  val INSUFFICIENT_STORAGE            = 507
  val NETWORK_AUTHENTICATION_REQUIRED = 511
}

/** Defines all standard HTTP headers. */
object HeaderNames extends HeaderNames

/** Defines all standard HTTP headers. */
trait HeaderNames {
  val ACCEPT          = "Accept"
  val ACCEPT_CHARSET  = "Accept-Charset"
  val ACCEPT_ENCODING = "Accept-Encoding"
  val ACCEPT_LANGUAGE = "Accept-Language"
  val ACCEPT_RANGES   = "Accept-Ranges"
  val AGE             = "Age"
  val ALLOW           = "Allow"
  val AUTHORIZATION   = "Authorization"

  val CACHE_CONTROL             = "Cache-Control"
  val CONNECTION                = "Connection"
  val CONTENT_DISPOSITION       = "Content-Disposition"
  val CONTENT_ENCODING          = "Content-Encoding"
  val CONTENT_LANGUAGE          = "Content-Language"
  val CONTENT_LENGTH            = "Content-Length"
  val CONTENT_LOCATION          = "Content-Location"
  val CONTENT_MD5               = "Content-MD5"
  val CONTENT_RANGE             = "Content-Range"
  val CONTENT_TRANSFER_ENCODING = "Content-Transfer-Encoding"
  val CONTENT_TYPE              = "Content-Type"
  val COOKIE                    = "Cookie"

  val DATE = "Date"

  val ETAG    = "ETag"
  val EXPECT  = "Expect"
  val EXPIRES = "Expires"

  val FROM = "From"

  val HOST = "Host"

  val IF_MATCH            = "If-Match"
  val IF_MODIFIED_SINCE   = "If-Modified-Since"
  val IF_NONE_MATCH       = "If-None-Match"
  val IF_RANGE            = "If-Range"
  val IF_UNMODIFIED_SINCE = "If-Unmodified-Since"

  val LAST_MODIFIED = "Last-Modified"
  val LINK          = "Link"
  val LOCATION      = "Location"

  val MAX_FORWARDS = "Max-Forwards"

  val PRAGMA              = "Pragma"
  val PROXY_AUTHENTICATE  = "Proxy-Authenticate"
  val PROXY_AUTHORIZATION = "Proxy-Authorization"

  val RANGE       = "Range"
  val REFERER     = "Referer"
  val RETRY_AFTER = "Retry-After"

  val SERVER = "Server"

  val SET_COOKIE  = "Set-Cookie"
  val SET_COOKIE2 = "Set-Cookie2"

  val TE                = "Te"
  val TRAILER           = "Trailer"
  val TRANSFER_ENCODING = "Transfer-Encoding"

  val UPGRADE    = "Upgrade"
  val USER_AGENT = "User-Agent"

  val VARY = "Vary"
  val VIA  = "Via"

  val WARNING          = "Warning"
  val WWW_AUTHENTICATE = "WWW-Authenticate"

  val FORWARDED         = "Forwarded"
  val X_FORWARDED_FOR   = "X-Forwarded-For"
  val X_FORWARDED_HOST  = "X-Forwarded-Host"
  val X_FORWARDED_PORT  = "X-Forwarded-Port"
  val X_FORWARDED_PROTO = "X-Forwarded-Proto"

  val X_REQUESTED_WITH = "X-Requested-With"

  val ACCESS_CONTROL_ALLOW_ORIGIN      = "Access-Control-Allow-Origin"
  val ACCESS_CONTROL_EXPOSE_HEADERS    = "Access-Control-Expose-Headers"
  val ACCESS_CONTROL_MAX_AGE           = "Access-Control-Max-Age"
  val ACCESS_CONTROL_ALLOW_CREDENTIALS = "Access-Control-Allow-Credentials"
  val ACCESS_CONTROL_ALLOW_METHODS     = "Access-Control-Allow-Methods"
  val ACCESS_CONTROL_ALLOW_HEADERS     = "Access-Control-Allow-Headers"

  val ORIGIN                         = "Origin"
  val ACCESS_CONTROL_REQUEST_METHOD  = "Access-Control-Request-Method"
  val ACCESS_CONTROL_REQUEST_HEADERS = "Access-Control-Request-Headers"

  val STRICT_TRANSPORT_SECURITY = "Strict-Transport-Security"

  val X_FRAME_OPTIONS                   = "X-Frame-Options"
  val X_XSS_PROTECTION                  = "X-XSS-Protection"
  val X_CONTENT_TYPE_OPTIONS            = "X-Content-Type-Options"
  val X_PERMITTED_CROSS_DOMAIN_POLICIES = "X-Permitted-Cross-Domain-Policies"
  val REFERRER_POLICY                   = "Referrer-Policy"

  val CONTENT_SECURITY_POLICY                        = "Content-Security-Policy"
  val CONTENT_SECURITY_POLICY_REPORT_ONLY: String    = "Content-Security-Policy-Report-Only"
  val X_CONTENT_SECURITY_POLICY_NONCE_HEADER: String = "X-Content-Security-Policy-Nonce"
}

/**
 * Defines HTTP protocol constants
 */
object HttpProtocol extends HttpProtocol

/**
 * Defines HTTP protocol constants
 */
trait HttpProtocol {
  // Versions
  val HTTP_1_0 = "HTTP/1.0"
  val HTTP_1_1 = "HTTP/1.1"
  val HTTP_2_0 = "HTTP/2.0"

  // Other HTTP protocol values
  val CHUNKED = "chunked"
}

[0m2021.04.01 14:53:31 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 14:53:32 INFO  time: compiled root in 1s[0m
[0m2021.04.01 14:54:06 INFO  compiling root (4 scala sources and 1 java source)[0m
[0m2021.04.01 14:54:06 INFO  time: compiled root in 0.34s[0m
[0m2021.04.01 14:54:06 INFO  compiling root (4 scala sources and 1 java source)[0m
[0m2021.04.01 14:54:06 INFO  time: compiled root in 0.17s[0m
/*
 * Copyright (C) Lightbend Inc. <https://www.lightbend.com>
 */

package play.api.mvc

import javax.inject.Inject
import play.api.data.FormBinding
import play.api.http._
import play.api.i18n.Langs
import play.api.i18n.MessagesApi
import play.twirl.api.Html

import scala.concurrent.ExecutionContext

/**
 * Useful mixins for controller classes.
 *
 * If you wish to write a controller with minimal dependencies, you can mix in this trait, which includes helpers and
 * useful constants.
 *
 * {{{
 *   class MyController @Inject() (action: DefaultActionBuilder, parse: PlayBodyParsers) extends ControllerHelpers {
 *     def index = action(parse.text) {
 *       Ok
 *     }
 *   }
 * }}}
 */
trait ControllerHelpers
    extends Results
    with HttpProtocol
    with Status
    with HeaderNames
    with ContentTypes
    with RequestExtractors
    with Rendering
    with RequestImplicits {

  /**
   * Used to mark an action that is still not implemented, e.g.:
   *
   * {{{
   *   def action(query: String) = TODO
   * }}}
   */
  lazy val TODO: Action[AnyContent] = ActionBuilder.ignoringBody { implicit request =>
    NotImplemented[Html](views.html.defaultpages.todo())
  }
}

object ControllerHelpers extends ControllerHelpers

/**
 * Useful prewired mixins for controller components, assuming an available [[ControllerComponents]].
 *
 * If you want to extend your own [[AbstractController]] but want to use a different base "Action",
 * you can mix in this trait.
 */
trait BaseControllerHelpers extends ControllerHelpers {

  /**
   * The components needed to use the controller methods
   */
  protected def controllerComponents: ControllerComponents

  /**
   * The default body parsers provided by Play. This can be used along with the Action helper to customize the body
   * parser, for example:
   *
   * {{{
   *   def foo(query: String) = Action(parse.tolerantJson) { request =>
   *     Ok(request.body)
   *   }
   * }}}
   */
  def parse: PlayBodyParsers = controllerComponents.parsers

  implicit lazy val defaultFormBinding: FormBinding = parse.formBinding(parse.DefaultMaxTextLength)

  /**
   * The default execution context provided by Play. You should use this for non-blocking code only. You can do so by
   * passing it explicitly, or by defining an implicit in your controller like so:
   *
   * {{{
   *   implicit lazy val executionContext = defaultExecutionContext
   * }}}
   */
  def defaultExecutionContext: ExecutionContext = controllerComponents.executionContext

  /**
   * The MessagesApi provided by Play. This can be used to provide the MessagesApi needed by play.api.i18n.I18nSupport.
   */
  implicit def messagesApi: MessagesApi = controllerComponents.messagesApi

  /**
   * The default Langs provided by Play. Can be used to determine the application's supported languages.
   */
  implicit def supportedLangs: Langs = controllerComponents.langs

  /**
   * The default FileMimeTypes provided by Play. Used to map between file name extensions and mime types.
   */
  implicit def fileMimeTypes: FileMimeTypes = controllerComponents.fileMimeTypes
}

/**
 * Useful mixin for methods that do implicit transformations of a request
 */
trait RequestImplicits {

  /**
   * Retrieves the session implicitly from the request.
   *
   * For example:
   * {{{
   * def index(name:String) = Action { implicit request =>
   *   val username = request2session("username")
   *   Ok("Hello " + username)
   * }
   * }}}
   */
  implicit def request2session(implicit request: RequestHeader): Session = request.session

  /**
   * Retrieve the flash scope implicitly from the request.
   *
   * For example:
   * {{{
   * def index(name:String) = Action { implicit request =>
   *   val message = request2flash("message")
   *   Ok("Got " + message)
   * }
   * }}}
   */
  implicit def request2flash(implicit request: RequestHeader): Flash = request.flash
}

/**
 * Defines utility methods to generate `Action` and `Results` types.
 *
 * For example:
 * {{{
 * class HomeController @Inject() (val controllerComponents: ControllerComponents) extends BaseController {
 *
 *   def hello(name:String) = Action { request =>
 *     Ok("Hello " + name)
 *   }
 *
 * }
 * }}}
 *
 *
 * This is intended to provide the idiomatic Play API for actions, allowing you to use "Action" for the default
 * action builder and "parse" to access Play's default body parsers. You may want to extend this to provide your own
 * base controller class, or write your own version with similar code.
 */
trait BaseController extends BaseControllerHelpers {

  /**
   * The default ActionBuilder. Used to construct an action, for example:
   *
   * {{{
   *   def foo(query: String) = Action {
   *     Ok
   *   }
   * }}}
   *
   * This is meant to be a replacement for the now-deprecated Action object, and can be used in the same way.
   */
  def Action: ActionBuilder[Request, AnyContent] = controllerComponents.actionBuilder
}

/**
 * An abstract implementation of [[BaseController]] to make it slightly easier to use.
 */
abstract class AbstractController(protected val controllerComponents: ControllerComponents) extends BaseController

/**
 * A variation of [[BaseController]] that gets its components via method injection.
 */
trait InjectedController extends BaseController {
  private[this] var _components: ControllerComponents = _

  protected override def controllerComponents: ControllerComponents = {
    if (_components == null) fallbackControllerComponents else _components
  }

  /**
   * Call this method to set the [[ControllerComponents]] instance.
   */
  @Inject
  def setControllerComponents(components: ControllerComponents): Unit = {
    _components = components
  }

  /**
   * Defines fallback components to use in case setControllerComponents has not been called.
   */
  protected def fallbackControllerComponents: ControllerComponents = {
    throw new NoSuchElementException(
      "ControllerComponents not set! Call setControllerComponents or create the instance with dependency injection."
    )
  }
}

/**
 * A variation of [[MessagesAbstractController]] that gets its components via method injection.
 */
trait MessagesInjectedController extends MessagesBaseController {
  private[this] var _components: MessagesControllerComponents = _

  protected override def controllerComponents: MessagesControllerComponents = {
    if (_components == null) fallbackControllerComponents else _components
  }

  /**
   * Call this method to set the [[ControllerComponents]] instance.
   */
  @Inject
  def setControllerComponents(components: MessagesControllerComponents): Unit = {
    _components = components
  }

  /**
   * Defines fallback components to use in case setControllerComponents has not been called.
   */
  protected def fallbackControllerComponents: MessagesControllerComponents = {
    throw new NoSuchElementException(
      "ControllerComponents not set! Call setControllerComponents or create the instance with dependency injection."
    )
  }
}

/**
 * The base controller components dependencies that most controllers rely on.
 */
trait ControllerComponents {
  def actionBuilder: ActionBuilder[Request, AnyContent]
  def parsers: PlayBodyParsers
  def messagesApi: MessagesApi
  def langs: Langs
  def fileMimeTypes: FileMimeTypes
  def executionContext: scala.concurrent.ExecutionContext
}

case class DefaultControllerComponents @Inject() (
    actionBuilder: DefaultActionBuilder,
    parsers: PlayBodyParsers,
    messagesApi: MessagesApi,
    langs: Langs,
    fileMimeTypes: FileMimeTypes,
    executionContext: scala.concurrent.ExecutionContext
) extends ControllerComponents

Apr 01, 2021 3:01:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 322
Apr 01, 2021 3:01:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 328
[0m2021.04.01 15:02:51 INFO  compiling root (4 scala sources and 1 java source)[0m
[0m2021.04.01 15:02:53 INFO  time: compiled root in 1.97s[0m
[0m2021.04.01 15:05:40 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 15:05:41 INFO  time: compiled root in 1.14s[0m
Apr 01, 2021 3:06:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 374
Apr 01, 2021 3:16:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 388
[0m2021.04.01 15:18:38 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 15:18:38 INFO  time: compiled root in 0.85s[0m
[0m2021.04.01 15:19:02 INFO  compiling root-test (1 scala source)[0m
[0m2021.04.01 15:19:02 INFO  time: compiled root-test in 0.34s[0m
[0m2021.04.01 15:22:28 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 15:22:28 INFO  time: compiled root in 0.16s[0m
[0m2021.04.01 15:22:39 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 15:22:41 INFO  time: compiled root in 1.78s[0m
[0m2021.04.01 15:22:56 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 15:22:56 INFO  time: compiled root in 0.79s[0m
[0m2021.04.01 15:29:16 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 15:29:16 INFO  time: compiled root in 0.2s[0m
[0m2021.04.01 15:29:25 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 15:29:25 INFO  time: compiled root in 0.15s[0m
[0m2021.04.01 15:29:45 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 15:29:45 INFO  time: compiled root in 0.15s[0m
[0m2021.04.01 15:31:44 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 15:31:44 INFO  time: compiled root in 0.15s[0m
[0m2021.04.01 15:34:31 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 15:34:31 INFO  time: compiled root in 0.16s[0m
/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package scala

object Option {

  import scala.language.implicitConversions

  /** An implicit conversion that converts an option to an iterable value
   */
  implicit def option2Iterable[A](xo: Option[A]): Iterable[A] = xo.toList

  /** An Option factory which creates Some(x) if the argument is not null,
   *  and None if it is null.
   *
   *  @param  x the value
   *  @return   Some(value) if value != null, None if value == null
   */
  def apply[A](x: A): Option[A] = if (x == null) None else Some(x)

  /** An Option factory which returns `None` in a manner consistent with
   *  the collections hierarchy.
   */
  def empty[A] : Option[A] = None
}

/** Represents optional values. Instances of `Option`
 *  are either an instance of $some or the object $none.
 *
 *  The most idiomatic way to use an $option instance is to treat it
 *  as a collection or monad and use `map`,`flatMap`, `filter`, or
 *  `foreach`:
 *
 *  {{{
 *  val name: Option[String] = request getParameter "name"
 *  val upper = name map { _.trim } filter { _.length != 0 } map { _.toUpperCase }
 *  println(upper getOrElse "")
 *  }}}
 *
 *  Note that this is equivalent to {{{
 *  val upper = for {
 *    name <- request getParameter "name"
 *    trimmed <- Some(name.trim)
 *    upper <- Some(trimmed.toUpperCase) if trimmed.length != 0
 *  } yield upper
 *  println(upper getOrElse "")
 *  }}}
 *
 *  Because of how for comprehension works, if $none is returned
 *  from `request.getParameter`, the entire expression results in
 *  $none
 *
 *  This allows for sophisticated chaining of $option values without
 *  having to check for the existence of a value.
 *
 * These are useful methods that exist for both $some and $none.
 *  - [[isDefined]] — True if not empty
 *  - [[isEmpty]] — True if empty
 *  - [[nonEmpty]] — True if not empty
 *  - [[orElse]] — Evaluate and return alternate optional value if empty
 *  - [[getOrElse]] — Evaluate and return alternate value if empty
 *  - [[get]] — Return value, throw exception if empty
 *  - [[fold]] —  Apply function on optional value, return default if empty
 *  - [[map]] — Apply a function on the optional value
 *  - [[flatMap]] — Same as map but function must return an optional value
 *  - [[foreach]] — Apply a procedure on option value
 *  - [[collect]] — Apply partial pattern match on optional value
 *  - [[filter]] — An optional value satisfies predicate
 *  - [[filterNot]] — An optional value doesn't satisfy predicate
 *  - [[exists]] — Apply predicate on optional value, or false if empty
 *  - [[forall]] — Apply predicate on optional value, or true if empty
 *  - [[contains]] — Checks if value equals optional value, or false if empty
 *  - [[toList]] — Unary list of optional value, otherwise the empty list
 *
 *  A less-idiomatic way to use $option values is via pattern matching: {{{
 *  val nameMaybe = request getParameter "name"
 *  nameMaybe match {
 *    case Some(name) =>
 *      println(name.trim.toUppercase)
 *    case None =>
 *      println("No name value")
 *  }
 *  }}}
 *
 * Interacting with code that can occasionally return null can be
 * safely wrapped in $option to become $none and $some otherwise. {{{
 * val abc = new java.util.HashMap[Int, String]
 * abc.put(1, "A")
 * bMaybe = Option(abc.get(2))
 * bMaybe match {
 *   case Some(b) =>
 *     println(s"Found \$b")
 *   case None =>
 *     println("Not found")
 * }
 * }}}
 *
 *  @note Many of the methods in here are duplicative with those
 *  in the Traversable hierarchy, but they are duplicated for a reason:
 *  the implicit conversion tends to leave one with an Iterable in
 *  situations where one could have retained an Option.
 *
 *  @author  Martin Odersky
 *  @author  Matthias Zenger
 *  @since   1.1
 *  @define none `None`
 *  @define some [[scala.Some]]
 *  @define option [[scala.Option]]
 *  @define p `p`
 *  @define f `f`
 *  @define coll option
 *  @define Coll `Option`
 *  @define orderDependent
 *  @define orderDependentFold
 *  @define mayNotTerminateInf
 *  @define willNotTerminateInf
 *  @define collectExample
 *  @define undefinedorder
 *  @define thatinfo the class of the returned collection. In the standard library configuration, `That` is `Iterable[B]`
 *  @define bfinfo an implicit value of class `CanBuildFrom` which determines the result class `That` from the current
 *    representation type `Repr` and the new element type `B`.
 */
@SerialVersionUID(-114498752079829388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4
sealed abstract class Option[+A] extends Product with Serializable {
  self =>

  /** Returns true if the option is $none, false otherwise.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(_) => false
   *   case None    => true
   * }
   * }}}
   */
  def isEmpty: Boolean

  /** Returns true if the option is an instance of $some, false otherwise.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(_) => true
   *   case None    => false
   * }
   * }}}
   */
  def isDefined: Boolean = !isEmpty

  /** Returns the option's value.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => x
   *   case None    => throw new Exception
   * }
   * }}}
   *  @note The option must be nonempty.
   *  @throws java.util.NoSuchElementException if the option is empty.
   */
  def get: A

  /** Returns the option's value if the option is nonempty, otherwise
   * return the result of evaluating `default`.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => x
   *   case None    => default
   * }
   * }}}
   *
   *  @param default  the default expression.
   */
  @inline final def getOrElse[B >: A](default: => B): B =
    if (isEmpty) default else this.get

  /** Returns the option's value if it is nonempty,
   * or `null` if it is empty.
   *
   * Although the use of null is discouraged, code written to use
   * $option must often interface with code that expects and returns nulls.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => x
   *   case None    => null
   * }
   * }}}
   * @example {{{
   * val initialText: Option[String] = getInitialText
   * val textField = new JComponent(initialText.orNull,20)
   * }}}
   */
  @inline final def orNull[A1 >: A](implicit ev: Null <:< A1): A1 = this getOrElse ev(null)

  /** Returns a $some containing the result of applying $f to this $option's
   * value if this $option is nonempty.
   * Otherwise return $none.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => Some(f(x))
   *   case None    => None
   * }
   * }}}
   *  @note This is similar to `flatMap` except here,
   *  $f does not need to wrap its result in an $option.
   *
   *  @param  f   the function to apply
   *  @see flatMap
   *  @see foreach
   */
  @inline final def map[B](f: A => B): Option[B] =
    if (isEmpty) None else Some(f(this.get))

  /** Returns the result of applying $f to this $option's
   *  value if the $option is nonempty.  Otherwise, evaluates
   *  expression `ifEmpty`.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => f(x)
   *   case None    => ifEmpty
   * }
   * }}}
   * This is also equivalent to:
   * {{{
   * option map f getOrElse ifEmpty
   * }}}
   *  @param  ifEmpty the expression to evaluate if empty.
   *  @param  f       the function to apply if nonempty.
   */
  @inline final def fold[B](ifEmpty: => B)(f: A => B): B =
    if (isEmpty) ifEmpty else f(this.get)

  /** Returns the result of applying $f to this $option's value if
   * this $option is nonempty.
   * Returns $none if this $option is empty.
   * Slightly different from `map` in that $f is expected to
   * return an $option (which could be $none).
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => f(x)
   *   case None    => None
   * }
   * }}}
   *  @param  f   the function to apply
   *  @see map
   *  @see foreach
   */
  @inline final def flatMap[B](f: A => Option[B]): Option[B] =
    if (isEmpty) None else f(this.get)

  def flatten[B](implicit ev: A <:< Option[B]): Option[B] =
    if (isEmpty) None else ev(this.get)

  /** Returns this $option if it is nonempty '''and''' applying the predicate $p to
   * this $option's value returns true. Otherwise, return $none.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) if p(x) => Some(x)
   *   case _               => None
   * }
   * }}}
   *  @param  p   the predicate used for testing.
   */
  @inline final def filter(p: A => Boolean): Option[A] =
    if (isEmpty || p(this.get)) this else None

  /** Returns this $option if it is nonempty '''and''' applying the predicate $p to
   * this $option's value returns false. Otherwise, return $none.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) if !p(x) => Some(x)
   *   case _                => None
   * }
   * }}}
   *  @param  p   the predicate used for testing.
   */
  @inline final def filterNot(p: A => Boolean): Option[A] =
    if (isEmpty || !p(this.get)) this else None

  /** Returns false if the option is $none, true otherwise.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(_) => true
   *   case None    => false
   * }
   * }}}
   *  @note   Implemented here to avoid the implicit conversion to Iterable.
   */
  final def nonEmpty = isDefined

  /** Necessary to keep $option from being implicitly converted to
   *  [[scala.collection.Iterable]] in `for` comprehensions.
   */
  @inline final def withFilter(p: A => Boolean): WithFilter = new WithFilter(p)

  /** We need a whole WithFilter class to honor the "doesn't create a new
   *  collection" contract even though it seems unlikely to matter much in a
   *  collection with max size 1.
   */
  class WithFilter(p: A => Boolean) {
    def map[B](f: A => B): Option[B] = self filter p map f
    def flatMap[B](f: A => Option[B]): Option[B] = self filter p flatMap f
    def foreach[U](f: A => U): Unit = self filter p foreach f
    def withFilter(q: A => Boolean): WithFilter = new WithFilter(x => p(x) && q(x))
  }

  /** Tests whether the option contains a given value as an element.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => x == elem
   *   case None    => false
   * }
   * }}}
   *  @example {{{
   *  // Returns true because Some instance contains string "something" which equals "something".
   *  Some("something") contains "something"
   *
   *  // Returns false because "something" != "anything".
   *  Some("something") contains "anything"
   *
   *  // Returns false when method called on None.
   *  None contains "anything"
   *  }}}
   *
   *  @param elem the element to test.
   *  @return `true` if the option has an element that is equal (as
   *  determined by `==`) to `elem`, `false` otherwise.
   */
  final def contains[A1 >: A](elem: A1): Boolean =
    !isEmpty && this.get == elem

  /** Returns true if this option is nonempty '''and''' the predicate
   * $p returns true when applied to this $option's value.
   * Otherwise, returns false.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => p(x)
   *   case None    => false
   * }
   * }}}
   *  @param  p   the predicate to test
   */
  @inline final def exists(p: A => Boolean): Boolean =
    !isEmpty && p(this.get)

  /** Returns true if this option is empty '''or''' the predicate
   * $p returns true when applied to this $option's value.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => p(x)
   *   case None    => true
   * }
   * }}}
   *  @param  p   the predicate to test
   */
  @inline final def forall(p: A => Boolean): Boolean = isEmpty || p(this.get)

  /** Apply the given procedure $f to the option's value,
   *  if it is nonempty. Otherwise, do nothing.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => f(x)
   *   case None    => ()
   * }
   * }}}
   *  @param  f   the procedure to apply.
   *  @see map
   *  @see flatMap
   */
  @inline final def foreach[U](f: A => U) {
    if (!isEmpty) f(this.get)
  }

  /** Returns a $some containing the result of
   * applying `pf` to this $option's contained
   * value, '''if''' this option is
   * nonempty '''and''' `pf` is defined for that value.
   * Returns $none otherwise.
   *
   *  @example {{{
   *  // Returns Some(HTTP) because the partial function covers the case.
   *  Some("http") collect {case "http" => "HTTP"}
   *
   *  // Returns None because the partial function doesn't cover the case.
   *  Some("ftp") collect {case "http" => "HTTP"}
   *
   *  // Returns None because the option is empty. There is no value to pass to the partial function.
   *  None collect {case value => value}
   *  }}}
   *
   *  @param  pf   the partial function.
   *  @return the result of applying `pf` to this $option's
   *  value (if possible), or $none.
   */
  @inline final def collect[B](pf: PartialFunction[A, B]): Option[B] =
    if (!isEmpty) pf.lift(this.get) else None

  /** Returns this $option if it is nonempty,
   *  otherwise return the result of evaluating `alternative`.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => Some(x)
   *   case None    => alternative
   * }
   * }}}
   *  @param alternative the alternative expression.
   */
  @inline final def orElse[B >: A](alternative: => Option[B]): Option[B] =
    if (isEmpty) alternative else this

  /** Returns a singleton iterator returning the $option's value
   * if it is nonempty, or an empty iterator if the option is empty.
   */
  def iterator: Iterator[A] =
    if (isEmpty) collection.Iterator.empty else collection.Iterator.single(this.get)

  /** Returns a singleton list containing the $option's value
   * if it is nonempty, or the empty list if the $option is empty.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => List(x)
   *   case None    => Nil
   * }
   * }}}
   */
  def toList: List[A] =
    if (isEmpty) List() else new ::(this.get, Nil)

  /** Returns a [[scala.util.Left]] containing the given
   * argument `left` if this $option is empty, or
   * a [[scala.util.Right]] containing this $option's value if
   * this is nonempty.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => Right(x)
   *   case None    => Left(left)
   * }
   * }}}
   * @param left the expression to evaluate and return if this is empty
   * @see toLeft
   */
  @inline final def toRight[X](left: => X): Either[X, A] =
    if (isEmpty) Left(left) else Right(this.get)

  /** Returns a [[scala.util.Right]] containing the given
   * argument `right` if this is empty, or
   * a [[scala.util.Left]] containing this $option's value
   * if this $option is nonempty.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => Left(x)
   *   case None    => Right(right)
   * }
   * }}}
   * @param right the expression to evaluate and return if this is empty
   * @see toRight
   */
  @inline final def toLeft[X](right: => X): Either[A, X] =
    if (isEmpty) Right(right) else Left(this.get)
}

/** Class `Some[A]` represents existing values of type
 *  `A`.
 *
 *  @author  Martin Odersky
 *  @since   1.0
 */
@SerialVersionUID(1234815782226070388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4
final case class Some[+A](@deprecatedName('x, "2.12.0") value: A) extends Option[A] {
  def isEmpty = false
  def get = value

  @deprecated("Use .value instead.", "2.12.0") def x: A = value
}


/** This case object represents non-existent values.
 *
 *  @author  Martin Odersky
 *  @since   1.0
 */
@SerialVersionUID(5066590221178148012L) // value computed by serialver for 2.11.2, annotation added in 2.11.4
case object None extends Option[Nothing] {
  def isEmpty = true
  def get = throw new NoSuchElementException("None.get")
}

[0m2021.04.01 15:35:25 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 15:35:25 INFO  time: compiled root in 0.17s[0m
[0m2021.04.01 15:36:40 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 15:36:40 INFO  time: compiled root in 0.17s[0m
[0m2021.04.01 15:36:54 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 15:36:55 INFO  time: compiled root in 1.04s[0m
[0m2021.04.01 16:03:18 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:03:18 INFO  time: compiled root in 0.22s[0m
[0m2021.04.01 16:03:56 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:03:56 INFO  time: compiled root in 0.17s[0m
[0m2021.04.01 16:06:43 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:5: stale bloop error: type mismatch;
 found   : Option[play.api.mvc.Result]
 required: play.api.mvc.Result
> request.body.asJson.map { json =>
>       (json \ "name")
>         .asOpt[String]
>         .map { name =>
>           Ok("Hello " + name)
>         }
>         .getOrElse {
>           BadRequest("Expecting Json data")
>         }
>     }[0m
[0m2021.04.01 16:06:43 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:5: stale bloop error: type mismatch;
 found   : Option[play.api.mvc.Result]
 required: play.api.mvc.Result
> request.body.asJson.map { json =>
>       (json \ "name")
>         .asOpt[String]
>         .map { name =>
>           Ok("Hello " + name)
>         }
>         .getOrElse {
>           BadRequest("Expecting Json data")
>         }
>     }[0m
[0m2021.04.01 16:06:43 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:5: stale bloop error: type mismatch;
 found   : Option[play.api.mvc.Result]
 required: play.api.mvc.Result
> request.body.asJson.map { json =>
>       (json \ "name")
>         .asOpt[String]
>         .map { name =>
>           Ok("Hello " + name)
>         }
>         .getOrElse {
>           BadRequest("Expecting Json data")
>         }
>     }[0m
[0m2021.04.01 16:06:44 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:5: stale bloop error: type mismatch;
 found   : Option[play.api.mvc.Result]
 required: play.api.mvc.Result
> request.body.asJson.map { json =>
>       (json \ "name")
>         .asOpt[String]
>         .map { name =>
>           Ok("Hello " + name)
>         }
>         .getOrElse {
>           BadRequest("Expecting Json data")
>         }
>     }[0m
[0m2021.04.01 16:06:43 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:5: stale bloop error: type mismatch;
 found   : Option[play.api.mvc.Result]
 required: play.api.mvc.Result
> request.body.asJson.map { json =>
>       (json \ "name")
>         .asOpt[String]
>         .map { name =>
>           Ok("Hello " + name)
>         }
>         .getOrElse {
>           BadRequest("Expecting Json data")
>         }
>     }[0m
[0m2021.04.01 16:06:43 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:5: stale bloop error: type mismatch;
 found   : Option[play.api.mvc.Result]
 required: play.api.mvc.Result
> request.body.asJson.map { json =>
>       (json \ "name")
>         .asOpt[String]
>         .map { name =>
>           Ok("Hello " + name)
>         }
>         .getOrElse {
>           BadRequest("Expecting Json data")
>         }
>     }[0m
[0m2021.04.01 16:06:43 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:5: stale bloop error: type mismatch;
 found   : Option[play.api.mvc.Result]
 required: play.api.mvc.Result
> request.body.asJson.map { json =>
>       (json \ "name")
>         .asOpt[String]
>         .map { name =>
>           Ok("Hello " + name)
>         }
>         .getOrElse {
>           BadRequest("Expecting Json data")
>         }
>     }[0m
[0m2021.04.01 16:06:44 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:5: stale bloop error: type mismatch;
 found   : Option[play.api.mvc.Result]
 required: play.api.mvc.Result
> request.body.asJson.map { json =>
>       (json \ "name")
>         .asOpt[String]
>         .map { name =>
>           Ok("Hello " + name)
>         }
>         .getOrElse {
>           BadRequest("Expecting Json data")
>         }
>     }[0m
[0m2021.04.01 16:06:45 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:5: stale bloop error: type mismatch;
 found   : Option[play.api.mvc.Result]
 required: play.api.mvc.Result
> request.body.asJson.map { json =>
>       (json \ "name")
>         .asOpt[String]
>         .map { name =>
>           Ok("Hello " + name)
>         }
>         .getOrElse {
>           BadRequest("Expecting Json data")
>         }
>     }[0m
[0m2021.04.01 16:06:45 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:5: stale bloop error: type mismatch;
 found   : Option[play.api.mvc.Result]
 required: play.api.mvc.Result
> request.body.asJson.map { json =>
>       (json \ "name")
>         .asOpt[String]
>         .map { name =>
>           Ok("Hello " + name)
>         }
>         .getOrElse {
>           BadRequest("Expecting Json data")
>         }
>     }[0m
/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package scala

import scala.language.implicitConversions

import scala.collection.{ mutable, immutable, generic }
import immutable.StringOps
import mutable.ArrayOps
import generic.CanBuildFrom
import scala.annotation.{ elidable, implicitNotFound }
import scala.annotation.elidable.ASSERTION
import scala.io.StdIn

/** The `Predef` object provides definitions that are accessible in all Scala
 *  compilation units without explicit qualification.
 *
 *  === Commonly Used Types ===
 *  Predef provides type aliases for types which are commonly used, such as
 *  the immutable collection types [[scala.collection.immutable.Map]],
 *  [[scala.collection.immutable.Set]], and the [[scala.collection.immutable.List]]
 *  constructors ([[scala.collection.immutable.::]] and
 *  [[scala.collection.immutable.Nil]]).
 *
 *  === Console Output ===
 *  For basic console output, `Predef` provides convenience methods [[print(x:Any* print]] and [[println(x:Any* println]],
 *  which are aliases of the methods in the object [[scala.Console]].
 *
 *  === Assertions ===
 *  A set of `assert` functions are provided for use as a way to document
 *  and dynamically check invariants in code. Invocations of `assert` can be elided
 *  at compile time by providing the command line option `-Xdisable-assertions`,
 *  which raises `-Xelide-below` above `elidable.ASSERTION`, to the `scalac` command.
 *
 *  Variants of `assert` intended for use with static analysis tools are also
 *  provided: `assume`, `require` and `ensuring`. `require` and `ensuring` are
 *  intended for use as a means of design-by-contract style specification
 *  of pre- and post-conditions on functions, with the intention that these
 *  specifications could be consumed by a static analysis tool. For instance,
 *
 *  {{{
 *  def addNaturals(nats: List[Int]): Int = {
 *    require(nats forall (_ >= 0), "List contains negative numbers")
 *    nats.foldLeft(0)(_ + _)
 *  } ensuring(_ >= 0)
 *  }}}
 *
 *  The declaration of `addNaturals` states that the list of integers passed should
 *  only contain natural numbers (i.e. non-negative), and that the result returned
 *  will also be natural. `require` is distinct from `assert` in that if the
 *  condition fails, then the caller of the function is to blame rather than a
 *  logical error having been made within `addNaturals` itself. `ensuring` is a
 *  form of `assert` that declares the guarantee the function is providing with
 *  regards to its return value.
 *
 *  === Implicit Conversions ===
 *  A number of commonly applied implicit conversions are also defined here, and
 *  in the parent type [[scala.LowPriorityImplicits]]. Implicit conversions
 *  are provided for the "widening" of numeric values, for instance, converting a
 *  Short value to a Long value as required, and to add additional higher-order
 *  functions to Array values. These are described in more detail in the documentation of [[scala.Array]].
 *
 * @groupname utilities Utility Methods
 * @groupprio utilities 10
 *
 * @groupname assertions Assertions
 * @groupprio assertions 20
 * @groupdesc assertions These methods support program verification and runtime correctness.
 *
 * @groupname console-output Console Output
 * @groupprio console-output 30
 * @groupdesc console-output These methods provide output via the console.
 *
 * @groupname type-constraints Type Constraints
 * @groupprio type-constraints 40
 * @groupdesc type-constraints These entities allows constraints between types to be stipulated.
 *
 * @groupname aliases Aliases
 * @groupprio aliases 50
 * @groupdesc aliases These aliases bring selected immutable types into scope without any imports.
 *
 * @groupname conversions-string String Conversions
 * @groupprio conversions-string 60
 * @groupdesc conversions-string Conversions to and from String and StringOps.
 *
 * @groupname implicit-classes-any Implicit Classes
 * @groupprio implicit-classes-any 70
 * @groupdesc implicit-classes-any These implicit classes add useful extension methods to every type.
 *
 * @groupname implicit-classes-char CharSequence Conversions
 * @groupprio implicit-classes-char 80
 * @groupdesc implicit-classes-char These implicit classes add CharSequence methods to Array[Char] and IndexedSeq[Char] instances.
 *
 * @groupname conversions-java-to-anyval Java to Scala
 * @groupprio conversions-java-to-anyval 90
 * @groupdesc conversions-java-to-anyval Implicit conversion from Java primitive wrapper types to Scala equivalents.
 *
 * @groupname conversions-anyval-to-java Scala to Java
 * @groupprio conversions-anyval-to-java 100
 * @groupdesc conversions-anyval-to-java Implicit conversion from Scala AnyVals to Java primitive wrapper types equivalents.
 *
 * @groupname conversions-array-to-wrapped-array Array to WrappedArray
 * @groupprio conversions-array-to-wrapped-array 110
 * @groupdesc conversions-array-to-wrapped-array Conversions from Arrays to WrappedArrays.
 */
object Predef extends LowPriorityImplicits with DeprecatedPredef {
  /**
   * Retrieve the runtime representation of a class type. `classOf[T]` is equivalent to
   * the class literal `T.class` in Java.
   *
   * @example {{{
   * val listClass = classOf[List[_]]
   * // listClass is java.lang.Class[List[_]] = class scala.collection.immutable.List
   *
   * val mapIntString = classOf[Map[Int,String]]
   * // mapIntString is java.lang.Class[Map[Int,String]] = interface scala.collection.immutable.Map
   * }}}
   * @group utilities
   */
  def classOf[T]: Class[T] = null // This is a stub method. The actual implementation is filled in by the compiler.

  /** The `String` type in Scala has methods that come either from the underlying
   *  Java String (see the documentation corresponding to your Java version, for
   *  example [[http://docs.oracle.com/javase/8/docs/api/java/lang/String.html]]) or
   *  are added implicitly through [[scala.collection.immutable.StringOps]].
   *  @group aliases
   */
  type String        = java.lang.String
  /**  @group aliases */
  type Class[T]      = java.lang.Class[T]

  // miscellaneous -----------------------------------------------------
  scala.`package`                         // to force scala package object to be seen.
  scala.collection.immutable.List         // to force Nil, :: to be seen.

  /**  @group aliases */
  type Function[-A, +B] = Function1[A, B]

  /**  @group aliases */
  type Map[A, +B] = immutable.Map[A, B]
  /**  @group aliases */
  type Set[A]     = immutable.Set[A]
  /**  @group aliases */
  val Map         = immutable.Map
  /**  @group aliases */
  val Set         = immutable.Set

  // Manifest types, companions, and incantations for summoning
  @annotation.implicitNotFound(msg = "No ClassManifest available for ${T}.")
  @deprecated("use `scala.reflect.ClassTag` instead", "2.10.0")
  type ClassManifest[T] = scala.reflect.ClassManifest[T]
  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.", "2.10.0")
  type OptManifest[T]   = scala.reflect.OptManifest[T]
  @annotation.implicitNotFound(msg = "No Manifest available for ${T}.")
  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead", "2.10.0")
  type Manifest[T]      = scala.reflect.Manifest[T]
  @deprecated("use `scala.reflect.ClassTag` instead", "2.10.0")
  val ClassManifest     = scala.reflect.ClassManifest
  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead", "2.10.0")
  val Manifest          = scala.reflect.Manifest
  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.", "2.10.0")
  val NoManifest        = scala.reflect.NoManifest

  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("use scala.reflect.classTag[T] and scala.reflect.runtime.universe.typeTag[T] instead", "2.10.0")
  def manifest[T](implicit m: Manifest[T])           = m
  @deprecated("use scala.reflect.classTag[T] instead", "2.10.0")
  def classManifest[T](implicit m: ClassManifest[T]) = m
  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.", "2.10.0")
  def optManifest[T](implicit m: OptManifest[T])     = m

  // Minor variations on identity functions
  /** @group utilities */
  @inline def identity[A](x: A): A         = x    // @see `conforms` for the implicit version
  /** @group utilities */
  @inline def implicitly[T](implicit e: T) = e    // for summoning implicit values from the nether world -- TODO: when dependent method types are on by default, give this result type `e.type`, so that inliner has better chance of knowing which method to inline in calls like `implicitly[MatchingStrategy[Option]].zero`
  /** @group utilities */
  @inline def locally[T](x: T): T  = x    // to communicate intent and avoid unmoored statements

  // assertions ---------------------------------------------------------

  /** Tests an expression, throwing an `AssertionError` if false.
   *  Calls to this method will not be generated if `-Xelide-below`
   *  is greater than `ASSERTION`.
   *
   *  @see [[scala.annotation.elidable elidable]]
   *  @param assertion   the expression to test
   *  @group assertions
   */
  @elidable(ASSERTION)
  def assert(assertion: Boolean) {
    if (!assertion)
      throw new java.lang.AssertionError("assertion failed")
  }

  /** Tests an expression, throwing an `AssertionError` if false.
   *  Calls to this method will not be generated if `-Xelide-below`
   *  is greater than `ASSERTION`.
   *
   *  @see [[scala.annotation.elidable elidable]]
   *  @param assertion   the expression to test
   *  @param message     a String to include in the failure message
   *  @group assertions
   */
  @elidable(ASSERTION) @inline
  final def assert(assertion: Boolean, message: => Any) {
    if (!assertion)
      throw new java.lang.AssertionError("assertion failed: "+ message)
  }

  /** Tests an expression, throwing an `AssertionError` if false.
   *  This method differs from assert only in the intent expressed:
   *  assert contains a predicate which needs to be proven, while
   *  assume contains an axiom for a static checker.  Calls to this method
   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.
   *
   *  @see [[scala.annotation.elidable elidable]]
   *  @param assumption   the expression to test
   *  @group assertions
   */
  @elidable(ASSERTION)
  def assume(assumption: Boolean) {
    if (!assumption)
      throw new java.lang.AssertionError("assumption failed")
  }

  /** Tests an expression, throwing an `AssertionError` if false.
   *  This method differs from assert only in the intent expressed:
   *  assert contains a predicate which needs to be proven, while
   *  assume contains an axiom for a static checker.  Calls to this method
   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.
   *
   *  @see [[scala.annotation.elidable elidable]]
   *  @param assumption   the expression to test
   *  @param message      a String to include in the failure message
   *  @group assertions
   */
  @elidable(ASSERTION) @inline
  final def assume(assumption: Boolean, message: => Any) {
    if (!assumption)
      throw new java.lang.AssertionError("assumption failed: "+ message)
  }

  /** Tests an expression, throwing an `IllegalArgumentException` if false.
   *  This method is similar to `assert`, but blames the caller of the method
   *  for violating the condition.
   *
   *  @param requirement   the expression to test
   *  @group assertions
   */
  def require(requirement: Boolean) {
    if (!requirement)
      throw new IllegalArgumentException("requirement failed")
  }

  /** Tests an expression, throwing an `IllegalArgumentException` if false.
   *  This method is similar to `assert`, but blames the caller of the method
   *  for violating the condition.
   *
   *  @param requirement   the expression to test
   *  @param message       a String to include in the failure message
   *  @group assertions
   */
  @inline final def require(requirement: Boolean, message: => Any) {
    if (!requirement)
      throw new IllegalArgumentException("requirement failed: "+ message)
  }

  /** `???` can be used for marking methods that remain to be implemented.
   *  @throws NotImplementedError
   *  @group utilities
   */
  def ??? : Nothing = throw new NotImplementedError

  // tupling ------------------------------------------------------------

  @deprecated("use built-in tuple syntax or Tuple2 instead", "2.11.0")
  type Pair[+A, +B] = Tuple2[A, B]
  @deprecated("use built-in tuple syntax or Tuple2 instead", "2.11.0")
  object Pair {
    def apply[A, B](x: A, y: B) = Tuple2(x, y)
    def unapply[A, B](x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)
  }

  @deprecated("use built-in tuple syntax or Tuple3 instead", "2.11.0")
  type Triple[+A, +B, +C] = Tuple3[A, B, C]
  @deprecated("use built-in tuple syntax or Tuple3 instead", "2.11.0")
  object Triple {
    def apply[A, B, C](x: A, y: B, z: C) = Tuple3(x, y, z)
    def unapply[A, B, C](x: Tuple3[A, B, C]): Option[Tuple3[A, B, C]] = Some(x)
  }

  // implicit classes -----------------------------------------------------

  /** @group implicit-classes-any */
  implicit final class ArrowAssoc[A](private val self: A) extends AnyVal {
    @inline def -> [B](y: B): Tuple2[A, B] = Tuple2(self, y)
    def →[B](y: B): Tuple2[A, B] = ->(y)
  }

  /** @group implicit-classes-any */
  implicit final class Ensuring[A](private val self: A) extends AnyVal {
    def ensuring(cond: Boolean): A = { assert(cond); self }
    def ensuring(cond: Boolean, msg: => Any): A = { assert(cond, msg); self }
    def ensuring(cond: A => Boolean): A = { assert(cond(self)); self }
    def ensuring(cond: A => Boolean, msg: => Any): A = { assert(cond(self), msg); self }
  }

  /** @group implicit-classes-any */
  implicit final class StringFormat[A](private val self: A) extends AnyVal {
    /** Returns string formatted according to given `format` string.
     *  Format strings are as for `String.format`
     *  (@see java.lang.String.format).
     */
    @inline def formatted(fmtstr: String): String = fmtstr format self
  }

  // scala/bug#8229 retaining the pre 2.11 name for source compatibility in shadowing this implicit
  /** @group implicit-classes-any */
  implicit final class any2stringadd[A](private val self: A) extends AnyVal {
    def +(other: String): String = String.valueOf(self) + other
  }

  implicit final class RichException(private val self: Throwable) extends AnyVal {
    import scala.compat.Platform.EOL
    @deprecated("use Throwable#getStackTrace", "2.11.0") def getStackTraceString = self.getStackTrace().mkString("", EOL, EOL)
  }

  // Sadly we have to do `@deprecatedName(null, "2.12.0")` because
  // `@deprecatedName(since="2.12.0")` incurs a warning about
  //   Usage of named or default arguments transformed this annotation constructor call into a block.
  //   The corresponding AnnotationInfo will contain references to local values and default getters
  //   instead of the actual argument trees
  // and `@deprecatedName(Symbol("<none>"), "2.12.0")` crashes scalac with
  //   scala.reflect.internal.Symbols$CyclicReference: illegal cyclic reference involving object Symbol
  // in run/repl-no-imports-no-predef-power.scala.
  /** @group implicit-classes-char */
  implicit final class SeqCharSequence(@deprecated("will be made private", "2.12.0") @deprecatedName(null, "2.12.0") val __sequenceOfChars: scala.collection.IndexedSeq[Char]) extends CharSequence {
    def length: Int                                     = __sequenceOfChars.length
    def charAt(index: Int): Char                        = __sequenceOfChars(index)
    def subSequence(start: Int, end: Int): CharSequence = new SeqCharSequence(__sequenceOfChars.slice(start, end))
    override def toString                               = __sequenceOfChars mkString ""
  }

  /** @group implicit-classes-char */
  implicit final class ArrayCharSequence(@deprecated("will be made private", "2.12.0") @deprecatedName(null, "2.12.0") val __arrayOfChars: Array[Char]) extends CharSequence {
    def length: Int                                     = __arrayOfChars.length
    def charAt(index: Int): Char                        = __arrayOfChars(index)
    def subSequence(start: Int, end: Int): CharSequence = new runtime.ArrayCharSequence(__arrayOfChars, start, end)
    override def toString                               = __arrayOfChars mkString ""
  }

  implicit val StringCanBuildFrom: CanBuildFrom[String, Char, String] = new CanBuildFrom[String, Char, String] {
    def apply(from: String) = apply()
    def apply()             = mutable.StringBuilder.newBuilder
  }

  /** @group conversions-string */
  @inline implicit def augmentString(x: String): StringOps = new StringOps(x)
  /** @group conversions-string */
  @inline implicit def unaugmentString(x: StringOps): String = x.repr

  // printing -----------------------------------------------------------

  /** Prints an object to `out` using its `toString` method.
   *
   *  @param x the object to print; may be null.
   *  @group console-output
   */
  def print(x: Any) = Console.print(x)

  /** Prints a newline character on the default output.
   *  @group console-output
   */
  def println() = Console.println()

  /** Prints out an object to the default output, followed by a newline character.
   *
   *  @param x the object to print.
   *  @group console-output
   */
  def println(x: Any) = Console.println(x)

  /** Prints its arguments as a formatted string to the default output,
   *  based on a string pattern (in a fashion similar to printf in C).
   *
   *  The interpretation of the formatting patterns is described in
   *  [[java.util.Formatter]].
   *
   *  Consider using the [[scala.StringContext.f f interpolator]] as more type safe and idiomatic.
   *
   *  @param text the pattern for formatting the arguments.
   *  @param args the arguments used to instantiating the pattern.
   *  @throws java.lang.IllegalArgumentException if there was a problem with the format string or arguments
   *
   *  @see [[scala.StringContext.f StringContext.f]]
   *  @group console-output
   */
  def printf(text: String, xs: Any*) = Console.print(text.format(xs: _*))

  // views --------------------------------------------------------------

  implicit def tuple2ToZippedOps[T1, T2](x: (T1, T2))                           = new runtime.Tuple2Zipped.Ops(x)
  implicit def tuple3ToZippedOps[T1, T2, T3](x: (T1, T2, T3))                   = new runtime.Tuple3Zipped.Ops(x)

  implicit def genericArrayOps[T](xs: Array[T]): ArrayOps[T] = (xs match {
    case x: Array[AnyRef]  => refArrayOps[AnyRef](x)
    case x: Array[Boolean] => booleanArrayOps(x)
    case x: Array[Byte]    => byteArrayOps(x)
    case x: Array[Char]    => charArrayOps(x)
    case x: Array[Double]  => doubleArrayOps(x)
    case x: Array[Float]   => floatArrayOps(x)
    case x: Array[Int]     => intArrayOps(x)
    case x: Array[Long]    => longArrayOps(x)
    case x: Array[Short]   => shortArrayOps(x)
    case x: Array[Unit]    => unitArrayOps(x)
    case null              => null
  }).asInstanceOf[ArrayOps[T]]

  implicit def booleanArrayOps(xs: Array[Boolean]): ArrayOps.ofBoolean   = new ArrayOps.ofBoolean(xs)
  implicit def byteArrayOps(xs: Array[Byte]): ArrayOps.ofByte            = new ArrayOps.ofByte(xs)
  implicit def charArrayOps(xs: Array[Char]): ArrayOps.ofChar            = new ArrayOps.ofChar(xs)
  implicit def doubleArrayOps(xs: Array[Double]): ArrayOps.ofDouble      = new ArrayOps.ofDouble(xs)
  implicit def floatArrayOps(xs: Array[Float]): ArrayOps.ofFloat         = new ArrayOps.ofFloat(xs)
  implicit def intArrayOps(xs: Array[Int]): ArrayOps.ofInt               = new ArrayOps.ofInt(xs)
  implicit def longArrayOps(xs: Array[Long]): ArrayOps.ofLong            = new ArrayOps.ofLong(xs)
  implicit def refArrayOps[T <: AnyRef](xs: Array[T]): ArrayOps.ofRef[T] = new ArrayOps.ofRef[T](xs)
  implicit def shortArrayOps(xs: Array[Short]): ArrayOps.ofShort         = new ArrayOps.ofShort(xs)
  implicit def unitArrayOps(xs: Array[Unit]): ArrayOps.ofUnit            = new ArrayOps.ofUnit(xs)

  // "Autoboxing" and "Autounboxing" ---------------------------------------------------

  /** @group conversions-anyval-to-java */
  implicit def byte2Byte(x: Byte): java.lang.Byte             = x.asInstanceOf[java.lang.Byte]
  /** @group conversions-anyval-to-java */
  implicit def short2Short(x: Short): java.lang.Short         = x.asInstanceOf[java.lang.Short]
  /** @group conversions-anyval-to-java */
  implicit def char2Character(x: Char): java.lang.Character   = x.asInstanceOf[java.lang.Character]
  /** @group conversions-anyval-to-java */
  implicit def int2Integer(x: Int): java.lang.Integer         = x.asInstanceOf[java.lang.Integer]
  /** @group conversions-anyval-to-java */
  implicit def long2Long(x: Long): java.lang.Long             = x.asInstanceOf[java.lang.Long]
  /** @group conversions-anyval-to-java */
  implicit def float2Float(x: Float): java.lang.Float         = x.asInstanceOf[java.lang.Float]
  /** @group conversions-anyval-to-java */
  implicit def double2Double(x: Double): java.lang.Double     = x.asInstanceOf[java.lang.Double]
  /** @group conversions-anyval-to-java */
  implicit def boolean2Boolean(x: Boolean): java.lang.Boolean = x.asInstanceOf[java.lang.Boolean]

  /** @group conversions-java-to-anyval */
  implicit def Byte2byte(x: java.lang.Byte): Byte             = x.asInstanceOf[Byte]
  /** @group conversions-java-to-anyval */
  implicit def Short2short(x: java.lang.Short): Short         = x.asInstanceOf[Short]
  /** @group conversions-java-to-anyval */
  implicit def Character2char(x: java.lang.Character): Char   = x.asInstanceOf[Char]
  /** @group conversions-java-to-anyval */
  implicit def Integer2int(x: java.lang.Integer): Int         = x.asInstanceOf[Int]
  /** @group conversions-java-to-anyval */
  implicit def Long2long(x: java.lang.Long): Long             = x.asInstanceOf[Long]
  /** @group conversions-java-to-anyval */
  implicit def Float2float(x: java.lang.Float): Float         = x.asInstanceOf[Float]
  /** @group conversions-java-to-anyval */
  implicit def Double2double(x: java.lang.Double): Double     = x.asInstanceOf[Double]
  /** @group conversions-java-to-anyval */
  implicit def Boolean2boolean(x: java.lang.Boolean): Boolean = x.asInstanceOf[Boolean]

  // Type Constraints --------------------------------------------------------------

  /**
   * An instance of `A <:< B` witnesses that `A` is a subtype of `B`.
   * Requiring an implicit argument of the type `A <:< B` encodes
   * the generalized constraint `A <: B`.
   *
   * @note we need a new type constructor `<:<` and evidence `conforms`,
   * as reusing `Function1` and `identity` leads to ambiguities in
   * case of type errors (`any2stringadd` is inferred)
   *
   * To constrain any abstract type T that's in scope in a method's
   * argument list (not just the method's own type parameters) simply
   * add an implicit argument of type `T <:< U`, where `U` is the required
   * upper bound; or for lower-bounds, use: `L <:< T`, where `L` is the
   * required lower bound.
   *
   * In part contributed by Jason Zaugg.
   * @group type-constraints
   */
  @implicitNotFound(msg = "Cannot prove that ${From} <:< ${To}.")
  sealed abstract class <:<[-From, +To] extends (From => To) with Serializable
  private[this] final val singleton_<:< = new <:<[Any,Any] { def apply(x: Any): Any = x }
  // The dollar prefix is to dodge accidental shadowing of this method
  // by a user-defined method of the same name (scala/bug#7788).
  // The collections rely on this method.
  /** @group type-constraints */
  implicit def $conforms[A]: A <:< A = singleton_<:<.asInstanceOf[A <:< A]

  @deprecated("use `implicitly[T <:< U]` or `identity` instead.", "2.11.0")
  def conforms[A]: A <:< A = $conforms[A]

  /** An instance of `A =:= B` witnesses that the types `A` and `B` are equal.
   *
   * @see `<:<` for expressing subtyping constraints
   * @group type-constraints
   */
  @implicitNotFound(msg = "Cannot prove that ${From} =:= ${To}.")
  sealed abstract class =:=[From, To] extends (From => To) with Serializable
  private[this] final val singleton_=:= = new =:=[Any,Any] { def apply(x: Any): Any = x }
  /** @group type-constraints */
  object =:= {
     implicit def tpEquals[A]: A =:= A = singleton_=:=.asInstanceOf[A =:= A]
  }

  /** A type for which there is always an implicit value.
   *  @see [[scala.Array$]], method `fallbackCanBuildFrom`
   */
  class DummyImplicit

  object DummyImplicit {

    /** An implicit value yielding a `DummyImplicit`.
     *   @see [[scala.Array$]], method `fallbackCanBuildFrom`
     */
    implicit def dummyImplicit: DummyImplicit = new DummyImplicit
  }
}

private[scala] trait DeprecatedPredef {
  self: Predef.type =>

  // Deprecated stubs for any who may have been calling these methods directly.
  @deprecated("use `ArrowAssoc`", "2.11.0") def any2ArrowAssoc[A](x: A): ArrowAssoc[A]                                      = new ArrowAssoc(x)
  @deprecated("use `Ensuring`", "2.11.0") def any2Ensuring[A](x: A): Ensuring[A]                                            = new Ensuring(x)
  @deprecated("use `StringFormat`", "2.11.0") def any2stringfmt(x: Any): StringFormat[Any]                                  = new StringFormat(x)
  @deprecated("use `Throwable` directly", "2.11.0") def exceptionWrapper(exc: Throwable)                                    = new RichException(exc)
  @deprecated("use `SeqCharSequence`", "2.11.0") def seqToCharSequence(xs: scala.collection.IndexedSeq[Char]): CharSequence = new SeqCharSequence(xs)
  @deprecated("use `ArrayCharSequence`", "2.11.0") def arrayToCharSequence(xs: Array[Char]): CharSequence                   = new ArrayCharSequence(xs)

  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readLine(): String                 = StdIn.readLine()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readLine(text: String, args: Any*) = StdIn.readLine(text, args: _*)
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readBoolean()                      = StdIn.readBoolean()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readByte()                         = StdIn.readByte()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readShort()                        = StdIn.readShort()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readChar()                         = StdIn.readChar()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readInt()                          = StdIn.readInt()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readLong()                         = StdIn.readLong()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readFloat()                        = StdIn.readFloat()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readDouble()                       = StdIn.readDouble()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readf(format: String)              = StdIn.readf(format)
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readf1(format: String)             = StdIn.readf1(format)
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readf2(format: String)             = StdIn.readf2(format)
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readf3(format: String)             = StdIn.readf3(format)
}

/** The `LowPriorityImplicits` class provides implicit values that
*  are valid in all Scala compilation units without explicit qualification,
*  but that are partially overridden by higher-priority conversions in object
*  `Predef`.
*
*  @author  Martin Odersky
*  @since 2.8
*/
// scala/bug#7335 Parents of Predef are defined in the same compilation unit to avoid
// cyclic reference errors compiling the standard library *without* a previously
// compiled copy on the classpath.
private[scala] abstract class LowPriorityImplicits {
  import mutable.WrappedArray
  import immutable.WrappedString

  /** We prefer the java.lang.* boxed types to these wrappers in
   *  any potential conflicts.  Conflicts do exist because the wrappers
   *  need to implement ScalaNumber in order to have a symmetric equals
   *  method, but that implies implementing java.lang.Number as well.
   *
   *  Note - these are inlined because they are value classes, but
   *  the call to xxxWrapper is not eliminated even though it does nothing.
   *  Even inlined, every call site does a no-op retrieval of Predef's MODULE$
   *  because maybe loading Predef has side effects!
   */
  @inline implicit def byteWrapper(x: Byte)       = new runtime.RichByte(x)
  @inline implicit def shortWrapper(x: Short)     = new runtime.RichShort(x)
  @inline implicit def intWrapper(x: Int)         = new runtime.RichInt(x)
  @inline implicit def charWrapper(c: Char)       = new runtime.RichChar(c)
  @inline implicit def longWrapper(x: Long)       = new runtime.RichLong(x)
  @inline implicit def floatWrapper(x: Float)     = new runtime.RichFloat(x)
  @inline implicit def doubleWrapper(x: Double)   = new runtime.RichDouble(x)
  @inline implicit def booleanWrapper(x: Boolean) = new runtime.RichBoolean(x)

  /** @group conversions-array-to-wrapped-array */
  implicit def genericWrapArray[T](xs: Array[T]): WrappedArray[T] =
    if (xs eq null) null
    else WrappedArray.make(xs)

  // Since the JVM thinks arrays are covariant, one 0-length Array[AnyRef]
  // is as good as another for all T <: AnyRef.  Instead of creating 100,000,000
  // unique ones by way of this implicit, let's share one.
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapRefArray[T <: AnyRef](xs: Array[T]): WrappedArray[T] = {
    if (xs eq null) null
    else if (xs.length == 0) WrappedArray.empty[T]
    else new WrappedArray.ofRef[T](xs)
  }

  /** @group conversions-array-to-wrapped-array */
  implicit def wrapIntArray(xs: Array[Int]): WrappedArray[Int] = if (xs ne null) new WrappedArray.ofInt(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapDoubleArray(xs: Array[Double]): WrappedArray[Double] = if (xs ne null) new WrappedArray.ofDouble(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapLongArray(xs: Array[Long]): WrappedArray[Long] = if (xs ne null) new WrappedArray.ofLong(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapFloatArray(xs: Array[Float]): WrappedArray[Float] = if (xs ne null) new WrappedArray.ofFloat(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapCharArray(xs: Array[Char]): WrappedArray[Char] = if (xs ne null) new WrappedArray.ofChar(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapByteArray(xs: Array[Byte]): WrappedArray[Byte] = if (xs ne null) new WrappedArray.ofByte(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapShortArray(xs: Array[Short]): WrappedArray[Short] = if (xs ne null) new WrappedArray.ofShort(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapBooleanArray(xs: Array[Boolean]): WrappedArray[Boolean] = if (xs ne null) new WrappedArray.ofBoolean(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapUnitArray(xs: Array[Unit]): WrappedArray[Unit] = if (xs ne null) new WrappedArray.ofUnit(xs) else null

  /** @group conversions-string */
  implicit def wrapString(s: String): WrappedString = if (s ne null) new WrappedString(s) else null
  /** @group conversions-string */
  implicit def unwrapString(ws: WrappedString): String = if (ws ne null) ws.self else null

  implicit def fallbackStringCanBuildFrom[T]: CanBuildFrom[String, T, immutable.IndexedSeq[T]] =
    new CanBuildFrom[String, T, immutable.IndexedSeq[T]] {
      def apply(from: String) = immutable.IndexedSeq.newBuilder[T]
      def apply() = immutable.IndexedSeq.newBuilder[T]
    }
}

[0m2021.04.01 16:11:50 INFO  compiling root-test (1 scala source)[0m
[0m2021.04.01 16:11:50 INFO  time: compiled root-test in 0.29s[0m
[0m2021.04.01 16:13:23 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:13:23 INFO  time: compiled root in 0.89s[0m
[0m2021.04.01 16:14:46 INFO  compiling root-test (1 scala source)[0m
[0m2021.04.01 16:14:46 INFO  time: compiled root-test in 0.36s[0m
[0m2021.04.01 16:15:07 INFO  compiling root-test (1 scala source)[0m
[0m2021.04.01 16:15:07 INFO  time: compiled root-test in 0.25s[0m
[0m2021.04.01 16:15:07 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:15:09 INFO  time: compiled root in 1.04s[0m
[0m2021.04.01 16:16:06 ERROR scalafmt: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:22: error: is not a valid block statement
    val jsonBody: Json.parse(body.asJson)
    ^[0m
[0m2021.04.01 16:16:06 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:16:06 INFO  time: compiled root in 0.13s[0m
[0m2021.04.01 16:17:40 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:17:40 INFO  time: compiled root in 0.98s[0m
[0m2021.04.01 16:17:52 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:17:52 INFO  time: compiled root in 0.18s[0m
[0m2021.04.01 16:19:22 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:19:22 INFO  time: compiled root in 0.15s[0m
[0m2021.04.01 16:20:13 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:20:13 INFO  time: compiled root in 0.17s[0m
/*
 * Copyright (C) 2009-2019 Lightbend Inc. <https://www.lightbend.com>
 */

package play.api.libs.json

import java.io.InputStream

/**
 * @define jsonParam @param json the JsValue to convert
 * @define returnStringRepr A String with the json representation
 */
sealed trait JsonFacade {

  /**
   * Parses a String representing a JSON input, and returns it as a [[JsValue]].
   *
   * @param input the String to parse
   */
  def parse(input: String): JsValue

  /**
   * Parses a stream representing a JSON input, and returns it as a [[JsValue]].
   *
   * @param input the InputStream to parse
   */
  def parse(input: InputStream): JsValue

  /**
   * Parses some bytes representing a JSON input,
   * and returns it as a [[JsValue]].
   *
   * The character encoding used will be automatically detected as UTF-8,
   * UTF-16 or UTF-32, as per the heuristics in RFC-4627.
   *
   * @param input the byte array to parse
   */
  def parse(input: Array[Byte]): JsValue

  /**
   * Converts a [[JsValue]] to its string representation.
   *
   * {{{
   * import play.api.libs.json.Json
   *
   * val input = Json.obj(
   *   "field1" -> Json.obj(
   *     "field11" -> "value11",
   *     "field12" -> Json.arr("alpha", 123L)
   *   )
   * )
   *
   * Json.stringify(input)
   * // => {"field1":{"field11":"value11","field12":["alpha",123]}}
   * }}}
   *
   * $jsonParam
   * @return a String with the json representation
   */
  def stringify(json: JsValue): String

  /**
   * Converts a [[JsValue]] to bytes (using UTF-8 encoding).
   *
   * $jsonParam
   * @return an `Array[Byte]` representing the UTF-8-encoded JSON
   */
  def toBytes(json: JsValue): Array[Byte]

  /**
   * Converts a [[JsValue]] to its string representation,
   * escaping all non-ascii characters using `\u005CuXXXX` syntax.
   *
   * This is particularly useful when the output JSON will be executed as javascript, since JSON is not a strict
   * subset of javascript
   * (see <a href="http://timelessrepo.com/json-isnt-a-javascript-subset">JSON: The JavaScript subset that isn't</a>).
   *
   * {{{
   * import play.api.libs.json.{ Json, JsString }
   *
   * Json.asciiStringify(JsString("some\\u005Ctext\\u005C"))
   * // => "some\\u005Ctext\\u005C"
   *
   * Json.stringify(JsString("some\\u005Ctext\\u005C"))
   * // => "sometext"
   * }}}
   *
   * $jsonParam
   * $returnStringRepr with all non-ascii characters escaped.
   */
  def asciiStringify(json: JsValue): String

  /**
   * Converts a [[JsValue]] to its pretty string representation using default
   * pretty printer (line feeds after each fields and 2-spaces indentation).
   *
   * {{{
   * import play.api.libs.json.Json
   *
   * val res0 = Json.obj(
   *   "field1" -> Json.obj(
   *     "field11" -> "value11",
   *     "field12" -> Json.arr("alpha", 123L)
   *   )
   * )
   * // => {"field1":{"field11":"value11","field12":["alpha",123]}}
   *
   * Json.prettyPrint(res0)
   * // =>
   * // {
   * //   "field1" : {
   * //     "field11" : "value11",
   * //     "field12" : [ "alpha", 123 ]
   * //   }
   * // }
   * }}}
   *
   * $jsonParam
   * $returnStringRepr.
   */
  def prettyPrint(json: JsValue): String

  /**
   * Converts any writeable value to a [[JsValue]].
   *
   * A value is writeable if a [[Writes]] implicit is available for its type.
   *
   * @tparam T the type of the value to be written as JSON
   * @param o the value to convert as JSON
   */
  def toJson[T](o: T)(implicit tjs: Writes[T]): JsValue

  /**
   * Converts any object writeable value to a [[JsObject]].
   *
   * A value is writeable as an object,
   * if a [[OWrites]] implicit is available for its type.
   *
   * @tparam T the type of the value to be written as `JsObject`
   * @param o the value to convert as JSON object
   */
  def toJsObject[T](o: T)(implicit tjs: OWrites[T]): JsObject

  /**
   * Converts a [[JsValue]] to a value of requested type `T`.
   *
   * @tparam T The type of conversion result,
   * only supported if a [[Reads]] implicit is available for.
   *
   * $jsonParam
   */
  def fromJson[T](json: JsValue)(implicit fjs: Reads[T]): JsResult[T]

  /**
   * Returns a [[JsObject]] with given fields.
   *
   * @param fields the object fields specified as pairs of name and value
   */
  def obj(fields: (String, Json.JsValueWrapper)*): JsObject

  /** Returns a [[JsArray]] with given items. */
  def arr(items: Json.JsValueWrapper*): JsArray
}

/**
 * Helper functions to handle JsValues.
 *
 * @define macroOptions @tparam Opts the compile-time options
 * @define macroTypeParam @tparam A the type for which the handler must be materialized
 * @define macroWarning If any missing implicit is discovered, compiler will break with corresponding error.
 */
object Json extends JsonFacade {
  def parse(input: String): JsValue = StaticBinding.parseJsValue(input)

  def parse(input: InputStream): JsValue = StaticBinding.parseJsValue(input)

  def parse(input: Array[Byte]): JsValue = StaticBinding.parseJsValue(input)

  def stringify(json: JsValue): String =
    StaticBinding.generateFromJsValue(json, false)

  def toBytes(json: JsValue): Array[Byte] = StaticBinding.toBytes(json)

  //We use unicode \u005C for a backlash in comments, because Scala will replace unicode escapes during lexing
  //anywhere in the program.
  def asciiStringify(json: JsValue): String =
    StaticBinding.generateFromJsValue(json, true)

  def prettyPrint(json: JsValue): String = StaticBinding.prettyPrint(json)

  def toJson[T](o: T)(implicit tjs: Writes[T]): JsValue = tjs.writes(o)

  def toJsObject[T](o: T)(implicit tjs: OWrites[T]): JsObject = tjs.writes(o)

  def fromJson[T](json: JsValue)(implicit fjs: Reads[T]): JsResult[T] = fjs.reads(json)

  /**
   * Next is the trait that allows Simplified Json syntax :
   *
   * Example:
   *
   * {{{
   * import play.api.libs.json._
   *
   * JsObject(Seq(
   *    "key1" -> JsString("value"),
   *    "key2" -> JsNumber(123),
   *    "key3" -> JsObject(Seq("key31" -> JsString("value31")))
   * )) == Json.obj(
   *   "key1" -> "value", "key2" -> 123, "key3" -> Json.obj("key31" -> "value31"))
   *
   * JsArray(Seq(JsString("value"), JsNumber(123), JsBoolean(true))) == Json.arr("value", 123, true)
   * }}}
   *
   * There is an implicit conversion from any Type with a Json Writes to JsValueWrapper
   * which is an empty trait that shouldn't end into unexpected implicit conversions.
   */
  sealed trait JsValueWrapper

  private case class JsValueWrapperImpl(field: JsValue) extends JsValueWrapper

  import scala.language.implicitConversions

  implicit def toJsFieldJsValueWrapper[T](field: T)(implicit w: Writes[T]): JsValueWrapper =
    JsValueWrapperImpl(w.writes(field))

  def obj(fields: (String, JsValueWrapper)*): JsObject =
    JsObject(fields.map(f => (f._1, f._2.asInstanceOf[JsValueWrapperImpl].field)))

  def arr(items: JsValueWrapper*): JsArray =
    JsArray(items.iterator.map(_.asInstanceOf[JsValueWrapperImpl].field).toArray[JsValue])

  import language.experimental.macros

  /**
   * Creates a `Reads[A]` by resolving, at compile-time,
   * the case class fields or sealed family, and the required implicits.
   *
   * $macroWarning
   *
   * $macroTypeParam
   *
   * {{{
   * import play.api.libs.functional.syntax._
   * import play.api.libs.json.{ Json, JsonConfiguration, __ }
   *
   * case class User(userName: String, age: Int)
   *
   * implicit val userReads1 = Json.reads[User]
   * // macro-compiler replaces Json.reads[User] by injecting into compile chain
   * // the exact code you would write yourself. This is strictly equivalent to:
   * implicit val userReads2 = (
   *    (__ \ implicitly[JsonConfiguration].naming("userName")).read[String] and
   *    (__ \ implicitly[JsonConfiguration].naming("age")).read[Int]
   * )(User)
   * }}}
   */
  def reads[A]: Reads[A] = macro JsMacroImpl.implicitConfigReadsImpl[A]

  /**
   * Creates a `Reads[A]`, if `A` is a ValueClass,
   * by resolving at compile-time the `Reads` for the underlying type.
   *
   * $macroWarning
   *
   * $macroTypeParam
   *
   * {{{
   * import play.api.libs.json.{ Json, Reads }
   *
   * final class IdText(val value: String) extends AnyVal
   *
   * // Based on provided Reads[String] corresponding to `value: String`
   * val r: Reads[IdText] = Json.valueReads
   * }}}
   */
  def valueReads[A]: Reads[A] = macro JsMacroImpl.implicitConfigValueReads[A]

  /**
   * Creates a `OWrites[T]` by resolving, at compile-time,
   * the case class fields or sealed family, and the required implicits.
   *
   * $macroWarning
   *
   * $macroTypeParam
   *
   * {{{
   * import play.api.libs.functional.syntax._
   * import play.api.libs.json.{ Json, JsonConfiguration, __ }
   *
   * case class User(userName: String, age: Int)
   *
   * implicit val userWrites1 = Json.writes[User]
   * // macro-compiler replaces Json.writes[User] by injecting into compile chain
   * // the exact code you would write yourself. This is strictly equivalent to:
   * implicit val userWrites2 = (
   *    (__ \ implicitly[JsonConfiguration].naming("userName")).write[String] and
   *    (__ \ implicitly[JsonConfiguration].naming("age")).write[Int]
   * )(unlift(User.unapply))
   * }}}
   */
  def writes[A]: OWrites[A] = macro JsMacroImpl.implicitConfigWritesImpl[A]

  /**
   * Creates a `OWrites[T]`, if `T` is a ValueClass,
   * by resolving at compile-time the `Writes` for the underlying type.
   *
   * $macroWarning
   *
   * $macroTypeParam
   *
   * {{{
   * import play.api.libs.json.{ Json, Writes }
   *
   * final class TextId(val value: String) extends AnyVal
   *
   * // Based on provided Writes[String] corresponding to `value: String`
   * val w: Writes[TextId] = Json.valueWrites[TextId]
   * }}}
   */
  def valueWrites[A]: Writes[A] = macro JsMacroImpl.implicitConfigValueWrites[A]

  /**
   * Creates a `OFormat[T]` by resolving, at compile-time,
   * the case class fields or sealed family, and the required implicits.
   *
   * $macroWarning
   *
   * $macroTypeParam
   *
   * {{{
   * import play.api.libs.functional.syntax._
   * import play.api.libs.json.{ Json, JsonConfiguration, __ }
   *
   * case class User(userName: String, age: Int)
   *
   * val userFormat1 = Json.format[User]
   * // macro-compiler replaces Json.format[User] by injecting into compile chain
   * // the exact code you would write yourself. This is strictly equivalent to:
   * val userFormat2 = (
   *    (__ \ implicitly[JsonConfiguration].naming("userName")).format[String] and
   *    (__ \ implicitly[JsonConfiguration].naming("age")).format[Int]
   * )(User.apply, unlift(User.unapply))
   * }}}
   */
  def format[A]: OFormat[A] = macro JsMacroImpl.implicitConfigFormatImpl[A]

  /**
   * Creates a `OFormat[T]` by resolving, if `T` is a ValueClass
   * (see [[valueReads]] and [[valueWrites]]).
   *
   * $macroWarning
   *
   * $macroTypeParam
   *
   * {{{
   * import play.api.libs.json.{ Format, Json }
   *
   * final class User(val name: String) extends AnyVal
   *
   * implicit val userFormat: Format[User] = Json.valueFormat[User]
   * }}}
   */
  def valueFormat[A]: Format[A] = macro JsMacroImpl.implicitConfigValueFormat[A]

  /**
   * Creates a `Format[E]` by automatically creating Reads[E] and Writes[E] for any Enumeration E
   *
   * {{{
   * import play.api.libs.json.{ Format, Json }
   *
   * object DayOfWeek extends Enumeration {
   *
   *  type DayOfWeek = Value
   *
   *  val Mon = Value("Monday")
   *  val Tue = Value("Tuesday")
   *  val Wed = Value("Wednesday")
   *  // etc.
   *
   *   implicit val format1: Format[DayOfWeek] = Json.formatEnum(DayOfWeek)
   *   // or 'this' if defining directly in Enum
   *   implicit val format2: Format[DayOfWeek] = Json.formatEnum(this)
   * }
   * }}}
   *
   * `Json.toJson(Mon)` will produce `"Monday"`.
   *
   * @param enum Enumeration object
   * @tparam E type of Enum
   */
  def formatEnum[E <: Enumeration](enum: E): Format[E#Value] =
    Format(Reads.enumNameReads(enum), Writes.enumNameWrites[E])

  /**
   * JSON facade with some macro options.
   *
   * $macroOptions
   *
   * @define macroWarning If any missing implicit is discovered, compiler will break with corresponding error.
   * @define macroTypeParam @tparam A the type for which the handler must be materialized
   */
  final class WithOptions[Opts <: MacroOptions](val config: JsonConfiguration.Aux[Opts]) extends JsonFacade {
    def this() = this(JsonConfiguration.default)

    @inline def parse(input: String): JsValue       = Json.parse(input)
    @inline def parse(input: InputStream): JsValue  = Json.parse(input)
    @inline def parse(input: Array[Byte]): JsValue  = Json.parse(input)
    @inline def stringify(json: JsValue): String    = Json.stringify(json)
    @inline def toBytes(json: JsValue): Array[Byte] = Json.toBytes(json)

    @inline def asciiStringify(json: JsValue): String =
      Json.asciiStringify(json)

    @inline def prettyPrint(json: JsValue): String = Json.prettyPrint(json)
    @inline def toJson[T](o: T)(implicit tjs: Writes[T]): JsValue =
      Json.toJson[T](o)

    @inline def toJsObject[T](o: T)(implicit tjs: OWrites[T]): JsObject =
      Json.toJsObject[T](o)

    @inline def fromJson[T](json: JsValue)(implicit fjs: Reads[T]): JsResult[T] = Json.fromJson[T](json)

    @inline def obj(fields: (String, JsValueWrapper)*): JsObject = Json.obj(fields: _*)

    @inline def arr(items: JsValueWrapper*): JsArray = Json.arr(items: _*)

    /**
     * Creates a `Reads[T]` by resolving, at compile-time,
     * the case class fields or sealed family, and the required implicits.
     *
     * $macroWarning
     *
     * $macroTypeParam
     *
     * {{{
     * import play.api.libs.json.{ Json, Reads }
     *
     * case class User(userName: String, age: Int)
     *
     * implicit val userReads: Reads[User] =
     *   Json.using[Json.MacroOptions with Json.DefaultValues].reads[User]
     * }}}
     */
    def reads[A]: Reads[A] = macro JsMacroImpl.withOptionsReadsImpl[A]

    /**
     * Creates a `OWrites[T]` by resolving, at compile-time,
     * the case class fields or sealed family, and the required implicits.
     *
     * $macroWarning
     *
     * $macroTypeParam
     *
     * {{{
     * import play.api.libs.json.{ Json, OWrites }
     *
     * case class User(userName: String, age: Int)
     *
     * implicit val userWrites: OWrites[User] =
     *   Json.using[Json.MacroOptions].writes[User]
     * }}}
     */
    def writes[A]: OWrites[A] = macro JsMacroImpl.withOptionsWritesImpl[A]

    /**
     * Creates a `OFormat[T]` by resolving, at compile-time,
     * the case class fields or sealed family, and the required implicits.
     *
     * $macroWarning
     *
     * $macroTypeParam
     *
     * {{{
     * import play.api.libs.json.{ Json, OFormat }
     *
     * case class User(userName: String, age: Int)
     *
     * implicit val userFormat: OFormat[User] =
     *   Json.using[Json.WithDefaultValues].format[User]
     * }}}
     */
    def format[A]: OFormat[A] = macro JsMacroImpl.withOptionsFormatImpl[A]
  }

  /**
   * Returns a [[JsonFacade]] using the current JSON configuration.
   *
   * @tparam C the type of compile-time configuration
   *
   * {{{
   * import play.api.libs.json.{ Json, Reads }
   *
   * case class Foo(v: String)
   *
   * // Materializes a `Reads[Foo]`,
   * // with the configuration resolved at compile time
   * val r: Reads[Foo] = Json.configured.reads[Foo]
   * }}}
   */
  def configured[Opts <: MacroOptions](implicit config: JsonConfiguration.Aux[Opts]) = new WithOptions[Opts](config)

  /**
   * Returns an inference context to call the JSON macros,
   * using explicit compile-time options.
   *
   * $macroOptions
   */
  def using[Opts <: MacroOptions] = new WithOptions[Opts](JsonConfiguration[Opts]())

  /**
   * Compile-time base options for macro usage.
   *
   * {{{
   * import play.api.libs.json.Json
   *
   * case class Foo(v: String)
   *
   * Json.using[Json.MacroOptions].format[Foo]
   * // equivalent to Json.format[Foo]
   * }}}
   */
  sealed trait MacroOptions

  object MacroOptions {

    /**
     * Defines the default macro options if no type is supplied.
     *
     * Since you can't have defaults for a type parameter (unless it's a contravariant type, it will default to
     * Nothing), we supply the default via an implicit parameter.
     */
    trait Default[O <: Json.MacroOptions]

    trait LowPriorityDefaultImplicits {

      /**
       * Low priority implicit used when some explicit Json.MacroOptions instance is passed.
       */
      implicit def lowPriorityDefault[O <: Json.MacroOptions]: Default[O] = new Default[O] {}
    }

    object Default extends LowPriorityDefaultImplicits {

      /**
       * This will be the default that's passed when no MacroOptions is passed.
       */
      implicit object macroOptionsDefault extends Default[Json.MacroOptions]
    }
  }

  /**
   * Flag to indicate the macros can use the type default values
   * (e.g. default values for the case class parameters)
   * when applicable.
   *
   * {{{
   * import play.api.libs.json._, Json._
   *
   * type Opts = MacroOptions with DefaultValues
   * }}}
   */
  trait DefaultValues { _: MacroOptions =>
  }

  /**
   * Alias for `MacroOptions with DefaultValues`
   *
   * {{{
   * import play.api.libs.json.Json
   *
   * Json.using[Json.WithDefaultValues]
   * }}}
   */
  type WithDefaultValues = MacroOptions with DefaultValues
}

[0m2021.04.01 16:20:23 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:20:23 INFO  time: compiled root in 0.17s[0m
/*
 * Copyright (C) 2009-2019 Lightbend Inc. <https://www.lightbend.com>
 */

package play.api.libs.json

import scala.collection._

case class JsResultException(errors: collection.Seq[(JsPath, collection.Seq[JsonValidationError])])
    extends RuntimeException(s"JsResultException(errors:$errors)")

/**
 * Generic json value
 */
sealed trait JsValue extends JsReadable {
  def validate[A](implicit rds: Reads[A]): JsResult[A] =
    rds.reads(this)

  def validateOpt[A](implicit rds: Reads[A]): JsResult[Option[A]] =
    JsDefined(this).validateOpt[A]

  override def toString = Json.stringify(this)
}

object JsValue {
  import scala.language.implicitConversions
  implicit def jsValueToJsLookup(value: JsValue): JsLookup =
    JsLookup(JsDefined(value))
}

/**
 * Represents a Json null value.
 */
case object JsNull extends JsValue

/**
 * Represents a Json boolean value.
 */
sealed abstract class JsBoolean(val value: Boolean) extends JsValue with Product with Serializable {
  def canEqual(that: Any): Boolean = that.isInstanceOf[JsBoolean]

  @deprecated("No longer a case class", "2.6.0")
  val productArity = 1

  @deprecated("No longer a case class", "2.6.0")
  def productElement(n: Int): Any = (n: @annotation.switch) match {
    case 0 => value
  }

  @deprecated("No longer a case class", "2.6.0")
  def copy(value: Boolean = this.value): JsBoolean =
    if (value) JsTrue else JsFalse

  override def equals(that: Any): Boolean =
    canEqual(that) && (this.value == that.asInstanceOf[JsBoolean].value)

  override def hashCode: Int = value.hashCode
}

/**
 * Represents Json Boolean True value.
 */
case object JsTrue extends JsBoolean(true)

/**
 * Represents Json Boolean False value.
 */
case object JsFalse extends JsBoolean(false)

object JsBoolean extends (Boolean => JsBoolean) {
  def apply(value: Boolean): JsBoolean = if (value) JsTrue else JsFalse

  def unapply(b: JsBoolean): Option[Boolean] = Some(b.value)
}

/**
 * Represent a Json number value.
 */
case class JsNumber(value: BigDecimal) extends JsValue

/**
 * Represent a Json string value.
 */
case class JsString(value: String) extends JsValue

/**
 * Represent a Json array value.
 */
case class JsArray(value: IndexedSeq[JsValue] = Array[JsValue]()) extends JsValue {
  // keeping this method will also help bincompat with older play-json versions
  private[json] def this(value: collection.Seq[JsValue]) = this(value.toArray[JsValue])

  /**
   * Concatenates this array with the elements of an other array.
   */
  def ++(other: JsArray): JsArray =
    JsArray(value ++ other.value)

  /**
   * Append an element to this array.
   */
  def :+(el: JsValue): JsArray     = JsArray(value :+ el)
  def append(el: JsValue): JsArray = this.:+(el)

  /**
   * Prepend an element to this array.
   */
  def +:(el: JsValue): JsArray      = JsArray(el +: value)
  def prepend(el: JsValue): JsArray = this.+:(el)
}

object JsArray extends (IndexedSeq[JsValue] => JsArray) {
  def apply(value: collection.Seq[JsValue]) = new JsArray(value.toArray[JsValue])

  def empty = JsArray(Array.empty[JsValue])
}

/**
 * Represent a Json object value.
 */
case class JsObject(
    private[json] val underlying: Map[String, JsValue]
) extends JsValue {

  /**
   * The fields of this JsObject in the order passed to the constructor
   */
  lazy val fields: collection.Seq[(String, JsValue)] = underlying.toSeq

  /**
   * The value of this JsObject as an immutable map.
   */
  lazy val value: Map[String, JsValue] = underlying match {
    case m: immutable.Map[String, JsValue] => m
    case m                                 => m.toMap
  }

  /**
   * Return all fields as a set
   */
  def fieldSet: Set[(String, JsValue)] = fields.toSet

  /**
   * Return all keys
   */
  def keys: Set[String] = underlying.keySet

  /**
   * Return all values
   */
  def values: Iterable[JsValue] = underlying.values

  /**
   * Merge this object with another one. Values from other override value of the current object.
   */
  def ++(other: JsObject): JsObject = JsObject(JsObject.createFieldsMap(underlying) ++= other.underlying)

  /**
   * Removes one field from the JsObject
   */
  def -(otherField: String): JsObject = JsObject(JsObject.createFieldsMap(underlying) -= otherField)

  /**
   * Adds one field to the JsObject
   */
  def +(otherField: (String, JsValue)): JsObject =
    JsObject(JsObject.createFieldsMap(underlying) += otherField)

  /**
   * merges everything in depth and doesn't stop at first level, as ++ does
   */
  def deepMerge(other: JsObject): JsObject = {
    def merge(existingObject: JsObject, otherObject: JsObject): JsObject = {
      val result = existingObject.underlying ++ otherObject.underlying.map {
        case (otherKey, otherValue) =>
          val maybeExistingValue = existingObject.underlying.get(otherKey)

          val newValue = (maybeExistingValue, otherValue) match {
            case (Some(e: JsObject), o: JsObject) => merge(e, o)
            case _                                => otherValue
          }
          otherKey -> newValue
      }
      JsObject(result)
    }
    merge(this, other)
  }

  override def equals(other: Any): Boolean = other match {
    case that @ JsObject(_) => (that.canEqual(this)) && fieldSet == that.fieldSet
    case _                  => false
  }

  def canEqual(other: Any): Boolean = other.isInstanceOf[JsObject]

  override def hashCode: Int = fieldSet.hashCode()
}

object JsObject extends (Seq[(String, JsValue)] => JsObject) {

  /**
   * INTERNAL API: create a fields map by wrapping a Java LinkedHashMap.
   *
   * We use this because the Java implementation better handles hash code collisions for Comparable keys.
   */
  private[json] def createFieldsMap(fields: Iterable[(String, JsValue)] = Seq.empty): mutable.Map[String, JsValue] = {
    import scala.collection.JavaConverters._
    new java.util.LinkedHashMap[String, JsValue]().asScala ++= fields
  }

  /**
   * Construct a new JsObject, with the order of fields in the Seq.
   */
  def apply(fields: collection.Seq[(String, JsValue)]): JsObject = new JsObject(createFieldsMap(fields))

  def empty = JsObject(Seq.empty)
}

[0m2021.04.01 16:21:19 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:21:19 INFO  time: compiled root in 0.19s[0m
[0m2021.04.01 16:21:28 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:21:28 INFO  time: compiled root in 0.16s[0m
Apr 01, 2021 4:21:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2821
[0m2021.04.01 16:24:42 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:25: stale bloop error: overloaded method parse with alternatives:
  (input: Array[Byte])play.api.libs.json.JsValue <and>
  (input: java.io.InputStream)play.api.libs.json.JsValue <and>
  (input: String)play.api.libs.json.JsValue
 cannot be applied to (play.api.mvc.Request[play.api.mvc.AnyContent])
    val body: JsValue = Json.parse(request)
                        ^^^^^^^^^^[0m
[0m2021.04.01 16:24:42 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:22:37: stale bloop error: value asJson is not a member of play.api.libs.json.JsValue
    val jsonBody: Option[JsValue] = body.asJson
                                    ^^^^^^^^^^^[0m
[0m2021.04.01 16:24:42 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:25: stale bloop error: overloaded method parse with alternatives:
  (input: Array[Byte])play.api.libs.json.JsValue <and>
  (input: java.io.InputStream)play.api.libs.json.JsValue <and>
  (input: String)play.api.libs.json.JsValue
 cannot be applied to (play.api.mvc.Request[play.api.mvc.AnyContent])
    val body: JsValue = Json.parse(request)
                        ^^^^^^^^^^[0m
[0m2021.04.01 16:24:42 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:22:37: stale bloop error: value asJson is not a member of play.api.libs.json.JsValue
    val jsonBody: Option[JsValue] = body.asJson
                                    ^^^^^^^^^^^[0m
[0m2021.04.01 16:24:42 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:25: stale bloop error: overloaded method parse with alternatives:
  (input: Array[Byte])play.api.libs.json.JsValue <and>
  (input: java.io.InputStream)play.api.libs.json.JsValue <and>
  (input: String)play.api.libs.json.JsValue
 cannot be applied to (play.api.mvc.Request[play.api.mvc.AnyContent])
    val body: JsValue = Json.parse(request)
                        ^^^^^^^^^^[0m
[0m2021.04.01 16:24:42 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:22:37: stale bloop error: value asJson is not a member of play.api.libs.json.JsValue
    val jsonBody: Option[JsValue] = body.asJson
                                    ^^^^^^^^^^^[0m
[0m2021.04.01 16:24:42 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:25: stale bloop error: overloaded method parse with alternatives:
  (input: Array[Byte])play.api.libs.json.JsValue <and>
  (input: java.io.InputStream)play.api.libs.json.JsValue <and>
  (input: String)play.api.libs.json.JsValue
 cannot be applied to (play.api.mvc.Request[play.api.mvc.AnyContent])
    val body: JsValue = Json.parse(request)
                        ^^^^^^^^^^[0m
[0m2021.04.01 16:24:42 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:22:37: stale bloop error: value asJson is not a member of play.api.libs.json.JsValue
    val jsonBody: Option[JsValue] = body.asJson
                                    ^^^^^^^^^^^[0m
[0m2021.04.01 16:24:48 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:25: stale bloop error: overloaded method parse with alternatives:
  (input: Array[Byte])play.api.libs.json.JsValue <and>
  (input: java.io.InputStream)play.api.libs.json.JsValue <and>
  (input: String)play.api.libs.json.JsValue
 cannot be applied to (play.api.mvc.Request[play.api.mvc.AnyContent])
    val body: JsValue = Json.parse(request)
                        ^^^^^^^^^^[0m
[0m2021.04.01 16:24:48 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:22:37: stale bloop error: value asJson is not a member of play.api.libs.json.JsValue
    val jsonBody: Option[JsValue] = body.asJson
                                    ^^^^^^^^^^^[0m
[0m2021.04.01 16:24:48 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:20:25: stale bloop error: overloaded method parse with alternatives:
  (input: Array[Byte])play.api.libs.json.JsValue <and>
  (input: java.io.InputStream)play.api.libs.json.JsValue <and>
  (input: String)play.api.libs.json.JsValue
 cannot be applied to (play.api.mvc.Request[play.api.mvc.AnyContent])
    val body: JsValue = Json.parse(request)
                        ^^^^^^^^^^[0m
[0m2021.04.01 16:24:48 INFO  /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:22:37: stale bloop error: value asJson is not a member of play.api.libs.json.JsValue
    val jsonBody: Option[JsValue] = body.asJson
                                    ^^^^^^^^^^^[0m
[0m2021.04.01 16:27:30 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:27:30 INFO  time: compiled root in 0.96s[0m
[0m2021.04.01 16:41:15 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:41:15 INFO  time: compiled root in 0.34s[0m
[0m2021.04.01 16:41:40 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:41:40 INFO  time: compiled root in 0.17s[0m
[0m2021.04.01 16:42:03 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:42:04 INFO  time: compiled root in 1.12s[0m
[0m2021.04.01 16:42:32 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:42:32 INFO  time: compiled root in 0.2s[0m
[0m2021.04.01 16:43:04 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:43:04 INFO  time: compiled root in 0.85s[0m
[0m2021.04.01 16:43:29 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:43:29 INFO  time: compiled root in 0.14s[0m
[0m2021.04.01 16:44:54 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:44:54 INFO  time: compiled root in 0.15s[0m
[0m2021.04.01 16:45:12 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:45:12 INFO  time: compiled root in 0.13s[0m
/*
 * Copyright (C) Lightbend Inc. <https://www.lightbend.com>
 */

package play.api.mvc

import java.io._
import java.nio.charset.StandardCharsets._
import java.nio.charset._
import java.nio.file.Files
import java.util.Locale

import javax.inject.Inject
import akka.actor.ActorSystem
import akka.stream._
import akka.stream.scaladsl.Flow
import akka.stream.scaladsl.Sink
import akka.stream.scaladsl.StreamConverters
import akka.stream.stage._
import akka.util.ByteString
import play.api._
import play.api.data.DefaultFormBinding
import play.api.data.Form
import play.api.data.FormBinding
import play.api.http.Status._
import play.api.http._
import play.api.libs.Files.SingletonTemporaryFileCreator
import play.api.libs.Files.TemporaryFile
import play.api.libs.Files.TemporaryFileCreator
import play.api.libs.json._
import play.api.libs.streams.Accumulator
import play.api.mvc.MultipartFormData._
import play.core.Execution
import play.core.parsers.Multipart
import play.utils.PlayIO

import scala.concurrent.ExecutionContext
import scala.concurrent.Future
import scala.concurrent.Promise
import scala.util.Failure
import scala.util.Success
import scala.util.Try
import scala.util.control.Exception.catching
import scala.util.control.NonFatal
import scala.xml._

/**
 * A request body that adapts automatically according the request Content-Type.
 */
sealed trait AnyContent {

  /**
   * application/x-www-form-urlencoded
   */
  def asFormUrlEncoded: Option[Map[String, Seq[String]]] = this match {
    case AnyContentAsFormUrlEncoded(data) => Some(data)
    case _                                => None
  }

  /**
   * text/plain
   */
  def asText: Option[String] = this match {
    case AnyContentAsText(txt) => Some(txt)
    case _                     => None
  }

  /**
   * application/xml
   */
  def asXml: Option[NodeSeq] = this match {
    case AnyContentAsXml(xml) => Some(xml)
    case _                    => None
  }

  /**
   * text/json or application/json
   */
  def asJson: Option[JsValue] = this match {
    case AnyContentAsJson(json) => Some(json)
    case _                      => None
  }

  /**
   * multipart/form-data
   */
  def asMultipartFormData: Option[MultipartFormData[TemporaryFile]] = this match {
    case AnyContentAsMultipartFormData(mfd) => Some(mfd)
    case _                                  => None
  }

  /**
   * Used when no Content-Type matches
   */
  def asRaw: Option[RawBuffer] = this match {
    case AnyContentAsRaw(raw) => Some(raw)
    case _                    => None
  }
}

/**
 * Factory object for creating an AnyContent instance.  Useful for unit testing.
 */
object AnyContent {
  def apply(): AnyContent                                           = AnyContentAsEmpty
  def apply(contentText: String): AnyContent                        = AnyContentAsText(contentText)
  def apply(json: JsValue): AnyContent                              = AnyContentAsJson(json)
  def apply(xml: NodeSeq): AnyContent                               = AnyContentAsXml(xml)
  def apply(formUrlEncoded: Map[String, Seq[String]]): AnyContent   = AnyContentAsFormUrlEncoded(formUrlEncoded)
  def apply(formData: MultipartFormData[TemporaryFile]): AnyContent = AnyContentAsMultipartFormData(formData)
  def apply(raw: RawBuffer): AnyContent                             = AnyContentAsRaw(raw)
}

/**
 * AnyContent - Empty request body
 */
case object AnyContentAsEmpty extends AnyContent

/**
 * AnyContent - Text body
 */
case class AnyContentAsText(txt: String) extends AnyContent

/**
 * AnyContent - Form url encoded body
 */
case class AnyContentAsFormUrlEncoded(data: Map[String, Seq[String]]) extends AnyContent

/**
 * AnyContent - Raw body (give access to the raw data as bytes).
 */
case class AnyContentAsRaw(raw: RawBuffer) extends AnyContent

/**
 * AnyContent - XML body
 */
case class AnyContentAsXml(xml: NodeSeq) extends AnyContent

/**
 * AnyContent - Json body
 */
case class AnyContentAsJson(json: JsValue) extends AnyContent

/**
 * AnyContent - Multipart form data body
 */
case class AnyContentAsMultipartFormData(mfd: MultipartFormData[TemporaryFile]) extends AnyContent

/**
 * Multipart form data body.
 */
case class MultipartFormData[A](dataParts: Map[String, Seq[String]], files: Seq[FilePart[A]], badParts: Seq[BadPart]) {

  /**
   * Extract the data parts as Form url encoded.
   */
  def asFormUrlEncoded: Map[String, Seq[String]] = dataParts

  /**
   * Access a file part.
   */
  def file(key: String): Option[FilePart[A]] = files.find(_.key == key)
}

/**
 * Defines parts handled by Multipart form data.
 */
object MultipartFormData {

  /**
   * A part.
   *
   * @tparam A the type that file parts are exposed as.
   */
  sealed trait Part[+A]

  /**
   * A data part.
   */
  case class DataPart(key: String, value: String) extends Part[Nothing]

  /**
   * A file part.
   */
  case class FilePart[A](
      key: String,
      filename: String,
      contentType: Option[String],
      ref: A,
      fileSize: Long = -1,
      dispositionType: String = "form-data"
  ) extends Part[A]

  /**
   * A part that has not been properly parsed.
   */
  case class BadPart(headers: Map[String, String]) extends Part[Nothing]

  /**
   * Emitted when the multipart stream can't be parsed for some reason.
   */
  case class ParseError(message: String) extends Part[Nothing]

  /**
   * The multipart/form-data parser buffers many things in memory, including data parts, headers, file names etc.
   *
   * Some buffer limits apply to each element, eg, there is a buffer for headers before they are parsed.  Other buffer
   * limits apply to all in memory data in aggregate, this includes data parts, file names, part names.
   *
   * If any of these buffers are exceeded, this will be emitted.
   */
  case class MaxMemoryBufferExceeded(message: String) extends Part[Nothing]
}

/**
 * Handle the request body a raw bytes data.
 *
 * @param memoryThreshold If the content size is bigger than this limit, the content is stored as file.
 * @param temporaryFileCreator the temporary file creator to store the content as file.
 * @param initialData the initial data, ByteString.empty by default.
 */
case class RawBuffer(
    memoryThreshold: Long,
    temporaryFileCreator: TemporaryFileCreator,
    initialData: ByteString = ByteString.empty
) {
  import play.api.libs.Files._

  @volatile private var inMemory: ByteString                 = initialData
  @volatile private var backedByTemporaryFile: TemporaryFile = _
  @volatile private var outStream: OutputStream              = _

  private[play] def push(chunk: ByteString): Unit = {
    if (inMemory != null) {
      if (chunk.length + inMemory.size > memoryThreshold) {
        backToTemporaryFile()
        outStream.write(chunk.toArray)
      } else {
        inMemory = inMemory ++ chunk
      }
    } else {
      outStream.write(chunk.toArray)
    }
  }

  private[play] def close(): Unit = if (outStream != null) outStream.close()

  private[play] def backToTemporaryFile(): Unit = {
    backedByTemporaryFile = temporaryFileCreator.create("requestBody", "asRaw")
    outStream = Files.newOutputStream(backedByTemporaryFile)
    outStream.write(inMemory.toArray)
    inMemory = null
  }

  /**
   * Buffer size.
   */
  def size: Long = {
    if (inMemory != null) inMemory.size else Files.size(backedByTemporaryFile)
  }

  /**
   * Returns the buffer content as a bytes array.
   *
   * This operation will cause the internal collection of byte arrays to be copied into a new byte array on each
   * invocation, no caching is done.  If the buffer has been written out to a file, it will read the contents of the
   * file.
   *
   * @param maxLength The max length allowed to be stored in memory.  If this is smaller than memoryThreshold, and the
   *                  buffer is already in memory then None will still be returned.
   * @return None if the content is greater than maxLength, otherwise, the data as bytes.
   */
  def asBytes(maxLength: Long = memoryThreshold): Option[ByteString] = {
    if (size <= maxLength) {
      Some(if (inMemory != null) inMemory else ByteString(PlayIO.readFile(backedByTemporaryFile.path)))
    } else {
      None
    }
  }

  /**
   * Returns the buffer content as File.
   */
  def asFile: File = {
    if (inMemory != null) {
      backToTemporaryFile()
      close()
    }
    backedByTemporaryFile
  }

  override def toString = {
    val inMemorySize: Any = Option(this.inMemory).map(_.size).orNull
    s"RawBuffer(inMemory=$inMemorySize, backedByTemporaryFile=$backedByTemporaryFile)"
  }
}

/**
 * A set of reusable body parsers and utilities that do not require configuration.
 */
trait BodyParserUtils {

  /**
   * Don't parse the body content.
   */
  def empty: BodyParser[Unit] = ignore(())

  def ignore[A](body: A): BodyParser[A] = BodyParser("ignore") { request =>
    Accumulator.done(Right(body))
  }

  /**
   * A body parser that always returns an error.
   */
  def error[A](result: Future[Result]): BodyParser[A] =
    BodyParser("error")(_ => Accumulator.done(result.map(Left.apply)(Execution.trampoline)))

  /**
   * Allows to choose the right BodyParser parser to use by examining the request headers.
   */
  def using[A](f: RequestHeader => BodyParser[A]) = BodyParser(request => f(request)(request))

  /**
   * A body parser that flattens a future BodyParser.
   */
  def flatten[A](underlying: Future[BodyParser[A]])(implicit ec: ExecutionContext, mat: Materializer): BodyParser[A] =
    BodyParser(request => Accumulator.flatten(underlying.map(_(request))))

  /**
   * Creates a conditional BodyParser.
   */
  def when[A](
      predicate: RequestHeader => Boolean,
      parser: BodyParser[A],
      badResult: RequestHeader => Future[Result]
  ): BodyParser[A] = {
    BodyParser(s"conditional, wrapping=$parser") { request =>
      if (predicate(request)) {
        parser(request)
      } else {
        Accumulator.done(badResult(request).map(Left.apply)(Execution.trampoline))
      }
    }
  }

  /**
   * Wrap an existing BodyParser with a maxLength constraints.
   *
   * @param maxLength The max length allowed
   * @param parser The BodyParser to wrap
   */
  def maxLength[A](maxLength: Long, parser: BodyParser[A])(
      implicit mat: Materializer
  ): BodyParser[Either[MaxSizeExceeded, A]] =
    BodyParser(s"maxLength=$maxLength, wrapping=$parser") { request =>
      if (BodyParserUtils.contentLengthHeaderExceedsMaxLength(request, maxLength)) {
        Accumulator.done(Future.successful(Right(Left(MaxSizeExceeded(maxLength)))))
      } else {
        val takeUpToFlow = Flow.fromGraph(new BodyParsers.TakeUpTo(maxLength))

        // Apply the request
        val parserSink = parser.apply(request).toSink

        Accumulator(takeUpToFlow.toMat(parserSink) { (statusFuture, resultFuture) =>
          import Execution.Implicits.trampoline
          statusFuture.flatMap {
            case exceeded: MaxSizeExceeded => Future.successful(Right(Left(exceeded)))
            case _ =>
              resultFuture.map {
                case Left(result) => Left(result)
                case Right(a)     => Right(Right(a))
              }
          }
        })
      }
    }
}

object BodyParserUtils {

  /**
   * @param request The request whose Content-Length header will be checked (if it exists).
   * @param maxLength Maximum allowed bytes.
   * @return true if the request's Content-Length header value is greater than maxLength.
   *         false otherwise or if the request does not have a Content-Length header (or if it can't be parsed).
   */
  def contentLengthHeaderExceedsMaxLength(request: RequestHeader, maxLength: Long) =
    request.headers
      .get(HeaderNames.CONTENT_LENGTH)
      .flatMap(clh => catching(classOf[NumberFormatException]).opt(clh.toLong))
      .exists(_ > maxLength)
}

class DefaultPlayBodyParsers @Inject() (
    val config: ParserConfiguration,
    val errorHandler: HttpErrorHandler,
    val materializer: Materializer,
    val temporaryFileCreator: TemporaryFileCreator
) extends PlayBodyParsers

object PlayBodyParsers {

  /**
   * A helper method for creating PlayBodyParsers. The default values are mainly useful in testing, and default the
   * TemporaryFileCreator and HttpErrorHandler to singleton versions.
   */
  def apply(
      tfc: TemporaryFileCreator = SingletonTemporaryFileCreator,
      eh: HttpErrorHandler = new DefaultHttpErrorHandler(),
      conf: ParserConfiguration = ParserConfiguration()
  )(implicit mat: Materializer): PlayBodyParsers = {
    new DefaultPlayBodyParsers(conf, eh, mat, tfc)
  }
}

/**
 * Body parsers officially supported by Play (i.e. built-in to Play)
 */
trait PlayBodyParsers extends BodyParserUtils {
  private val logger = Logger(classOf[PlayBodyParsers])

  private[play] implicit def materializer: Materializer
  private[play] def config: ParserConfiguration
  private[play] def errorHandler: HttpErrorHandler
  private[play] def temporaryFileCreator: TemporaryFileCreator

  /**
   * Unlimited size.
   */
  val UNLIMITED: Long = Long.MaxValue

  private[play] val ApplicationXmlMatcher = """application/.*\+xml.*""".r

  /**
   * Default max length allowed for text based body.
   *
   * You can configure it in application.conf:
   *
   * {{{
   * play.http.parser.maxMemoryBuffer = 100k
   * }}}
   */
  def DefaultMaxTextLength: Long = config.maxMemoryBuffer

  /**
   * Default max length allowed for disk based body.
   *
   * You can configure it in application.conf:
   *
   * {{{
   * play.http.parser.maxDiskBuffer = 512k
   * }}}
   */
  def DefaultMaxDiskLength: Long = config.maxDiskBuffer

  /**
   * If empty file uploads are allowed (no matter if filename or file is empty)
   */
  def DefaultAllowEmptyFileUploads: Boolean = false

  // -- General purpose

  def formBinding(maxChars: Long = DefaultMaxTextLength): FormBinding = new DefaultFormBinding(maxChars)

  // -- Text parser

  /**
   * Parses the body as text without checking the Content-Type.
   *
   * Will attempt to parse content with an explicit charset, but will fallback to UTF-8, ISO-8859-1, and finally US-ASCII if incorrect characters are detected.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def tolerantText(maxLength: Long): BodyParser[String] =
    tolerantBodyParser("text", maxLength, "Error decoding text body") { (request, bytes) =>
      val byteBuffer = bytes.toByteBuffer

      def decode(encodingToTry: Charset): Try[String] = {
        import java.nio.charset.CodingErrorAction
        val decoder = encodingToTry.newDecoder.onMalformedInput(CodingErrorAction.REPORT)
        try {
          // Make sure we are at the beginning of the buffer - previous decoding attempts may have
          // managed to advance through a part of the buffer before failing.
          byteBuffer.rewind()
          Success(decoder.decode(byteBuffer).toString)
        } catch {
          case e: CharacterCodingException =>
            logger.warn(
              s"TolerantText body parser tried to parse request ${request.id} as text body with charset $encodingToTry, but it contains invalid characters!"
            )
            Failure(e)
          case e: Exception =>
            logger.error("Unexpected exception while decoding text/plain body", e)
            Failure(e)
        }
      }

      // Run through a common set of encoders to get an idea of the best character encoding.

      // Per RFC-7321, "The default charset of ISO-8859-1 for text media types has been removed; the default is now
      // whatever the media type definition says." and
      // The default "charset" parameter value for "text/plain" is unchanged from [RFC2046] and remains as "US-ASCII".
      // https://tools.ietf.org/html/rfc6657#section-4
      val charset = request.charset.fold(US_ASCII)(Charset.forName)
      decode(charset)
        .recoverWith {
          case _: CharacterCodingException => decode(UTF_8)
        }
        .recoverWith {
          case _: CharacterCodingException => decode(ISO_8859_1)
        }
        .getOrElse {
          // We can't get a decent charset.  If we added https://github.com/albfernandez/juniversalchardet
          // then we could guess at the encoding, but that's best done in userspace rather than adding
          // it into the core...
          bytes.decodeString(charset)
        }
    }

  /**
   * Parse the body as text without checking the Content-Type.
   */
  def tolerantText: BodyParser[String] = tolerantText(DefaultMaxTextLength)

  /**
   * Parse the body as text if the Content-Type is text/plain.
   *
   * If the charset is not explicitly declared, then the default "charset" parameter value is US-ASCII,
   * per https://tools.ietf.org/html/rfc6657#section-4.  Use tolerantText if more flexible character
   * decoding is desired.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def text(maxLength: Long): BodyParser[String] = {
    BodyParser("text") { request =>
      if (request.contentType.exists(_.equalsIgnoreCase("text/plain"))) {
        val bodyParser = tolerantBodyParser("text", maxLength, "Error decoding text body") { (request, bytes) =>
          val charset = request.charset.fold(US_ASCII)(Charset.forName)
          import java.nio.charset.CodingErrorAction
          val decoder = charset.newDecoder.onMalformedInput(CodingErrorAction.REPORT)
          try {
            // Render with assumption that all characters are valid
            decoder.decode(bytes.toByteBuffer).toString
          } catch {
            case e: CharacterCodingException =>
              // Log a warning, and render to the given charset with unmappable characters.
              // This is slower (exception + 2 * rendering) but the happy path is just as fast.
              logger.warn(
                s"Text body parser tried to parse request ${request.id} as text body with charset $charset, but it contains invalid characters!"
              )
              bytes.decodeString(charset)
          }
        }
        bodyParser(request)
      } else {
        Accumulator.done {
          val badResult = createBadResult("Expecting text/plain body", UNSUPPORTED_MEDIA_TYPE)
          badResult(request).map(Left.apply)(Execution.trampoline)
        }
      }
    }
  }

  /**
   * Parse the body as text if the Content-Type is text/plain.
   */
  def text: BodyParser[String] = text(DefaultMaxTextLength)

  /**
   * Buffer the body as a simple [[akka.util.ByteString]].
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def byteString(maxLength: Long): BodyParser[ByteString] = {
    tolerantBodyParser("byteString", maxLength, "Error decoding byte string body")((_, bytes) => bytes)
  }

  /**
   * Buffer the body as a simple [[akka.util.ByteString]].
   *
   * Will buffer up to the configured max memory buffer amount, after which point, it will return an EntityTooLarge
   * HTTP response.
   */
  def byteString: BodyParser[ByteString] = byteString(config.maxMemoryBuffer)

  // -- Raw parser

  /**
   * Store the body content in a RawBuffer.
   *
   * @param memoryThreshold If the content size is bigger than this limit, the content is stored as file.
   *
   * @see [[DefaultMaxDiskLength]]
   * @see [[Results.EntityTooLarge]]
   */
  def raw(memoryThreshold: Long = DefaultMaxTextLength, maxLength: Long = DefaultMaxDiskLength): BodyParser[RawBuffer] =
    BodyParser("raw, memoryThreshold=" + memoryThreshold) { request =>
      import Execution.Implicits.trampoline
      enforceMaxLength(
        request,
        maxLength,
        Accumulator
          .strict[ByteString, RawBuffer](
            { maybeStrictBytes =>
              Future.successful(
                RawBuffer(memoryThreshold, temporaryFileCreator, maybeStrictBytes.getOrElse(ByteString.empty))
              )
            }, {
              val buffer = RawBuffer(memoryThreshold, temporaryFileCreator)
              val sink = Sink.fold[RawBuffer, ByteString](buffer) { (bf, bs) =>
                bf.push(bs); bf
              }
              sink.mapMaterializedValue { future =>
                future.andThen { case _ => buffer.close() }
              }
            }
          )
          .map(buffer => Right(buffer))
      )
    }

  /**
   * Store the body content in a RawBuffer.
   */
  def raw: BodyParser[RawBuffer] = raw()

  // -- JSON parser

  /**
   * Parse the body as Json without checking the Content-Type.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def tolerantJson(maxLength: Long): BodyParser[JsValue] =
    tolerantBodyParser[JsValue]("json", maxLength, "Invalid Json") { (request, bytes) =>
      // Encoding notes: RFC 4627 requires that JSON be encoded in Unicode, and states that whether that's
      // UTF-8, UTF-16 or UTF-32 can be auto detected by reading the first two bytes. So we ignore the declared
      // charset and don't decode, we passing the byte array as is because Jackson supports auto detection.
      Json.parse(bytes.iterator.asInputStream)
    }

  /**
   * Parse the body as Json without checking the Content-Type.
   */
  def tolerantJson: BodyParser[JsValue] = tolerantJson(DefaultMaxTextLength)

  /**
   * Parse the body as Json without checking the Content-Type,
   * validating the result with the Json reader.
   *
   * @tparam A the type to read and validate from the body.
   * @param reader a Json reader for type A.
   */
  def tolerantJson[A](implicit reader: Reads[A]): BodyParser[A] = jsonReads(tolerantJson)

  /**
   * Parse the body as Json if the Content-Type is text/json or application/json.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def json(maxLength: Long): BodyParser[JsValue] = when(
    _.contentType.exists(m => m.equalsIgnoreCase("text/json") || m.equalsIgnoreCase("application/json")),
    tolerantJson(maxLength),
    createBadResult("Expecting text/json or application/json body", UNSUPPORTED_MEDIA_TYPE)
  )

  /**
   * Parse the body as Json if the Content-Type is text/json or application/json.
   */
  def json: BodyParser[JsValue] = json(DefaultMaxTextLength)

  /**
   * Parse the body as Json if the Content-Type is text/json or application/json,
   * validating the result with the Json reader.
   *
   * @tparam A the type to read and validate from the body.
   * @param reader a Json reader for type A.
   */
  def json[A](implicit reader: Reads[A]): BodyParser[A] = jsonReads(json)

  /**
   * Parse the body as Json given a BodyParser,
   * validating the result with the Json reader.
   */
  private def jsonReads[A](parser: BodyParser[JsValue])(implicit reader: Reads[A]): BodyParser[A] =
    BodyParser("json reader") { request =>
      import Execution.Implicits.trampoline
      parser(request).mapFuture {
        case Left(simpleResult) =>
          Future.successful(Left(simpleResult))
        case Right(jsValue) =>
          jsValue
            .validate(reader)
            .map { a =>
              Future.successful(Right(a))
            }
            .recoverTotal { jsError =>
              val msg = s"Json validation error ${JsError.toFlatForm(jsError)}"
              createBadResult(msg)(request).map(Left.apply)
            }
      }
    }

  // -- Form parser

  /**
   * Parse the body and binds it to a given form model.
   *
   * {{{
   *   case class User(name: String)
   *
   *   val userForm: Form[User] = Form(mapping("name" -> nonEmptyText)(User.apply)(User.unapply))
   *
   *   Action(parse.form(userForm)) { request =>
   *     Ok(s"Hello, \${request.body.name}!")
   *   }
   * }}}
   *
   * @param form Form model
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response. If `None`, the default `play.http.parser.maxMemoryBuffer` configuration value is used.
   * @param onErrors The result to reply in case of errors during the form binding process
   */
  def form[A](
      form: Form[A],
      maxLength: Option[Long] = None,
      onErrors: Form[A] => Result = (_: Form[A]) => Results.BadRequest
  ): BodyParser[A] =
    BodyParser { requestHeader =>
      val parser  = anyContent(maxLength)
      val binding = formBinding(maxLength.getOrElse(DefaultMaxTextLength))
      parser(requestHeader).map { resultOrBody =>
        resultOrBody.right.flatMap { body =>
          form
            .bindFromRequest()(Request[AnyContent](requestHeader, body), binding)
            .fold(formErrors => Left(onErrors(formErrors)), a => Right(a))
        }
      }(Execution.trampoline)
    }

  // -- XML parser

  /**
   * Parse the body as Xml without checking the Content-Type.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def tolerantXml(maxLength: Long): BodyParser[NodeSeq] =
    tolerantBodyParser[NodeSeq]("xml", maxLength, "Invalid XML") { (request, bytes) =>
      val inputSource = new InputSource(bytes.iterator.asInputStream)

      // Encoding notes: RFC 3023 is the RFC for XML content types.  Comments below reflect what it says.

      // An externally declared charset takes precedence
      request.charset
        .orElse(
          // If omitted, maybe select a default charset, based on the media type.
          request.mediaType.collect {
            // According to RFC 3023, the default encoding for text/xml is us-ascii. This contradicts RFC 2616, which
            // states that the default for text/* is ISO-8859-1.  An RFC 3023 conforming client will send US-ASCII,
            // in that case it is safe for us to use US-ASCII or ISO-8859-1.  But a client that knows nothing about
            // XML, and therefore nothing about RFC 3023, but rather conforms to RFC 2616, will send ISO-8859-1.
            // Since decoding as ISO-8859-1 works for both clients that conform to RFC 3023, and clients that conform
            // to RFC 2616, we use that.
            case mt if mt.mediaType == "text" => "iso-8859-1"
            // Otherwise, there should be no default, it will be detected by the XML parser.
          }
        )
        .foreach { charset =>
          inputSource.setEncoding(charset)
        }
      Play.XML.load(inputSource)
    }

  /**
   * Parse the body as Xml without checking the Content-Type.
   */
  def tolerantXml: BodyParser[NodeSeq] = tolerantXml(DefaultMaxTextLength)

  /**
   * Parse the body as Xml if the Content-Type is application/xml, text/xml or application/XXX+xml.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def xml(maxLength: Long): BodyParser[NodeSeq] = when(
    _.contentType.exists { t =>
      val tl = t.toLowerCase(Locale.ENGLISH)
      tl.startsWith("text/xml") || tl
        .startsWith("application/xml") || ApplicationXmlMatcher.pattern.matcher(tl).matches()
    },
    tolerantXml(maxLength),
    createBadResult("Expecting xml body", UNSUPPORTED_MEDIA_TYPE)
  )

  /**
   * Parse the body as Xml if the Content-Type is application/xml, text/xml or application/XXX+xml.
   */
  def xml: BodyParser[NodeSeq] = xml(DefaultMaxTextLength)

  // -- File parsers

  /**
   * Store the body content into a file.
   *
   * @param to The file used to store the content.
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def file(to: File, maxLength: Long): BodyParser[File] = BodyParser(s"file, to=$to") { request =>
    import Execution.Implicits.trampoline
    val bodyAccumulator =
      Accumulator(StreamConverters.fromOutputStream(() => Files.newOutputStream(to.toPath))).map(_ => Right(to))
    enforceMaxLength(request, maxLength, bodyAccumulator)
  }

  /**
   * Store the body content into a file.
   *
   * @param to The file used to store the content.
   */
  def file(to: File): BodyParser[File] = file(to, DefaultMaxDiskLength)

  private def requestEntityTooLarge(request: RequestHeader) =
    createBadResult("Request Entity Too Large", REQUEST_ENTITY_TOO_LARGE)(request).map(Left(_))(Execution.trampoline)

  /**
   * Store the body content into a temporary file.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def temporaryFile(maxLength: Long): BodyParser[TemporaryFile] = BodyParser("temporaryFile") { request =>
    if (BodyParserUtils.contentLengthHeaderExceedsMaxLength(request, maxLength)) {
      // We check early here already to not even create a temporary file
      Accumulator.done(requestEntityTooLarge(request))
    } else {
      val tempFile = temporaryFileCreator.create("requestBody", "asTemporaryFile")
      file(tempFile, maxLength)(request).map(_.fold(result => Left(result), _ => Right(tempFile)))(Execution.trampoline)
    }
  }

  /**
   * Store the body content into a temporary file.
   */
  def temporaryFile: BodyParser[TemporaryFile] = temporaryFile(DefaultMaxDiskLength)

  // -- FormUrlEncoded

  /**
   * Parse the body as Form url encoded without checking the Content-Type.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def tolerantFormUrlEncoded(maxLength: Long): BodyParser[Map[String, Seq[String]]] =
    tolerantBodyParser("formUrlEncoded", maxLength, "Error parsing application/x-www-form-urlencoded") {
      (request, bytes) =>
        import play.core.parsers._
        val charset          = request.charset.getOrElse("UTF-8")
        val urlEncodedString = bytes.decodeString("UTF-8")
        FormUrlEncodedParser.parse(urlEncodedString, charset)
    }

  /**
   * Parse the body as form url encoded without checking the Content-Type.
   */
  def tolerantFormUrlEncoded: BodyParser[Map[String, Seq[String]]] =
    tolerantFormUrlEncoded(DefaultMaxTextLength)

  /**
   * Parse the body as form url encoded if the Content-Type is application/x-www-form-urlencoded.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def formUrlEncoded(maxLength: Long): BodyParser[Map[String, Seq[String]]] = when(
    _.contentType.exists(_.equalsIgnoreCase("application/x-www-form-urlencoded")),
    tolerantFormUrlEncoded(maxLength),
    createBadResult("Expecting application/x-www-form-urlencoded body", UNSUPPORTED_MEDIA_TYPE)
  )

  /**
   * Parse the body as form url encoded if the Content-Type is application/x-www-form-urlencoded.
   */
  def formUrlEncoded: BodyParser[Map[String, Seq[String]]] =
    formUrlEncoded(DefaultMaxTextLength)

  // -- Magic any content

  /**
   * If the request has a body, parse the body content by checking the Content-Type header.
   */
  def default: BodyParser[AnyContent] = default(None)

  // this is an alias method since "default" is a Java reserved word
  def defaultBodyParser: BodyParser[AnyContent] = default

  /**
   * If the request has a body, parse the body content by checking the Content-Type header.
   */
  def default(maxLength: Option[Long]): BodyParser[AnyContent] = using { request =>
    if (request.hasBody) {
      anyContent(maxLength)
    } else {
      ignore(AnyContentAsEmpty)
    }
  }

  /**
   * Guess the body content by checking the Content-Type header.
   */
  def anyContent: BodyParser[AnyContent] = anyContent(None)

  /**
   * Guess the body content by checking the Content-Type header.
   */
  def anyContent(maxLength: Option[Long]): BodyParser[AnyContent] = BodyParser("anyContent") { request =>
    import Execution.Implicits.trampoline

    def maxLengthOrDefault          = maxLength.fold(DefaultMaxTextLength)(_.toInt)
    def maxLengthOrDefaultLarge     = maxLength.getOrElse(DefaultMaxDiskLength)
    val contentType: Option[String] = request.contentType.map(_.toLowerCase(Locale.ENGLISH))
    contentType match {
      case Some("text/plain") =>
        logger.trace("Parsing AnyContent as text")
        text(maxLengthOrDefault)(request).map(_.right.map(s => AnyContentAsText(s)))

      case Some("text/xml") | Some("application/xml") | Some(ApplicationXmlMatcher()) =>
        logger.trace("Parsing AnyContent as xml")
        xml(maxLengthOrDefault)(request).map(_.right.map(x => AnyContentAsXml(x)))

      case Some("text/json") | Some("application/json") =>
        logger.trace("Parsing AnyContent as json")
        json(maxLengthOrDefault)(request).map(_.right.map(j => AnyContentAsJson(j)))

      case Some("application/x-www-form-urlencoded") =>
        logger.trace("Parsing AnyContent as urlFormEncoded")
        formUrlEncoded(maxLengthOrDefault)(request).map(_.right.map(d => AnyContentAsFormUrlEncoded(d)))

      case Some("multipart/form-data") =>
        logger.trace("Parsing AnyContent as multipartFormData")
        multipartFormData(
          Multipart.handleFilePartAsTemporaryFile(temporaryFileCreator),
          maxLengthOrDefaultLarge,
          DefaultAllowEmptyFileUploads
        ).apply(request)
          .map(_.right.map(m => AnyContentAsMultipartFormData(m)))

      case _ =>
        logger.trace("Parsing AnyContent as raw")
        raw(DefaultMaxTextLength, maxLengthOrDefaultLarge)(request).map(_.right.map(r => AnyContentAsRaw(r)))
    }
  }

  // -- Multipart

  /**
   * Parse the content as multipart/form-data
   */
  def multipartFormData: BodyParser[MultipartFormData[TemporaryFile]] =
    multipartFormData(Multipart.handleFilePartAsTemporaryFile(temporaryFileCreator))

  /**
   * Parse the content as multipart/form-data
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def multipartFormData(maxLength: Long): BodyParser[MultipartFormData[TemporaryFile]] =
    multipartFormData(Multipart.handleFilePartAsTemporaryFile(temporaryFileCreator), maxLength)

  /**
   * Parse the content as multipart/form-data
   *
   * @param allowEmptyFiles If empty file uploads are allowed (no matter if filename or file is empty)
   */
  def multipartFormData(allowEmptyFiles: Boolean): BodyParser[MultipartFormData[TemporaryFile]] =
    multipartFormData(Multipart.handleFilePartAsTemporaryFile(temporaryFileCreator), allowEmptyFiles = allowEmptyFiles)

  /**
   * Parse the content as multipart/form-data
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   * @param allowEmptyFiles If empty file uploads are allowed (no matter if filename or file is empty)
   */
  def multipartFormData(maxLength: Long, allowEmptyFiles: Boolean): BodyParser[MultipartFormData[TemporaryFile]] =
    multipartFormData(Multipart.handleFilePartAsTemporaryFile(temporaryFileCreator), maxLength, allowEmptyFiles)

  /**
   * Parse the content as multipart/form-data
   *
   * @param filePartHandler Handles file parts.
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   *
   * @see [[DefaultMaxDiskLength]]
   * @see [[Results.EntityTooLarge]]
   */
  def multipartFormData[A](
      filePartHandler: Multipart.FilePartHandler[A],
      maxLength: Long
  ): BodyParser[MultipartFormData[A]] = multipartFormData(filePartHandler, maxLength, false)

  /**
   * Parse the content as multipart/form-data
   *
   * @param filePartHandler Handles file parts.
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   * @param allowEmptyFiles If empty file uploads are allowed (no matter if filename or file is empty)
   *
   * @see [[DefaultMaxDiskLength]]
   * @see [[Results.EntityTooLarge]]
   */
  def multipartFormData[A](
      filePartHandler: Multipart.FilePartHandler[A],
      maxLength: Long = DefaultMaxDiskLength,
      allowEmptyFiles: Boolean = DefaultAllowEmptyFileUploads
  ): BodyParser[MultipartFormData[A]] = {
    BodyParser("multipartFormData") { request =>
      val bodyAccumulator =
        Multipart.multipartParser(DefaultMaxTextLength, allowEmptyFiles, filePartHandler, errorHandler).apply(request)
      enforceMaxLength(request, maxLength, bodyAccumulator)
    }
  }

  protected def createBadResult(msg: String, statusCode: Int = BAD_REQUEST): RequestHeader => Future[Result] = {
    request =>
      errorHandler.onClientError(request, statusCode, msg)
  }

  /**
   * Enforce the max length on the stream consumed by the given accumulator.
   */
  private[play] def enforceMaxLength[A](
      request: RequestHeader,
      maxLength: Long,
      accumulator: Accumulator[ByteString, Either[Result, A]]
  ): Accumulator[ByteString, Either[Result, A]] = {
    if (BodyParserUtils.contentLengthHeaderExceedsMaxLength(request, maxLength)) {
      Accumulator.done(requestEntityTooLarge(request))
    } else {
      val takeUpToFlow = Flow.fromGraph(new BodyParsers.TakeUpTo(maxLength))
      Accumulator(takeUpToFlow.toMat(accumulator.toSink) { (statusFuture, resultFuture) =>
        statusFuture.flatMap {
          case MaxSizeExceeded(_) => requestEntityTooLarge(request)
          case MaxSizeNotExceeded => resultFuture
        }(Execution.trampoline)
      })
    }
  }

  /**
   * Create a body parser that uses the given parser and enforces the given max length.
   *
   * @param name The name of the body parser.
   * @param maxLength The maximum length of the body to buffer.
   * @param errorMessage The error message to prepend to the exception message if an error was encountered.
   * @param parser The parser.
   */
  protected def tolerantBodyParser[A](name: String, maxLength: Long, errorMessage: String)(
      parser: (RequestHeader, ByteString) => A
  ): BodyParser[A] =
    BodyParser(name + ", maxLength=" + maxLength) { request =>
      import Execution.Implicits.trampoline

      def parseBody(bytes: ByteString): Future[Either[Result, A]] = {
        try {
          Future.successful(Right(parser(request, bytes)))
        } catch {
          case NonFatal(e) =>
            logger.debug(errorMessage, e)
            createBadResult(errorMessage + ": " + e.getMessage)(request).map(Left(_))
        }
      }

      if (BodyParserUtils.contentLengthHeaderExceedsMaxLength(request, maxLength)) {
        Accumulator.done(requestEntityTooLarge(request))
      } else {
        Accumulator.strict[ByteString, Either[Result, A]](
          // If the body was strict
          {
            case Some(bytes) if bytes.size <= maxLength =>
              parseBody(bytes)
            case None =>
              parseBody(ByteString.empty)
            case _ => requestEntityTooLarge(request)
          },
          // Otherwise, use an enforce max length accumulator on a folding sink
          enforceMaxLength(
            request,
            maxLength,
            Accumulator(
              Sink.fold[ByteString, ByteString](ByteString.empty)((state, bs) => state ++ bs)
            ).mapFuture(parseBody)
          ).toSink
        )
      }
    }
}

/**
 * Default BodyParsers.
 */
object BodyParsers {

  /**
   * The default body parser provided by Play
   */
  class Default @Inject() (parse: PlayBodyParsers) extends BodyParser[AnyContent] {

    /**
     * An alternate constructor primarily designed for unit testing. Default values are set to empty or singleton
     * implementations where appropriate.
     */
    def this(
        tfc: TemporaryFileCreator = SingletonTemporaryFileCreator,
        eh: HttpErrorHandler = new DefaultHttpErrorHandler(),
        config: ParserConfiguration = ParserConfiguration()
    )(implicit mat: Materializer) = this(PlayBodyParsers(tfc, eh, config))
    override def apply(rh: RequestHeader) = parse.default(None)(rh)
  }

  object utils extends BodyParserUtils

  private[play] def takeUpTo(maxLength: Long): Graph[FlowShape[ByteString, ByteString], Future[MaxSizeStatus]] =
    new TakeUpTo(maxLength)

  private[play] class TakeUpTo(maxLength: Long)
      extends GraphStageWithMaterializedValue[FlowShape[ByteString, ByteString], Future[MaxSizeStatus]] {
    private val in  = Inlet[ByteString]("TakeUpTo.in")
    private val out = Outlet[ByteString]("TakeUpTo.out")

    override def shape: FlowShape[ByteString, ByteString] = FlowShape.of(in, out)

    override def createLogicAndMaterializedValue(
        inheritedAttributes: Attributes
    ): (GraphStageLogic, Future[MaxSizeStatus]) = {
      val status            = Promise[MaxSizeStatus]()
      var pushedBytes: Long = 0

      val logic = new GraphStageLogic(shape) {
        setHandler(out, new OutHandler {
          override def onPull(): Unit = {
            pull(in)
          }
          override def onDownstreamFinish(): Unit = {
            status.success(MaxSizeNotExceeded)
            completeStage()
          }
        })
        setHandler(
          in,
          new InHandler {
            override def onPush(): Unit = {
              val chunk = grab(in)
              pushedBytes += chunk.size
              if (pushedBytes > maxLength) {
                status.success(MaxSizeExceeded(maxLength))
                // Make sure we fail the stream, this will ensure downstream body parsers don't try to parse it
                failStage(new MaxLengthLimitAttained)
              } else {
                push(out, chunk)
              }
            }
            override def onUpstreamFinish(): Unit = {
              status.success(MaxSizeNotExceeded)
              completeStage()
            }
            override def onUpstreamFailure(ex: Throwable): Unit = {
              status.failure(ex)
              failStage(ex)
            }
          }
        )
      }

      (logic, status.future)
    }
  }

  private[play] class MaxLengthLimitAttained extends RuntimeException(null, null, false, false)
}

/**
 * The status of a max size flow.
 */
sealed trait MaxSizeStatus

/**
 * Signal a max content size exceeded.
 */
case class MaxSizeExceeded(length: Long) extends MaxSizeStatus

/**
 * Signal max size is not exceeded.
 */
case object MaxSizeNotExceeded extends MaxSizeStatus

[0m2021.04.01 16:46:32 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:46:32 INFO  time: compiled root in 0.73s[0m
[0m2021.04.01 16:48:31 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:48:31 INFO  time: compiled root in 0.19s[0m
/*
 * Copyright (C) Lightbend Inc. <https://www.lightbend.com>
 */

package play.api.mvc

import java.security.cert.X509Certificate
import java.util.Locale

import play.api.http.HeaderNames
import play.api.http.MediaRange
import play.api.http.MediaType
import play.api.i18n.Lang
import play.api.i18n.Messages
import play.api.libs.typedmap.TypedKey
import play.api.libs.typedmap.TypedMap
import play.api.mvc.request._

import scala.annotation.implicitNotFound

/**
 * The HTTP request header. Note that it doesn’t contain the request body yet.
 */
@implicitNotFound("Cannot find any HTTP Request Header here")
trait RequestHeader {
  top =>

  /**
   * The remote connection that made the request.
   */
  def connection: RemoteConnection

  def withConnection(newConnection: RemoteConnection): RequestHeader =
    new RequestHeaderImpl(newConnection, method, target, version, headers, attrs)

  /**
   * The request id. The request id is stored as an attribute indexed by [[play.api.mvc.request.RequestAttrKey.Id]].
   */
  final def id: Long = attrs(RequestAttrKey.Id)

  /**
   * The HTTP method.
   */
  def method: String

  /**
   * Return a new copy of the request with its method changed.
   */
  def withMethod(newMethod: String): RequestHeader =
    new RequestHeaderImpl(connection, newMethod, target, version, headers, attrs)

  /**
   * The target of the HTTP request, i.e. the URI or path that was
   * given on the first line of the request.
   */
  def target: RequestTarget

  /**
   * Return a new copy of the request with its target changed.
   */
  def withTarget(newTarget: RequestTarget): RequestHeader =
    new RequestHeaderImpl(connection, method, newTarget, version, headers, attrs)

  /**
   * The complete request URI, containing both path and query string.
   * The URI is what was on the status line after the request method.
   * E.g. in "GET /foo/bar?q=s HTTP/1.1" the URI should be /foo/bar?q=s.
   * It could be absolute, some clients send absolute URLs, especially proxies,
   * e.g. http://www.example.org/foo/bar?q=s.
   *
   * This method delegates to `target.uriString`.
   */
  final def uri: String = target.uriString

  /**
   * The URI path. This method delegates to `target.path`.
   */
  final def path: String = target.path

  /**
   * The HTTP version.
   */
  def version: String

  /**
   * Return a new copy of the request with its HTTP version changed.
   */
  def withVersion(newVersion: String): RequestHeader =
    new RequestHeaderImpl(connection, method, target, newVersion, headers, attrs)

  /**
   * The parsed query string. This method delegates to `target.queryMap`.
   */
  final def queryString: Map[String, Seq[String]] = target.queryMap

  /**
   * The HTTP headers.
   */
  def headers: Headers

  /**
   * The remote connection that made the request.
   */
  def withHeaders(newHeaders: Headers): RequestHeader =
    new RequestHeaderImpl(connection, method, target, version, newHeaders, attrs)

  /**
   * The client IP address.
   *
   * retrieves the last untrusted proxy
   * from the Forwarded-Headers or the X-Forwarded-*-Headers.
   *
   * This method delegates to `connection.remoteAddressString`.
   */
  final def remoteAddress: String = connection.remoteAddressString

  /**
   * Is the client using SSL? This method delegates to `connection.secure`.
   */
  final def secure: Boolean = connection.secure

  /**
   * The X509 certificate chain presented by a client during SSL requests.  This method is
   * equivalent to `connection.clientCertificateChain`.
   */
  final def clientCertificateChain: Option[Seq[X509Certificate]] = connection.clientCertificateChain

  /**
   * A map of typed attributes associated with the request.
   */
  def attrs: TypedMap

  /**
   * Create a new version of this object with the given attributes attached to it.
   * This replaces any existing attributes.
   *
   * @param newAttrs The new attributes to add.
   * @return The new version of this object with the attributes attached.
   */
  def withAttrs(newAttrs: TypedMap): RequestHeader =
    new RequestHeaderImpl(connection, method, target, version, headers, newAttrs)

  /**
   * Create a new versions of this object with the given attribute attached to it.
   *
   * @param key The new attribute key.
   * @param value  The attribute value.
   * @tparam A The type of value.
   * @return The new version of this object with the new attribute.
   */
  def addAttr[A](key: TypedKey[A], value: A): RequestHeader =
    withAttrs(attrs.updated(key, value))

  /**
   * Create a new versions of this object with the given attribute removed.
   *
   * @param key The key of the attribute to remove.
   * @return The new version of this object with the attribute removed.
   */
  def removeAttr(key: TypedKey[_]): RequestHeader =
    withAttrs(attrs - key)

  // -- Computed

  /**
   * Helper method to access a queryString parameter. This method delegates to `connection.getQueryParameter(key)`.
   *
   * @return The query parameter's value if the parameter is present
   *         and there is only one value. If the parameter is absent
   *         or there is more than one value for that parameter then
   *         `None` is returned.
   */
  def getQueryString(key: String): Option[String] = target.getQueryParameter(key)

  /**
   * True if this request has a body, so we know if we should trigger body parsing. The base implementation simply
   * checks for the Content-Length or Transfer-Encoding headers, but subclasses (such as fake requests) may return
   * true in other cases so the headers need not be updated to reflect the body.
   */
  def hasBody: Boolean = headers.hasBody

  /**
   * The HTTP host (domain, optionally port). This value is derived from the request target, if a hostname is present.
   * If the target doesn't have a host then the `Host` header is used, if present. If that's not present then an
   * empty string is returned.
   */
  lazy val host: String = {
    import RequestHeader.AbsoluteUri
    uri match {
      case AbsoluteUri(proto, hostPort, rest) => hostPort
      case _                                  => headers.get(HeaderNames.HOST).getOrElse("")
    }
  }

  /**
   * The HTTP domain. The domain part of the request's [[host]].
   */
  lazy val domain: String = host.split(':').head

  /**
   * The Request Langs extracted from the Accept-Language header and sorted by preference (preferred first).
   */
  lazy val acceptLanguages: Seq[play.api.i18n.Lang] = {
    val langs =
      RequestHeader.acceptHeader(headers, HeaderNames.ACCEPT_LANGUAGE).map(item => (item._1, Lang.get(item._2)))
    langs.sortWith((a, b) => a._1 > b._1).flatMap(_._2)
  }

  /**
   * @return The media types list of the request’s Accept header, sorted by preference (preferred first).
   */
  lazy val acceptedTypes: Seq[play.api.http.MediaRange] = {
    headers.get(HeaderNames.ACCEPT).toSeq.flatMap(MediaRange.parse.apply)
  }

  /**
   * Check if this request accepts a given media type.
   *
   * @return true if `mimeType` matches the Accept header, otherwise false
   */
  def accepts(mimeType: String): Boolean = {
    acceptedTypes.isEmpty || acceptedTypes.exists(_.accepts(mimeType))
  }

  /**
   * The HTTP cookies. The request's cookies are stored in an attribute indexed by
   * [[play.api.mvc.request.RequestAttrKey.Cookies]]. The attribute uses a Cell to store the cookies,
   * to allow them to be evaluated on-demand.
   */
  def cookies: Cookies = attrs(RequestAttrKey.Cookies).value

  /**
   * Parses the `Session` cookie and returns the `Session` data. The request's session cookie is stored in an attribute indexed by
   * [[play.api.mvc.request.RequestAttrKey.Session]]. The attribute uses a [[play.api.mvc.request.Cell]] to store the session cookie, to allow it to be evaluated on-demand.
   */
  def session: Session = attrs(RequestAttrKey.Session).value

  /**
   * Parses the `Flash` cookie and returns the `Flash` data. The request's flash cookie is stored in an attribute indexed by
   * [[play.api.mvc.request.RequestAttrKey.Flash]]. The attribute uses a [[play.api.mvc.request.Cell]] to store the flash, to allow it to be evaluated on-demand.
   */
  def flash: Flash = attrs(RequestAttrKey.Flash).value

  /**
   * Returns the raw query string. This method delegates to `connection.rawQueryString`.
   */
  def rawQueryString: String = target.queryString

  /**
   * The media type of this request.  Same as contentType, except returns a fully parsed media type with parameters.
   */
  lazy val mediaType: Option[MediaType] = headers.get(HeaderNames.CONTENT_TYPE).flatMap(MediaType.parse.apply)

  /**
   * Returns the value of the Content-Type header (without the parameters (eg charset))
   */
  lazy val contentType: Option[String] = mediaType.map(mt => mt.mediaType + "/" + mt.mediaSubType)

  /**
   * Returns the charset of the request for text-based body
   */
  lazy val charset: Option[String] = for {
    mt      <- mediaType
    param   <- mt.parameters.find(_._1.equalsIgnoreCase("charset"))
    charset <- param._2
  } yield charset

  /**
   * Attach a body to this header.
   *
   * @param body The body to attach.
   * @tparam A The type of the body.
   * @return A new request with the body attached to the header.
   */
  def withBody[A](body: A): Request[A] =
    new RequestImpl[A](connection, method, target, version, headers, attrs, body)

  /**
   * Create a new versions of this object with the given transient language set.
   * The transient language will be taken into account when using [[play.api.i18n.MessagesApi.preferred()]] (It will take precedence over any other language).
   *
   * @param lang The language to use.
   * @return The new version of this object with the given transient language set.
   */
  def withTransientLang(lang: Lang): RequestHeader =
    addAttr(Messages.Attrs.CurrentLang, lang)

  /**
   * Create a new versions of this object with the given transient language set.
   * The transient language will be taken into account when using [[play.api.i18n.MessagesApi.preferred()]] (It will take precedence over any other language).
   *
   * @param code The language to use.
   * @return The new version of this object with the given transient language set.
   */
  def withTransientLang(code: String): RequestHeader =
    withTransientLang(Lang(code))

  /**
   * Create a new versions of this object with the given transient language set.
   * The transient language will be taken into account when using [[play.api.i18n.MessagesApi.preferred()]] (It will take precedence over any other language).
   *
   * @param locale The language to use.
   * @return The new version of this object with the given transient language set.
   */
  def withTransientLang(locale: Locale): RequestHeader =
    withTransientLang(Lang(locale))

  /**
   * Create a new versions of this object with the given transient language removed.
   *
   * @return The new version of this object with the transient language removed.
   */
  def withoutTransientLang(): RequestHeader =
    removeAttr(Messages.Attrs.CurrentLang)

  /**
   * The transient language will be taken into account when using [[play.api.i18n.MessagesApi.preferred()]] (It will take precedence over any other language).
   *
   * @return The current transient language of this request.
   */
  def transientLang(): Option[Lang] =
    attrs.get(Messages.Attrs.CurrentLang)

  override def toString: String = {
    method + " " + uri
  }

  def asJava: play.mvc.Http.RequestHeader = new play.core.j.RequestHeaderImpl(this)
}

object RequestHeader {
  private val AbsoluteUri = """(?is)^(https?)://([^/]+)(/.*|$)""".r

  // “The first "q" parameter (if any) separates the media-range parameter(s) from the accept-params.”
  val qPattern = ";\\s*q=([0-9.]+)".r

  /**
   * @return The items of an Accept* header, with their q-value.
   */
  private[play] def acceptHeader(headers: Headers, headerName: String): Seq[(Double, String)] = {
    for {
      header <- headers.get(headerName).toList
      value0 <- header.split(',')
      value = value0.trim
    } yield {
      RequestHeader.qPattern.findFirstMatchIn(value) match {
        case Some(m) => (m.group(1).toDouble, m.before.toString)
        case None    => (1.0, value) // “The default value is q=1.”
      }
    }
  }
}

/**
 * A standard implementation of a RequestHeader.
 */
private[play] class RequestHeaderImpl(
    override val connection: RemoteConnection,
    override val method: String,
    override val target: RequestTarget,
    override val version: String,
    override val headers: Headers,
    override val attrs: TypedMap
) extends RequestHeader

/*
 * Copyright (C) Lightbend Inc. <https://www.lightbend.com>
 */

package play.api.mvc

import java.util.Locale
import java.util.Optional

import play.api.i18n.Lang
import play.api.i18n.Messages
import play.api.libs.typedmap.TypedKey
import play.api.libs.typedmap.TypedMap
import play.api.mvc.request.RemoteConnection
import play.api.mvc.request.RequestTarget
import play.mvc.Http

import scala.annotation.implicitNotFound
import scala.annotation.tailrec

/**
 * The complete HTTP request.
 *
 * @tparam A the body content type.
 */
@implicitNotFound("Cannot find any HTTP Request here")
trait Request[+A] extends RequestHeader {
  self =>

  /**
   * True if this request has a body. This is either done by inspecting the request headers or the body itself to see if
   * it is an entity representing an "empty" body.
   */
  override def hasBody: Boolean = {
    import play.api.http.HeaderNames._
    if (headers.get(CONTENT_LENGTH).isDefined || headers.get(TRANSFER_ENCODING).isDefined) {
      // A relevant header is set, which means this is a real request or a fake request used for testing where the user
      // cared about setting the headers. We can just use them to see if a body exists. In a real life production application,
      // where clients basically always send these headers when applicable (for requests that send bodies like POST, etc.)
      // we are very likely to enter this if branch.
      super.hasBody
    } else {
      // No relevant header present, very likely this is a real life GET request (or alike) without a body or a fake request
      // used for testing where the user did not care about setting the headers (but maybe did set an entity though).
      // Let's do our best to find out if there is an entity that represents an "empty" body.
      @tailrec @inline def isEmptyBody(body: Any): Boolean = body match {
        case rb: play.mvc.Http.RequestBody =>
          rb match {
            // In PlayJava, Optional.empty() is used to represent an empty body
            case _ if rb.as(classOf[Optional[_]]) != null => !rb.as(classOf[Optional[_]]).isPresent
            case _                                        => isEmptyBody(rb.as(classOf[AnyRef]))
          }
        case AnyContentAsEmpty | null | ()                      => true
        case unit if unit.isInstanceOf[scala.runtime.BoxedUnit] => true
        // All values which are known to represent an empty body have been checked, therefore, if we end up here, technically
        // it is sure something is set (at least it's not null), even though this something might represent "empty"/"no body"
        // (like an empty string or an empty ByteString) - but how should we know? This something could be a custom type
        // coming from a custom body parser defined entirely by the user... Sure, we could check for the most common types
        // if they represent an empty body (empty Strings, empty ByteString, etc.) but that would not be consistent
        // (custom types defined by the user that represent "empty" would still return false)
        case _ => false
      }

      !isEmptyBody(body)
    }
  }

  /**
   * The body content.
   */
  def body: A

  /**
   * Transform the request body.
   */
  def map[B](f: A => B): Request[B] = withBody(f(body))

  // Override the return type and default implementation of these RequestHeader methods
  override def withConnection(newConnection: RemoteConnection): Request[A] =
    new RequestImpl[A](newConnection, method, target, version, headers, attrs, body)
  override def withMethod(newMethod: String): Request[A] =
    new RequestImpl[A](connection, newMethod, target, version, headers, attrs, body)
  override def withTarget(newTarget: RequestTarget): Request[A] =
    new RequestImpl[A](connection, method, newTarget, version, headers, attrs, body)
  override def withVersion(newVersion: String): Request[A] =
    new RequestImpl[A](connection, method, target, newVersion, headers, attrs, body)
  override def withHeaders(newHeaders: Headers): Request[A] =
    new RequestImpl[A](connection, method, target, version, newHeaders, attrs, body)
  override def withAttrs(newAttrs: TypedMap): Request[A] =
    new RequestImpl[A](connection, method, target, version, headers, newAttrs, body)
  override def addAttr[B](key: TypedKey[B], value: B): Request[A] =
    withAttrs(attrs.updated(key, value))
  override def removeAttr(key: TypedKey[_]): Request[A] =
    withAttrs(attrs - key)
  override def withTransientLang(lang: Lang): Request[A] =
    addAttr(Messages.Attrs.CurrentLang, lang)
  override def withTransientLang(code: String): Request[A] =
    withTransientLang(Lang(code))
  override def withTransientLang(locale: Locale): Request[A] =
    withTransientLang(Lang(locale))
  override def withoutTransientLang(): Request[A] =
    removeAttr(Messages.Attrs.CurrentLang)

  override def asJava: Http.Request = this match {
    case req: Request[Http.RequestBody @unchecked] =>
      // This will preserve the parsed body since it is already using the Java body wrapper
      new Http.RequestImpl(req)
    case _ =>
      new Http.RequestImpl(this)
  }
}

object Request {

  /**
   * Create a new Request from a RequestHeader and a body. The RequestHeader's
   * methods aren't evaluated when this method is called.
   */
  def apply[A](rh: RequestHeader, body: A): Request[A] = rh.withBody(body)
}

/**
 * A standard implementation of a Request.
 *
 * @param body The body of the request.
 * @tparam A The type of the body content.
 */
private[play] class RequestImpl[+A](
    override val connection: RemoteConnection,
    override val method: String,
    override val target: RequestTarget,
    override val version: String,
    override val headers: Headers,
    override val attrs: TypedMap,
    override val body: A
) extends Request[A]

Apr 01, 2021 4:48:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3730
[0m2021.04.01 16:49:12 ERROR scalafmt: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala:22: error: illegal start of simple expression
    println("body: ", )
                      ^[0m
[0m2021.04.01 16:49:12 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:49:12 INFO  time: compiled root in 0.13s[0m
[0m2021.04.01 16:49:17 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:49:17 INFO  time: compiled root in 0.21s[0m
[0m2021.04.01 16:49:27 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:49:27 INFO  time: compiled root in 0.14s[0m
[0m2021.04.01 16:58:26 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 16:58:26 INFO  time: compiled root in 0.8s[0m
[0m2021.04.01 17:00:11 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 17:00:11 INFO  time: compiled root in 0.85s[0m
[0m2021.04.01 17:00:24 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 17:00:25 INFO  time: compiled root in 1s[0m
[0m2021.04.01 17:00:36 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 17:00:36 INFO  time: compiled root in 0.16s[0m
[0m2021.04.01 17:00:44 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 17:00:44 INFO  time: compiled root in 0.15s[0m
[0m2021.04.01 17:01:10 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 17:01:10 INFO  time: compiled root in 0.17s[0m
[0m2021.04.01 17:04:51 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 17:04:51 INFO  time: compiled root in 0.14s[0m
[0m2021.04.01 17:05:02 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 17:05:02 INFO  time: compiled root in 0.14s[0m
[0m2021.04.01 17:05:03 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 17:05:03 INFO  time: compiled root in 63ms[0m
[0m2021.04.01 17:05:34 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 17:05:34 INFO  time: compiled root in 0.14s[0m
[0m2021.04.01 17:05:40 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 17:05:40 INFO  time: compiled root in 0.17s[0m
[0m2021.04.01 17:06:04 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 17:06:04 INFO  time: compiled root in 0.15s[0m
[0m2021.04.01 17:06:58 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 17:06:58 INFO  time: compiled root in 0.14s[0m
[0m2021.04.01 17:07:10 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 17:07:10 INFO  time: compiled root in 0.15s[0m
[0m2021.04.01 17:07:17 INFO  compiling root (1 scala source)[0m
[0m2021.04.01 17:07:18 INFO  time: compiled root in 1.44s[0m
[0m2021.04.02 12:09:03 INFO  shutting down Metals[0m
[0m2021.04.02 12:09:04 INFO  Shut down connection with build server.[0m
[0m2021.04.02 12:09:04 INFO  Shut down connection with build server.[0m
[0m2021.04.02 12:09:04 INFO  Shut down connection with build server.[0m
No more data in the client stdin, exiting...
No more data in the client stdin, exiting...
No more data in the client stdin, exiting...
[0m2021.04.21 16:32:29 INFO  Started: Metals version 0.10.1 in workspace '/Users/davidashley/Documents/Scala/scalabackend/scalabackend' for client vscode 1.55.1.[0m
[0m2021.04.21 16:32:30 INFO  time: initialize in 0.5s[0m
[0m2021.04.21 16:32:30 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher4793852583454501055/bsp.socket'...
Waiting for the bsp connection to come up...
[0m2021.04.21 16:32:30 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/controllers/UsersController.scala[0m
[0m2021.04.21 16:32:30 INFO  skipping build import with status 'Installed'[0m
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher4793852583454501055/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher4793852583454501055/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.04.21 16:32:32 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.04.21 16:32:34 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m
[0m2021.04.21 16:32:35 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
[0m2021.04.21 16:32:35 INFO  Attempting to connect to the build server...Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher6152864332710861080/bsp.socket'...[0m

Waiting for the bsp connection to come up...
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher4712107288434745462/bsp.socket'...
Waiting for the bsp connection to come up...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher6152864332710861080/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher6152864332710861080/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.04.21 16:32:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher4712107288434745462/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher4712107288434745462/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.04.21 16:32:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.04.21 16:32:36 WARN  no build target for: /Users/davidashley/Documents/Scala/scalabackend/scalabackend/app/models/DatabaseExecutionContext.scala[0m
[0m2021.04.21 16:32:36 INFO  time: Connected to build server in 5.33s[0m
[0m2021.04.21 16:32:36 INFO  Connected to Build server: Bloop v1.4.8[0m
[0m2021.04.21 16:32:36 INFO  time: Imported build in 0.15s[0m
[0m2021.04.21 16:32:37 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m
[0m2021.04.21 16:32:37 INFO  time: code lens generation in 1.08s[0m
[0m2021.04.21 16:32:41 INFO  time: indexed workspace in 4.71s[0m
[0m2021.04.21 16:32:41 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.04.21 16:32:41 INFO  Deduplicating compilation of root from bsp client 'Metals 0.10.1' (since 9.286s)[0m
[0m2021.04.21 16:32:41 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.04.21 16:32:43 INFO  time: code lens generation in 12s[0m
[0m2021.04.21 16:32:44 INFO  time: compiled root in 3.21s[0m
[0m2021.04.21 16:32:44 INFO  compiling root-test (1 scala source)[0m
[0m2021.04.21 16:32:44 INFO  time: compiled root-test in 0.5s[0m
Apr 21, 2021 4:33:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 24
Apr 21, 2021 4:34:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 41
Apr 21, 2021 4:34:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 47
Apr 21, 2021 4:34:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 53
Apr 21, 2021 4:34:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 59
Apr 21, 2021 4:34:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 64
[0m2021.04.21 16:34:46 INFO  compiling root (1 scala source)[0m
[0m2021.04.21 16:34:46 INFO  time: compiled root in 0.91s[0m
Apr 21, 2021 5:04:53 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Apr 21, 2021 5:04:56 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
[0m2021.04.21 20:35:28 INFO  shutting down Metals[0m
[0m2021.04.21 20:35:28 INFO  Shut down connection with build server.[0m
[0m2021.04.21 20:35:28 INFO  Shut down connection with build server.[0m
[0m2021.04.21 20:35:28 INFO  Shut down connection with build server.[0m
No more data in the client stdin, exiting...
No more data in the client stdin, exiting...
No more data in the client stdin, exiting...
[0m2021.04.22 12:30:28 INFO  Started: Metals version 0.10.1 in workspace '/Users/davidashley/Documents/Scala/scalabackend/scalabackend' for client vscode 1.55.2.[0m
[0m2021.04.22 12:30:29 INFO  time: initialize in 0.58s[0m
[0m2021.04.22 12:30:29 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher2290475669831715813/bsp.socket'...
Waiting for the bsp connection to come up...
[0m2021.04.22 12:30:30 INFO  skipping build import with status 'Installed'[0m
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher2290475669831715813/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher2290475669831715813/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.04.22 12:30:30 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.04.22 12:30:30 INFO  Attempting to connect to the build server...[0m
[0m2021.04.22 12:30:30 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher5050079372422476337/bsp.socket'...
Waiting for the bsp connection to come up...
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher6576359080781766108/bsp.socket'...
Waiting for the bsp connection to come up...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher5050079372422476337/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher5050079372422476337/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.04.22 12:30:29 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher6576359080781766108/bsp.socket...
The server is listening for incoming connections at local:///var/folders/g5/72rs6xkj1b709qvrrw_1365h0000gn/T/bsp-launcher6576359080781766108/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.04.22 12:30:30 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/davidashley/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.04.22 12:30:30 INFO  time: Connected to build server in 0.92s[0m
[0m2021.04.22 12:30:30 INFO  Connected to Build server: Bloop v1.4.8[0m
[0m2021.04.22 12:30:36 INFO  time: indexed workspace in 5.13s[0m
